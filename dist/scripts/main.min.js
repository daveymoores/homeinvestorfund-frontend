!function(e){function n(r){if(t[r])return t[r].exports;var i=t[r]={exports:{},id:r,loaded:!1};return e[r].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var t={};n.m=e,n.c=t,n.p="",n(0)}([function(module,exports,__webpack_require__){eval('(function () {\n\t\'use strict\';\n\n\tvar widgets;\n    var $body = document.body;\n\n\twidgets = {\n\t\t"navigation" : __webpack_require__(1),\n\t\t"calculator" : __webpack_require__(2),\n\t\t"accordion" : __webpack_require__(4),\n\t\t"maps" : __webpack_require__(5),\n\t\t"property-map" : __webpack_require__(18),\n\t\t"carousel" : __webpack_require__(20),\n\t\t"contact-map" : __webpack_require__(22),\n\t\t"info-overlay" : __webpack_require__(23),\n\t\t"plyr-init" : __webpack_require__(24),\n\t\t"nav-tabs" : __webpack_require__(26),\n\t\t"staff-overlay" : __webpack_require__(27),\n\t\t"matrix" : __webpack_require__(28),\n\t\t"video-modal" : __webpack_require__(42),\n\t\t"equal-heights" : __webpack_require__(43),\n\t\t"share-btns" : __webpack_require__(44),\n\t\t"video-display" : __webpack_require__(45),\n\t\t"faq-carousel" : __webpack_require__(46),\n\t\t"faq-more-info" : __webpack_require__(47)\n\t};\n\n    function initWidgets ($node) {\n        var dw = $node.querySelectorAll(\'[data-widget]\');\n        Array.prototype.forEach.call(dw, function(el, index, array){\n            var type;\n            type = el.getAttribute(\'data-widget\');\n\n            if (widgets[type]) {\n                new widgets[type](el);\n            }\n        });\n    }\n\n    initWidgets($body);\n\n}());\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./assets/scripts/main.js\n// module id = 0\n// module chunks = 0\n//# sourceURL=webpack:///./assets/scripts/main.js?')},function(module,exports){eval("function Navigation(node){\n    this.node = node;\n    this.CLASSES();\n    this.init();\n}\n\nNavigation.prototype.CLASSES = function(){\n    this.CLASSES = {\n        states : {\n            'open' : 'open',\n            'active' : 'is-active'\n        },\n        selectors : {\n            'menuButton' : '.navigation--menu-button',\n            'dropdownToggle' : '.navigation__dropdown',\n            'dropdownPanel' : '.navigation__dropdown--panel',\n            'navigationMain' : '.navigation__list--main',\n            'navigationWrapper' : '.navigation__list--main'\n        }\n    }\n}\n\nNavigation.prototype.init = function(){\n    this.menuButton = this.node.querySelector(this.CLASSES.selectors.menuButton);\n    this.dropdownToggle = this.node.querySelector(this.CLASSES.selectors.dropdownToggle);\n    this.dropdownPanel = this.dropdownToggle.querySelector(this.CLASSES.selectors.dropdownPanel);\n    this.navigationMain = this.node.querySelector(this.CLASSES.selectors.navigationMain);\n    this.navigationWrapper = this.node.querySelector(this.CLASSES.selectors.navigationWrapper);\n\n    this.menuButton.addEventListener('click', this.openMenu.bind(this));\n}\n\nNavigation.prototype.openMenu = function(e){\n    var navHeight = this.navigationMain.getBoundingClientRect().height;\n    var wrapHeight = this.navigationWrapper.getBoundingClientRect().height;\n    var ww = window.innerHeight;\n    var hh = navHeight+wrapHeight;\n\n    if(ww<hh) {\n        hh = ww;\n    }\n\n    e.currentTarget.classList.toggle(this.CLASSES.states.active);\n    this.node.classList.toggle(this.CLASSES.states.open);\n\n    if(this.node.classList.contains(this.CLASSES.states.open)) {\n        this.node.style.maxHeight = hh+'px';\n    } else {\n        this.node.style.maxHeight = \"\";\n    }\n\n    e.preventDefault();\n}\n\nmodule.exports = Navigation;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./assets/scripts/widgets/navigation.js\n// module id = 1\n// module chunks = 0\n//# sourceURL=webpack:///./assets/scripts/widgets/navigation.js?")},function(module,exports,__webpack_require__){eval("//var rangeSlider = require(\"rangeslider-pure\");\nvar noUiSlider = __webpack_require__(3);\n\nfunction Calculator(node){\n    this.node = node;\n\n    this.setVars();\n    this.init();\n}\n\nCalculator.prototype.setVars = function(){\n    this.CLASSES = {\n        states : {},\n        selectors : {\n            'calcUnit' : '.calculator__amount--unit',\n            'calcSlider' : '.calculator--slider',\n            'calcStandardRate' : '.calculator__standard-rate',\n            'calcFundRate' : '.calculator__fund-rate'\n        }\n    }\n}\n\nCalculator.prototype.init = function(){\n    var cxt = this;\n    this.calcUnit = this.node.querySelector(this.CLASSES.selectors.calcUnit);\n    this.calcSlider = this.node.querySelector(this.CLASSES.selectors.calcSlider);\n    this.calcInput = this.calcSlider.querySelector('#slider');\n    this.calcStandardRate = this.node.querySelector(this.CLASSES.selectors.calcStandardRate);\n    this.calcFundRate = this.node.querySelector(this.CLASSES.selectors.calcFundRate);\n\n    this.calcUnit.addEventListener('keyup', this.handleInput.bind(this));\n\n    this.setSlider();\n}\n\nCalculator.prototype.handleInput = function(e){\n    var value = e.currentTarget.innerText;\n    var plainValue = value.replace(/\\,/g,'');\n\n    this.calcSlider.rangeSlider.update({value : plainValue});\n    this.calcStandardRate.innerText = this.calcInterest(plainValue)[0];\n    this.calcFundRate.innerText = this.calcInterest(plainValue)[1];\n}\n\nCalculator.prototype.setSlider = function(){\n    var cxt = this;\n\n    noUiSlider.create(this.calcInput, {\n    \tstart: [ 0, 25000 ],\n        connect: true,\n        step: 100,\n    \trange: {\n    \t\t'min': [  100 ],\n    \t\t'max': [ 150000 ]\n    \t}\n    });\n\n    // this.calcInput.noUiSlider.set([0, 25000]);\n    //\n    // this.calcInput.noUiSlider.on('set', function(values, handle){\n    //     cxt.calcUnit.innerText = Math.round(values[1]).toLocaleString();\n    //     cxt.calcStandardRate.innerText = cxt.calcInterest(values[1])[0];\n    //     cxt.calcFundRate.innerText = cxt.calcInterest(values[1])[1];\n    // });\n\n    this.calcInput.noUiSlider.on('slide', function(values, handle){\n        cxt.calcUnit.innerText = Math.round(values[1]).toLocaleString();\n        cxt.calcStandardRate.innerText = cxt.calcInterest(values[1])[0];\n        cxt.calcFundRate.innerText = cxt.calcInterest(values[1])[1];\n    });\n\n    // this.calcInput.noUiSlider.on('end', function(values, handle){\n    //     console.log(values);\n    // });\n}\n\nCalculator.prototype.calcInterest = function(amount){\n    var r = 1.8/100;\n    var R = 35.73/100;\n    var standardRate = Math.round(amount*(1 + (r * 5)));\n    var fundRate = Math.round(amount*(1 + (R * 5)));\n    return [standardRate.toLocaleString(), fundRate.toLocaleString()];\n}\n\nmodule.exports = Calculator;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./assets/scripts/widgets/calculator.js\n// module id = 2\n// module chunks = 0\n//# sourceURL=webpack:///./assets/scripts/widgets/calculator.js?")},function(module,exports,__webpack_require__){
eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! nouislider - 10.1.0 - 2017-07-28 17:11:18 */\n\n(function (factory) {\n\n    if ( true ) {\n\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    } else if ( typeof exports === 'object' ) {\n\n        // Node/CommonJS\n        module.exports = factory();\n\n    } else {\n\n        // Browser globals\n        window.noUiSlider = factory();\n    }\n\n}(function( ){\n\n\t'use strict';\n\n\tvar VERSION = '10.1.0';\n\n\n\tfunction isValidFormatter ( entry ) {\n\t\treturn typeof entry === 'object' && typeof entry.to === 'function' && typeof entry.from === 'function';\n\t}\n\n\tfunction removeElement ( el ) {\n\t\tel.parentElement.removeChild(el);\n\t}\n\n\t// Bindable version\n\tfunction preventDefault ( e ) {\n\t\te.preventDefault();\n\t}\n\n\t// Removes duplicates from an array.\n\tfunction unique ( array ) {\n\t\treturn array.filter(function(a){\n\t\t\treturn !this[a] ? this[a] = true : false;\n\t\t}, {});\n\t}\n\n\t// Round a value to the closest 'to'.\n\tfunction closest ( value, to ) {\n\t\treturn Math.round(value / to) * to;\n\t}\n\n\t// Current position of an element relative to the document.\n\tfunction offset ( elem, orientation ) {\n\n\t\tvar rect = elem.getBoundingClientRect();\n\t\tvar doc = elem.ownerDocument;\n\t\tvar docElem = doc.documentElement;\n\t\tvar pageOffset = getPageOffset(doc);\n\n\t\t// getBoundingClientRect contains left scroll in Chrome on Android.\n\t\t// I haven't found a feature detection that proves this. Worst case\n\t\t// scenario on mis-match: the 'tap' feature on horizontal sliders breaks.\n\t\tif ( /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) ) {\n\t\t\tpageOffset.x = 0;\n\t\t}\n\n\t\treturn orientation ? (rect.top + pageOffset.y - docElem.clientTop) : (rect.left + pageOffset.x - docElem.clientLeft);\n\t}\n\n\t// Checks whether a value is numerical.\n\tfunction isNumeric ( a ) {\n\t\treturn typeof a === 'number' && !isNaN( a ) && isFinite( a );\n\t}\n\n\t// Sets a class and removes it after [duration] ms.\n\tfunction addClassFor ( element, className, duration ) {\n\t\tif (duration > 0) {\n\t\taddClass(element, className);\n\t\t\tsetTimeout(function(){\n\t\t\t\tremoveClass(element, className);\n\t\t\t}, duration);\n\t\t}\n\t}\n\n\t// Limits a value to 0 - 100\n\tfunction limit ( a ) {\n\t\treturn Math.max(Math.min(a, 100), 0);\n\t}\n\n\t// Wraps a variable as an array, if it isn't one yet.\n\t// Note that an input array is returned by reference!\n\tfunction asArray ( a ) {\n\t\treturn Array.isArray(a) ? a : [a];\n\t}\n\n\t// Counts decimals\n\tfunction countDecimals ( numStr ) {\n\t\tnumStr = String(numStr);\n\t\tvar pieces = numStr.split(\".\");\n\t\treturn pieces.length > 1 ? pieces[1].length : 0;\n\t}\n\n\t// http://youmightnotneedjquery.com/#add_class\n\tfunction addClass ( el, className ) {\n\t\tif ( el.classList ) {\n\t\t\tel.classList.add(className);\n\t\t} else {\n\t\t\tel.className += ' ' + className;\n\t\t}\n\t}\n\n\t// http://youmightnotneedjquery.com/#remove_class\n\tfunction removeClass ( el, className ) {\n\t\tif ( el.classList ) {\n\t\t\tel.classList.remove(className);\n\t\t} else {\n\t\t\tel.className = el.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n\t\t}\n\t}\n\n\t// https://plainjs.com/javascript/attributes/adding-removing-and-testing-for-classes-9/\n\tfunction hasClass ( el, className ) {\n\t\treturn el.classList ? el.classList.contains(className) : new RegExp('\\\\b' + className + '\\\\b').test(el.className);\n\t}\n\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes\n\tfunction getPageOffset ( doc ) {\n\n\t\tvar supportPageOffset = window.pageXOffset !== undefined;\n\t\tvar isCSS1Compat = ((doc.compatMode || \"\") === \"CSS1Compat\");\n\t\tvar x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc.documentElement.scrollLeft : doc.body.scrollLeft;\n\t\tvar y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc.documentElement.scrollTop : doc.body.scrollTop;\n\n\t\treturn {\n\t\t\tx: x,\n\t\t\ty: y\n\t\t};\n\t}\n\n\t// we provide a function to compute constants instead\n\t// of accessing window.* as soon as the module needs it\n\t// so that we do not compute anything if not needed\n\tfunction getActions ( ) {\n\n\t\t// Determine the events to bind. IE11 implements pointerEvents without\n\t\t// a prefix, which breaks compatibility with the IE10 implementation.\n\t\treturn window.navigator.pointerEnabled ? {\n\t\t\tstart: 'pointerdown',\n\t\t\tmove: 'pointermove',\n\t\t\tend: 'pointerup'\n\t\t} : window.navigator.msPointerEnabled ? {\n\t\t\tstart: 'MSPointerDown',\n\t\t\tmove: 'MSPointerMove',\n\t\t\tend: 'MSPointerUp'\n\t\t} : {\n\t\t\tstart: 'mousedown touchstart',\n\t\t\tmove: 'mousemove touchmove',\n\t\t\tend: 'mouseup touchend'\n\t\t};\n\t}\n\n\t// https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n\t// Issue #785\n\tfunction getSupportsPassive ( ) {\n\n\t\tvar supportsPassive = false;\n\n\t\ttry {\n\n\t\t\tvar opts = Object.defineProperty({}, 'passive', {\n\t\t\t\tget: function() {\n\t\t\t\t\tsupportsPassive = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\twindow.addEventListener('test', null, opts);\n\n\t\t} catch (e) {}\n\n\t\treturn supportsPassive;\n\t}\n\n\tfunction getSupportsTouchActionNone ( ) {\n\t\treturn window.CSS && CSS.supports && CSS.supports('touch-action', 'none');\n\t}\n\n\n// Value calculation\n\n\t// Determine the size of a sub-range in relation to a full range.\n\tfunction subRangeRatio ( pa, pb ) {\n\t\treturn (100 / (pb - pa));\n\t}\n\n\t// (percentage) How many percent is this value of this range?\n\tfunction fromPercentage ( range, value ) {\n\t\treturn (value * 100) / ( range[1] - range[0] );\n\t}\n\n\t// (percentage) Where is this value on this range?\n\tfunction toPercentage ( range, value ) {\n\t\treturn fromPercentage( range, range[0] < 0 ?\n\t\t\tvalue + Math.abs(range[0]) :\n\t\t\t\tvalue - range[0] );\n\t}\n\n\t// (value) How much is this percentage on this range?\n\tfunction isPercentage ( range, value ) {\n\t\treturn ((value * ( range[1] - range[0] )) / 100) + range[0];\n\t}\n\n\n// Range conversion\n\n\tfunction getJ ( value, arr ) {\n\n\t\tvar j = 1;\n\n\t\twhile ( value >= arr[j] ){\n\t\t\tj += 1;\n\t\t}\n\n\t\treturn j;\n\t}\n\n\t// (percentage) Input a value, find where, on a scale of 0-100, it applies.\n\tfunction toStepping ( xVal, xPct, value ) {\n\n\t\tif ( value >= xVal.slice(-1)[0] ){\n\t\t\treturn 100;\n\t\t}\n\n\t\tvar j = getJ( value, xVal ), va, vb, pa, pb;\n\n\t\tva = xVal[j-1];\n\t\tvb = xVal[j];\n\t\tpa = xPct[j-1];\n\t\tpb = xPct[j];\n\n\t\treturn pa + (toPercentage([va, vb], value) / subRangeRatio (pa, pb));\n\t}\n\n\t// (value) Input a percentage, find where it is on the specified range.\n\tfunction fromStepping ( xVal, xPct, value ) {\n\n\t\t// There is no range group that fits 100\n\t\tif ( value >= 100 ){\n\t\t\treturn xVal.slice(-1)[0];\n\t\t}\n\n\t\tvar j = getJ( value, xPct ), va, vb, pa, pb;\n\n\t\tva = xVal[j-1];\n\t\tvb = xVal[j];\n\t\tpa = xPct[j-1];\n\t\tpb = xPct[j];\n\n\t\treturn isPercentage([va, vb], (value - pa) * subRangeRatio (pa, pb));\n\t}\n\n\t// (percentage) Get the step that applies at a certain value.\n\tfunction getStep ( xPct, xSteps, snap, value ) {\n\n\t\tif ( value === 100 ) {\n\t\t\treturn value;\n\t\t}\n\n\t\tvar j = getJ( value, xPct ), a, b;\n\n\t\t// If 'snap' is set, steps are used as fixed points on the slider.\n\t\tif ( snap ) {\n\n\t\t\ta = xPct[j-1];\n\t\t\tb = xPct[j];\n\n\t\t\t// Find the closest position, a or b.\n\t\t\tif ((value - a) > ((b-a)/2)){\n\t\t\t\treturn b;\n\t\t\t}\n\n\t\t\treturn a;\n\t\t}\n\n\t\tif ( !xSteps[j-1] ){\n\t\t\treturn value;\n\t\t}\n\n\t\treturn xPct[j-1] + closest(\n\t\t\tvalue - xPct[j-1],\n\t\t\txSteps[j-1]\n\t\t);\n\t}\n\n\n// Entry parsing\n\n\tfunction handleEntryPoint ( index, value, that ) {\n\n\t\tvar percentage;\n\n\t\t// Wrap numerical input in an array.\n\t\tif ( typeof value === \"number\" ) {\n\t\t\tvalue = [value];\n\t\t}\n\n\t\t// Reject any invalid input, by testing whether value is an array.\n\t\tif ( Object.prototype.toString.call( value ) !== '[object Array]' ){\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'range' contains invalid value.\");\n\t\t}\n\n\t\t// Covert min/max syntax to 0 and 100.\n\t\tif ( index === 'min' ) {\n\t\t\tpercentage = 0;\n\t\t} else if ( index === 'max' ) {\n\t\t\tpercentage = 100;\n\t\t} else {\n\t\t\tpercentage = parseFloat( index );\n\t\t}\n\n\t\t// Check for correct input.\n\t\tif ( !isNumeric( percentage ) || !isNumeric( value[0] ) ) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'range' value isn't numeric.\");\n\t\t}\n\n\t\t// Store values.\n\t\tthat.xPct.push( percentage );\n\t\tthat.xVal.push( value[0] );\n\n\t\t// NaN will evaluate to false too, but to keep\n\t\t// logging clear, set step explicitly. Make sure\n\t\t// not to override the 'step' setting with false.\n\t\tif ( !percentage ) {\n\t\t\tif ( !isNaN( value[1] ) ) {\n\t\t\t\tthat.xSteps[0] = value[1];\n\t\t\t}\n\t\t} else {\n\t\t\tthat.xSteps.push( isNaN(value[1]) ? false : value[1] );\n\t\t}\n\n\t\tthat.xHighestCompleteStep.push(0);\n\t}\n\n\tfunction handleStepPoint ( i, n, that ) {\n\n\t\t// Ignore 'false' stepping.\n\t\tif ( !n ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Factor to range ratio\n\t\tthat.xSteps[i] = fromPercentage([\n\t\t\t that.xVal[i]\n\t\t\t,that.xVal[i+1]\n\t\t], n) / subRangeRatio (\n\t\t\tthat.xPct[i],\n\t\t\tthat.xPct[i+1] );\n\n\t\tvar totalSteps = (that.xVal[i+1] - that.xVal[i]) / that.xNumSteps[i];\n\t\tvar highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);\n\t\tvar step = that.xVal[i] + (that.xNumSteps[i] * highestStep);\n\n\t\tthat.xHighestCompleteStep[i] = step;\n\t}\n\n\n// Interface\n\n\tfunction Spectrum ( entry, snap, singleStep ) {\n\n\t\tthis.xPct = [];\n\t\tthis.xVal = [];\n\t\tthis.xSteps = [ singleStep || false ];\n\t\tthis.xNumSteps = [ false ];\n\t\tthis.xHighestCompleteStep = [];\n\n\t\tthis.snap = snap;\n\n\t\tvar index, ordered = [ /* [0, 'min'], [1, '50%'], [2, 'max'] */ ];\n\n\t\t// Map the object keys to an array.\n\t\tfor ( index in entry ) {\n\t\t\tif ( entry.hasOwnProperty(index) ) {\n\t\t\t\tordered.push([entry[index], index]);\n\t\t\t}\n\t\t}\n\n\t\t// Sort all entries by value (numeric sort).\n\t\tif ( ordered.length && typeof ordered[0][0] === \"object\" ) {\n\t\t\tordered.sort(function(a, b) { return a[0][0] - b[0][0]; });\n\t\t} else {\n\t\t\tordered.sort(function(a, b) { return a[0] - b[0]; });\n\t\t}\n\n\n\t\t// Convert all entries to subranges.\n\t\tfor ( index = 0; index < ordered.length; index++ ) {\n\t\t\thandleEntryPoint(ordered[index][1], ordered[index][0], this);\n\t\t}\n\n\t\t// Store the actual step values.\n\t\t// xSteps is sorted in the same order as xPct and xVal.\n\t\tthis.xNumSteps = this.xSteps.slice(0);\n\n\t\t// Convert all numeric steps to the percentage of the subrange they represent.\n\t\tfor ( index = 0; index < this.xNumSteps.length; index++ ) {\n\t\t\thandleStepPoint(index, this.xNumSteps[index], this);\n\t\t}\n\t}\n\n\tSpectrum.prototype.getMargin = function ( value ) {\n\n\t\tvar step = this.xNumSteps[0];\n\n\t\tif ( step && ((value / step) % 1) !== 0 ) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'limit', 'margin' and 'padding' must be divisible by step.\");\n\t\t}\n\n\t\treturn this.xPct.length === 2 ? fromPercentage(this.xVal, value) : false;\n\t};\n\n\tSpectrum.prototype.toStepping = function ( value ) {\n\n\t\tvalue = toStepping( this.xVal, this.xPct, value );\n\n\t\treturn value;\n\t};\n\n\tSpectrum.prototype.fromStepping = function ( value ) {\n\n\t\treturn fromStepping( this.xVal, this.xPct, value );\n\t};\n\n\tSpectrum.prototype.getStep = function ( value ) {\n\n\t\tvalue = getStep(this.xPct, this.xSteps, this.snap, value );\n\n\t\treturn value;\n\t};\n\n\tSpectrum.prototype.getNearbySteps = function ( value ) {\n\n\t\tvar j = getJ(value, this.xPct);\n\n\t\treturn {\n\t\t\tstepBefore: { startValue: this.xVal[j-2], step: this.xNumSteps[j-2], highestStep: this.xHighestCompleteStep[j-2] },\n\t\t\tthisStep: { startValue: this.xVal[j-1], step: this.xNumSteps[j-1], highestStep: this.xHighestCompleteStep[j-1] },\n\t\t\tstepAfter: { startValue: this.xVal[j-0], step: this.xNumSteps[j-0], highestStep: this.xHighestCompleteStep[j-0] }\n\t\t};\n\t};\n\n\tSpectrum.prototype.countStepDecimals = function () {\n\t\tvar stepDecimals = this.xNumSteps.map(countDecimals);\n\t\treturn Math.max.apply(null, stepDecimals);\n \t};\n\n\t// Outside testing\n\tSpectrum.prototype.convert = function ( value ) {\n\t\treturn this.getStep(this.toStepping(value));\n\t};\n\n/*\tEvery input option is tested and parsed. This'll prevent\n\tendless validation in internal methods. These tests are\n\tstructured with an item for every option available. An\n\toption can be marked as required by setting the 'r' flag.\n\tThe testing function is provided with three arguments:\n\t\t- The provided value for the option;\n\t\t- A reference to the options object;\n\t\t- The name for the option;\n\n\tThe testing function returns false when an error is detected,\n\tor true when everything is OK. It can also modify the option\n\tobject, to make sure all values can be correctly looped elsewhere. */\n\n\tvar defaultFormatter = { 'to': function( value ){\n\t\treturn value !== undefined && value.toFixed(2);\n\t}, 'from': Number };\n\n\tfunction validateFormat ( entry ) {\n\n\t\t// Any object with a to and from method is supported.\n\t\tif ( isValidFormatter(entry) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'format' requires 'to' and 'from' methods.\");\n\t}\n\n\tfunction testStep ( parsed, entry ) {\n\n\t\tif ( !isNumeric( entry ) ) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'step' is not numeric.\");\n\t\t}\n\n\t\t// The step option can still be used to set stepping\n\t\t// for linear sliders. Overwritten if set in 'range'.\n\t\tparsed.singleStep = entry;\n\t}\n\n\tfunction testRange ( parsed, entry ) {\n\n\t\t// Filter incorrect input.\n\t\tif ( typeof entry !== 'object' || Array.isArray(entry) ) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'range' is not an object.\");\n\t\t}\n\n\t\t// Catch missing start or end.\n\t\tif ( entry.min === undefined || entry.max === undefined ) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): Missing 'min' or 'max' in 'range'.\");\n\t\t}\n\n\t\t// Catch equal start or end.\n\t\tif ( entry.min === entry.max ) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'range' 'min' and 'max' cannot be equal.\");\n\t\t}\n\n\t\tparsed.spectrum = new Spectrum(entry, parsed.snap, parsed.singleStep);\n\t}\n\n\tfunction testStart ( parsed, entry ) {\n\n\t\tentry = asArray(entry);\n\n\t\t// Validate input. Values aren't tested, as the public .val method\n\t\t// will always provide a valid location.\n\t\tif ( !Array.isArray( entry ) || !entry.length ) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'start' option is incorrect.\");\n\t\t}\n\n\t\t// Store the number of handles.\n\t\tparsed.handles = entry.length;\n\n\t\t// When the slider is initialized, the .val method will\n\t\t// be called with the start options.\n\t\tparsed.start = entry;\n\t}\n\n\tfunction testSnap ( parsed, entry ) {\n\n\t\t// Enforce 100% stepping within subranges.\n\t\tparsed.snap = entry;\n\n\t\tif ( typeof entry !== 'boolean' ){\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'snap' option must be a boolean.\");\n\t\t}\n\t}\n\n\tfunction testAnimate ( parsed, entry ) {\n\n\t\t// Enforce 100% stepping within subranges.\n\t\tparsed.animate = entry;\n\n\t\tif ( typeof entry !== 'boolean' ){\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'animate' option must be a boolean.\");\n\t\t}\n\t}\n\n\tfunction testAnimationDuration ( parsed, entry ) {\n\n\t\tparsed.animationDuration = entry;\n\n\t\tif ( typeof entry !== 'number' ){\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'animationDuration' option must be a number.\");\n\t\t}\n\t}\n\n\tfunction testConnect ( parsed, entry ) {\n\n\t\tvar connect = [false];\n\t\tvar i;\n\n\t\t// Map legacy options\n\t\tif ( entry === 'lower' ) {\n\t\t\tentry = [true, false];\n\t\t}\n\n\t\telse if ( entry === 'upper' ) {\n\t\t\tentry = [false, true];\n\t\t}\n\n\t\t// Handle boolean options\n\t\tif ( entry === true || entry === false ) {\n\n\t\t\tfor ( i = 1; i < parsed.handles; i++ ) {\n\t\t\t\tconnect.push(entry);\n\t\t\t}\n\n\t\t\tconnect.push(false);\n\t\t}\n\n\t\t// Reject invalid input\n\t\telse if ( !Array.isArray( entry ) || !entry.length || entry.length !== parsed.handles + 1 ) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'connect' option doesn't match handle count.\");\n\t\t}\n\n\t\telse {\n\t\t\tconnect = entry;\n\t\t}\n\n\t\tparsed.connect = connect;\n\t}\n\n\tfunction testOrientation ( parsed, entry ) {\n\n\t\t// Set orientation to an a numerical value for easy\n\t\t// array selection.\n\t\tswitch ( entry ){\n\t\t  case 'horizontal':\n\t\t\tparsed.ort = 0;\n\t\t\tbreak;\n\t\t  case 'vertical':\n\t\t\tparsed.ort = 1;\n\t\t\tbreak;\n\t\t  default:\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'orientation' option is invalid.\");\n\t\t}\n\t}\n\n\tfunction testMargin ( parsed, entry ) {\n\n\t\tif ( !isNumeric(entry) ){\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'margin' option must be numeric.\");\n\t\t}\n\n\t\t// Issue #582\n\t\tif ( entry === 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tparsed.margin = parsed.spectrum.getMargin(entry);\n\n\t\tif ( !parsed.margin ) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'margin' option is only supported on linear sliders.\");\n\t\t}\n\t}\n\n\tfunction testLimit ( parsed, entry ) {\n\n\t\tif ( !isNumeric(entry) ){\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'limit' option must be numeric.\");\n\t\t}\n\n\t\tparsed.limit = parsed.spectrum.getMargin(entry);\n\n\t\tif ( !parsed.limit || parsed.handles < 2 ) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'limit' option is only supported on linear sliders with 2 or more handles.\");\n\t\t}\n\t}\n\n\tfunction testPadding ( parsed, entry ) {\n\n\t\tif ( !isNumeric(entry) ){\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'padding' option must be numeric.\");\n\t\t}\n\n\t\tif ( entry === 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tparsed.padding = parsed.spectrum.getMargin(entry);\n\n\t\tif ( !parsed.padding ) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'padding' option is only supported on linear sliders.\");\n\t\t}\n\n\t\tif ( parsed.padding < 0 ) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'padding' option must be a positive number.\");\n\t\t}\n\n\t\tif ( parsed.padding >= 50 ) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'padding' option must be less than half the range.\");\n\t\t}\n\t}\n\n\tfunction testDirection ( parsed, entry ) {\n\n\t\t// Set direction as a numerical value for easy parsing.\n\t\t// Invert connection for RTL sliders, so that the proper\n\t\t// handles get the connect/background classes.\n\t\tswitch ( entry ) {\n\t\t  case 'ltr':\n\t\t\tparsed.dir = 0;\n\t\t\tbreak;\n\t\t  case 'rtl':\n\t\t\tparsed.dir = 1;\n\t\t\tbreak;\n\t\t  default:\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'direction' option was not recognized.\");\n\t\t}\n\t}\n\n\tfunction testBehaviour ( parsed, entry ) {\n\n\t\t// Make sure the input is a string.\n\t\tif ( typeof entry !== 'string' ) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'behaviour' must be a string containing options.\");\n\t\t}\n\n\t\t// Check if the string contains any keywords.\n\t\t// None are required.\n\t\tvar tap = entry.indexOf('tap') >= 0;\n\t\tvar drag = entry.indexOf('drag') >= 0;\n\t\tvar fixed = entry.indexOf('fixed') >= 0;\n\t\tvar snap = entry.indexOf('snap') >= 0;\n\t\tvar hover = entry.indexOf('hover') >= 0;\n\n\t\tif ( fixed ) {\n\n\t\t\tif ( parsed.handles !== 2 ) {\n\t\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'fixed' behaviour must be used with 2 handles\");\n\t\t\t}\n\n\t\t\t// Use margin to enforce fixed state\n\t\t\ttestMargin(parsed, parsed.start[1] - parsed.start[0]);\n\t\t}\n\n\t\tparsed.events = {\n\t\t\ttap: tap || snap,\n\t\t\tdrag: drag,\n\t\t\tfixed: fixed,\n\t\t\tsnap: snap,\n\t\t\thover: hover\n\t\t};\n\t}\n\n\tfunction testMultitouch ( parsed, entry ) {\n\t\tparsed.multitouch = entry;\n\n\t\tif ( typeof entry !== 'boolean' ){\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'multitouch' option must be a boolean.\");\n\t\t}\n\t}\n\n\tfunction testTooltips ( parsed, entry ) {\n\n\t\tif ( entry === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\telse if ( entry === true ) {\n\n\t\t\tparsed.tooltips = [];\n\n\t\t\tfor ( var i = 0; i < parsed.handles; i++ ) {\n\t\t\t\tparsed.tooltips.push(true);\n\t\t\t}\n\t\t}\n\n\t\telse {\n\n\t\t\tparsed.tooltips = asArray(entry);\n\n\t\t\tif ( parsed.tooltips.length !== parsed.handles ) {\n\t\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): must pass a formatter for all handles.\");\n\t\t\t}\n\n\t\t\tparsed.tooltips.forEach(function(formatter){\n\t\t\t\tif ( typeof formatter !== 'boolean' && (typeof formatter !== 'object' || typeof formatter.to !== 'function') ) {\n\t\t\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'tooltips' must be passed a formatter or 'false'.\");\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction testAriaFormat ( parsed, entry ) {\n\t\tparsed.ariaFormat = entry;\n\t\tvalidateFormat(entry);\n\t}\n\n\tfunction testFormat ( parsed, entry ) {\n\t\tparsed.format = entry;\n\t\tvalidateFormat(entry);\n\t}\n\n\tfunction testCssPrefix ( parsed, entry ) {\n\n\t\tif ( entry !== undefined && typeof entry !== 'string' && entry !== false ) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'cssPrefix' must be a string or `false`.\");\n\t\t}\n\n\t\tparsed.cssPrefix = entry;\n\t}\n\n\tfunction testCssClasses ( parsed, entry ) {\n\n\t\tif ( entry !== undefined && typeof entry !== 'object' ) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'cssClasses' must be an object.\");\n\t\t}\n\n\t\tif ( typeof parsed.cssPrefix === 'string' ) {\n\t\t\tparsed.cssClasses = {};\n\n\t\t\tfor ( var key in entry ) {\n\t\t\t\tif ( !entry.hasOwnProperty(key) ) { continue; }\n\n\t\t\t\tparsed.cssClasses[key] = parsed.cssPrefix + entry[key];\n\t\t\t}\n\t\t} else {\n\t\t\tparsed.cssClasses = entry;\n\t\t}\n\t}\n\n\tfunction testUseRaf ( parsed, entry ) {\n\t\tif ( entry === true || entry === false ) {\n\t\t\tparsed.useRequestAnimationFrame = entry;\n\t\t} else {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'useRequestAnimationFrame' option should be true (default) or false.\");\n\t\t}\n\t}\n\n\t// Test all developer settings and parse to assumption-safe values.\n\tfunction testOptions ( options ) {\n\n\t\t// To prove a fix for #537, freeze options here.\n\t\t// If the object is modified, an error will be thrown.\n\t\t// Object.freeze(options);\n\n\t\tvar parsed = {\n\t\t\tmargin: 0,\n\t\t\tlimit: 0,\n\t\t\tpadding: 0,\n\t\t\tanimate: true,\n\t\t\tanimationDuration: 300,\n\t\t\tariaFormat: defaultFormatter,\n\t\t\tformat: defaultFormatter\n\t\t};\n\n\t\t// Tests are executed in the order they are presented here.\n\t\tvar tests = {\n\t\t\t'step': { r: false, t: testStep },\n\t\t\t'start': { r: true, t: testStart },\n\t\t\t'connect': { r: true, t: testConnect },\n\t\t\t'direction': { r: true, t: testDirection },\n\t\t\t'snap': { r: false, t: testSnap },\n\t\t\t'animate': { r: false, t: testAnimate },\n\t\t\t'animationDuration': { r: false, t: testAnimationDuration },\n\t\t\t'range': { r: true, t: testRange },\n\t\t\t'orientation': { r: false, t: testOrientation },\n\t\t\t'margin': { r: false, t: testMargin },\n\t\t\t'limit': { r: false, t: testLimit },\n\t\t\t'padding': { r: false, t: testPadding },\n\t\t\t'behaviour': { r: true, t: testBehaviour },\n\t\t\t'multitouch': { r: true, t: testMultitouch },\n\t\t\t'ariaFormat': { r: false, t: testAriaFormat },\n\t\t\t'format': { r: false, t: testFormat },\n\t\t\t'tooltips': { r: false, t: testTooltips },\n\t\t\t'cssPrefix': { r: false, t: testCssPrefix },\n\t\t\t'cssClasses': { r: false, t: testCssClasses },\n\t\t\t'useRequestAnimationFrame': { r: false, t: testUseRaf }\n\t\t};\n\n\t\tvar defaults = {\n\t\t\t'connect': false,\n\t\t\t'direction': 'ltr',\n\t\t\t'behaviour': 'tap',\n\t\t\t'multitouch': false,\n\t\t\t'orientation': 'horizontal',\n\t\t\t'cssPrefix' : 'noUi-',\n\t\t\t'cssClasses': {\n\t\t\t\ttarget: 'target',\n\t\t\t\tbase: 'base',\n\t\t\t\torigin: 'origin',\n\t\t\t\thandle: 'handle',\n\t\t\t\thandleLower: 'handle-lower',\n\t\t\t\thandleUpper: 'handle-upper',\n\t\t\t\thorizontal: 'horizontal',\n\t\t\t\tvertical: 'vertical',\n\t\t\t\tbackground: 'background',\n\t\t\t\tconnect: 'connect',\n\t\t\t\tltr: 'ltr',\n\t\t\t\trtl: 'rtl',\n\t\t\t\tdraggable: 'draggable',\n\t\t\t\tdrag: 'state-drag',\n\t\t\t\ttap: 'state-tap',\n\t\t\t\tactive: 'active',\n\t\t\t\ttooltip: 'tooltip',\n\t\t\t\tpips: 'pips',\n\t\t\t\tpipsHorizontal: 'pips-horizontal',\n\t\t\t\tpipsVertical: 'pips-vertical',\n\t\t\t\tmarker: 'marker',\n\t\t\t\tmarkerHorizontal: 'marker-horizontal',\n\t\t\t\tmarkerVertical: 'marker-vertical',\n\t\t\t\tmarkerNormal: 'marker-normal',\n\t\t\t\tmarkerLarge: 'marker-large',\n\t\t\t\tmarkerSub: 'marker-sub',\n\t\t\t\tvalue: 'value',\n\t\t\t\tvalueHorizontal: 'value-horizontal',\n\t\t\t\tvalueVertical: 'value-vertical',\n\t\t\t\tvalueNormal: 'value-normal',\n\t\t\t\tvalueLarge: 'value-large',\n\t\t\t\tvalueSub: 'value-sub'\n\t\t\t},\n\t\t\t'useRequestAnimationFrame': true\n\t\t};\n\n\t\t// AriaFormat defaults to regular format, if any.\n\t\tif ( options.format && !options.ariaFormat ) {\n\t\t\toptions.ariaFormat = options.format;\n\t\t}\n\n\t\t// Run all options through a testing mechanism to ensure correct\n\t\t// input. It should be noted that options might get modified to\n\t\t// be handled properly. E.g. wrapping integers in arrays.\n\t\tObject.keys(tests).forEach(function( name ){\n\n\t\t\t// If the option isn't set, but it is required, throw an error.\n\t\t\tif ( options[name] === undefined && defaults[name] === undefined ) {\n\n\t\t\t\tif ( tests[name].r ) {\n\t\t\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): '\" + name + \"' is required.\");\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\ttests[name].t( parsed, options[name] === undefined ? defaults[name] : options[name] );\n\t\t});\n\n\t\t// Forward pips options\n\t\tparsed.pips = options.pips;\n\n\t\tvar styles = [['left', 'top'], ['right', 'bottom']];\n\n\t\t// Pre-define the styles.\n\t\tparsed.style = styles[parsed.dir][parsed.ort];\n\t\tparsed.styleOposite = styles[parsed.dir?0:1][parsed.ort];\n\n\t\treturn parsed;\n\t}\n\n\nfunction closure ( target, options, originalOptions ){\n\n\tvar actions = getActions();\n\tvar supportsTouchActionNone = getSupportsTouchActionNone();\n\tvar supportsPassive = supportsTouchActionNone && getSupportsPassive();\n\n\t// All variables local to 'closure' are prefixed with 'scope_'\n\tvar scope_Target = target;\n\tvar scope_Locations = [];\n\tvar scope_Base;\n\tvar scope_Handles;\n\tvar scope_HandleNumbers = [];\n\tvar scope_ActiveHandlesCount = 0;\n\tvar scope_Connects;\n\tvar scope_Spectrum = options.spectrum;\n\tvar scope_Values = [];\n\tvar scope_Events = {};\n\tvar scope_Self;\n\tvar scope_Pips;\n\tvar scope_Document = target.ownerDocument;\n\tvar scope_DocumentElement = scope_Document.documentElement;\n\tvar scope_Body = scope_Document.body;\n\n\n\t// Creates a node, adds it to target, returns the new node.\n\tfunction addNodeTo ( target, className ) {\n\n\t\tvar div = scope_Document.createElement('div');\n\n\t\tif ( className ) {\n\t\t\taddClass(div, className);\n\t\t}\n\n\t\ttarget.appendChild(div);\n\n\t\treturn div;\n\t}\n\n\t// Append a origin to the base\n\tfunction addOrigin ( base, handleNumber ) {\n\n\t\tvar origin = addNodeTo(base, options.cssClasses.origin);\n\t\tvar handle = addNodeTo(origin, options.cssClasses.handle);\n\n\t\thandle.setAttribute('data-handle', handleNumber);\n\n\t\t// https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex\n\t\t// 0 = focusable and reachable\n\t\thandle.setAttribute('tabindex', '0');\n\t\thandle.setAttribute('role', 'slider');\n\t\thandle.setAttribute('aria-orientation', options.ort ? 'vertical' : 'horizontal');\n\n\t\tif ( handleNumber === 0 ) {\n\t\t\taddClass(handle, options.cssClasses.handleLower);\n\t\t}\n\n\t\telse if ( handleNumber === options.handles - 1 ) {\n\t\t\taddClass(handle, options.cssClasses.handleUpper);\n\t\t}\n\n\t\treturn origin;\n\t}\n\n\t// Insert nodes for connect elements\n\tfunction addConnect ( base, add ) {\n\n\t\tif ( !add ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn addNodeTo(base, options.cssClasses.connect);\n\t}\n\n\t// Add handles to the slider base.\n\tfunction addElements ( connectOptions, base ) {\n\n\t\tscope_Handles = [];\n\t\tscope_Connects = [];\n\n\t\tscope_Connects.push(addConnect(base, connectOptions[0]));\n\n\t\t// [::::O====O====O====]\n\t\t// connectOptions = [0, 1, 1, 1]\n\n\t\tfor ( var i = 0; i < options.handles; i++ ) {\n\t\t\t// Keep a list of all added handles.\n\t\t\tscope_Handles.push(addOrigin(base, i));\n\t\t\tscope_HandleNumbers[i] = i;\n\t\t\tscope_Connects.push(addConnect(base, connectOptions[i + 1]));\n\t\t}\n\t}\n\n\t// Initialize a single slider.\n\tfunction addSlider ( target ) {\n\n\t\t// Apply classes and data to the target.\n\t\taddClass(target, options.cssClasses.target);\n\n\t\tif ( options.dir === 0 ) {\n\t\t\taddClass(target, options.cssClasses.ltr);\n\t\t} else {\n\t\t\taddClass(target, options.cssClasses.rtl);\n\t\t}\n\n\t\tif ( options.ort === 0 ) {\n\t\t\taddClass(target, options.cssClasses.horizontal);\n\t\t} else {\n\t\t\taddClass(target, options.cssClasses.vertical);\n\t\t}\n\n\t\tscope_Base = addNodeTo(target, options.cssClasses.base);\n\t}\n\n\n\tfunction addTooltip ( handle, handleNumber ) {\n\n\t\tif ( !options.tooltips[handleNumber] ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn addNodeTo(handle.firstChild, options.cssClasses.tooltip);\n\t}\n\n\t// The tooltips option is a shorthand for using the 'update' event.\n\tfunction tooltips ( ) {\n\n\t\t// Tooltips are added with options.tooltips in original order.\n\t\tvar tips = scope_Handles.map(addTooltip);\n\n\t\tbindEvent('update', function(values, handleNumber, unencoded) {\n\n\t\t\tif ( !tips[handleNumber] ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar formattedValue = values[handleNumber];\n\n\t\t\tif ( options.tooltips[handleNumber] !== true ) {\n\t\t\t\tformattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);\n\t\t\t}\n\n\t\t\ttips[handleNumber].innerHTML = formattedValue;\n\t\t});\n\t}\n\n\n\tfunction aria ( ) {\n\n\t\tbindEvent('update', function ( values, handleNumber, unencoded, tap, positions ) {\n\n\t\t\t// Update Aria Values for all handles, as a change in one changes min and max values for the next.\n\t\t\tscope_HandleNumbers.forEach(function( handleNumber ){\n\n\t\t\t\tvar handle = scope_Handles[handleNumber];\n\n\t\t\t\tvar min = checkHandlePosition(scope_Locations, handleNumber, 0, true, true, true);\n\t\t\t\tvar max = checkHandlePosition(scope_Locations, handleNumber, 100, true, true, true);\n\n\t\t\t\tvar now = positions[handleNumber];\n\t\t\t\tvar text = options.ariaFormat.to(unencoded[handleNumber]);\n\n\t\t\t\thandle.children[0].setAttribute('aria-valuemin', min.toFixed(1));\n\t\t\t\thandle.children[0].setAttribute('aria-valuemax', max.toFixed(1));\n\t\t\t\thandle.children[0].setAttribute('aria-valuenow', now.toFixed(1));\n\t\t\t\thandle.children[0].setAttribute('aria-valuetext', text);\n\t\t\t});\n\t\t});\n\t}\n\n\n\tfunction getGroup ( mode, values, stepped ) {\n\n\t\t// Use the range.\n\t\tif ( mode === 'range' || mode === 'steps' ) {\n\t\t\treturn scope_Spectrum.xVal;\n\t\t}\n\n\t\tif ( mode === 'count' ) {\n\n\t\t\tif ( !values ) {\n\t\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): 'values' required for mode 'count'.\");\n\t\t\t}\n\n\t\t\t// Divide 0 - 100 in 'count' parts.\n\t\t\tvar spread = ( 100 / (values - 1) );\n\t\t\tvar v;\n\t\t\tvar i = 0;\n\n\t\t\tvalues = [];\n\n\t\t\t// List these parts and have them handled as 'positions'.\n\t\t\twhile ( (v = i++ * spread) <= 100 ) {\n\t\t\t\tvalues.push(v);\n\t\t\t}\n\n\t\t\tmode = 'positions';\n\t\t}\n\n\t\tif ( mode === 'positions' ) {\n\n\t\t\t// Map all percentages to on-range values.\n\t\t\treturn values.map(function( value ){\n\t\t\t\treturn scope_Spectrum.fromStepping( stepped ? scope_Spectrum.getStep( value ) : value );\n\t\t\t});\n\t\t}\n\n\t\tif ( mode === 'values' ) {\n\n\t\t\t// If the value must be stepped, it needs to be converted to a percentage first.\n\t\t\tif ( stepped ) {\n\n\t\t\t\treturn values.map(function( value ){\n\n\t\t\t\t\t// Convert to percentage, apply step, return to value.\n\t\t\t\t\treturn scope_Spectrum.fromStepping( scope_Spectrum.getStep( scope_Spectrum.toStepping( value ) ) );\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t\t// Otherwise, we can simply use the values.\n\t\t\treturn values;\n\t\t}\n\t}\n\n\tfunction generateSpread ( density, mode, group ) {\n\n\t\tfunction safeIncrement(value, increment) {\n\t\t\t// Avoid floating point variance by dropping the smallest decimal places.\n\t\t\treturn (value + increment).toFixed(7) / 1;\n\t\t}\n\n\t\tvar indexes = {};\n\t\tvar firstInRange = scope_Spectrum.xVal[0];\n\t\tvar lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length-1];\n\t\tvar ignoreFirst = false;\n\t\tvar ignoreLast = false;\n\t\tvar prevPct = 0;\n\n\t\t// Create a copy of the group, sort it and filter away all duplicates.\n\t\tgroup = unique(group.slice().sort(function(a, b){ return a - b; }));\n\n\t\t// Make sure the range starts with the first element.\n\t\tif ( group[0] !== firstInRange ) {\n\t\t\tgroup.unshift(firstInRange);\n\t\t\tignoreFirst = true;\n\t\t}\n\n\t\t// Likewise for the last one.\n\t\tif ( group[group.length - 1] !== lastInRange ) {\n\t\t\tgroup.push(lastInRange);\n\t\t\tignoreLast = true;\n\t\t}\n\n\t\tgroup.forEach(function ( current, index ) {\n\n\t\t\t// Get the current step and the lower + upper positions.\n\t\t\tvar step;\n\t\t\tvar i;\n\t\t\tvar q;\n\t\t\tvar low = current;\n\t\t\tvar high = group[index+1];\n\t\t\tvar newPct;\n\t\t\tvar pctDifference;\n\t\t\tvar pctPos;\n\t\t\tvar type;\n\t\t\tvar steps;\n\t\t\tvar realSteps;\n\t\t\tvar stepsize;\n\n\t\t\t// When using 'steps' mode, use the provided steps.\n\t\t\t// Otherwise, we'll step on to the next subrange.\n\t\t\tif ( mode === 'steps' ) {\n\t\t\t\tstep = scope_Spectrum.xNumSteps[ index ];\n\t\t\t}\n\n\t\t\t// Default to a 'full' step.\n\t\t\tif ( !step ) {\n\t\t\t\tstep = high-low;\n\t\t\t}\n\n\t\t\t// Low can be 0, so test for false. If high is undefined,\n\t\t\t// we are at the last subrange. Index 0 is already handled.\n\t\t\tif ( low === false || high === undefined ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Make sure step isn't 0, which would cause an infinite loop (#654)\n\t\t\tstep = Math.max(step, 0.0000001);\n\n\t\t\t// Find all steps in the subrange.\n\t\t\tfor ( i = low; i <= high; i = safeIncrement(i, step) ) {\n\n\t\t\t\t// Get the percentage value for the current step,\n\t\t\t\t// calculate the size for the subrange.\n\t\t\t\tnewPct = scope_Spectrum.toStepping( i );\n\t\t\t\tpctDifference = newPct - prevPct;\n\n\t\t\t\tsteps = pctDifference / density;\n\t\t\t\trealSteps = Math.round(steps);\n\n\t\t\t\t// This ratio represents the ammount of percentage-space a point indicates.\n\t\t\t\t// For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-devided.\n\t\t\t\t// Round the percentage offset to an even number, then divide by two\n\t\t\t\t// to spread the offset on both sides of the range.\n\t\t\t\tstepsize = pctDifference/realSteps;\n\n\t\t\t\t// Divide all points evenly, adding the correct number to this subrange.\n\t\t\t\t// Run up to <= so that 100% gets a point, event if ignoreLast is set.\n\t\t\t\tfor ( q = 1; q <= realSteps; q += 1 ) {\n\n\t\t\t\t\t// The ratio between the rounded value and the actual size might be ~1% off.\n\t\t\t\t\t// Correct the percentage offset by the number of points\n\t\t\t\t\t// per subrange. density = 1 will result in 100 points on the\n\t\t\t\t\t// full range, 2 for 50, 4 for 25, etc.\n\t\t\t\t\tpctPos = prevPct + ( q * stepsize );\n\t\t\t\t\tindexes[pctPos.toFixed(5)] = ['x', 0];\n\t\t\t\t}\n\n\t\t\t\t// Determine the point type.\n\t\t\t\ttype = (group.indexOf(i) > -1) ? 1 : ( mode === 'steps' ? 2 : 0 );\n\n\t\t\t\t// Enforce the 'ignoreFirst' option by overwriting the type for 0.\n\t\t\t\tif ( !index && ignoreFirst ) {\n\t\t\t\t\ttype = 0;\n\t\t\t\t}\n\n\t\t\t\tif ( !(i === high && ignoreLast)) {\n\t\t\t\t\t// Mark the 'type' of this point. 0 = plain, 1 = real value, 2 = step value.\n\t\t\t\t\tindexes[newPct.toFixed(5)] = [i, type];\n\t\t\t\t}\n\n\t\t\t\t// Update the percentage count.\n\t\t\t\tprevPct = newPct;\n\t\t\t}\n\t\t});\n\n\t\treturn indexes;\n\t}\n\n\tfunction addMarking ( spread, filterFunc, formatter ) {\n\n\t\tvar element = scope_Document.createElement('div');\n\n\t\tvar valueSizeClasses = [\n\t\t\toptions.cssClasses.valueNormal,\n\t\t\toptions.cssClasses.valueLarge,\n\t\t\toptions.cssClasses.valueSub\n\t\t];\n\t\tvar markerSizeClasses = [\n\t\t\toptions.cssClasses.markerNormal,\n\t\t\toptions.cssClasses.markerLarge,\n\t\t\toptions.cssClasses.markerSub\n\t\t];\n\t\tvar valueOrientationClasses = [\n\t\t\toptions.cssClasses.valueHorizontal,\n\t\t\toptions.cssClasses.valueVertical\n\t\t];\n\t\tvar markerOrientationClasses = [\n\t\t\toptions.cssClasses.markerHorizontal,\n\t\t\toptions.cssClasses.markerVertical\n\t\t];\n\n\t\taddClass(element, options.cssClasses.pips);\n\t\taddClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);\n\n\t\tfunction getClasses( type, source ){\n\t\t\tvar a = source === options.cssClasses.value;\n\t\t\tvar orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;\n\t\t\tvar sizeClasses = a ? valueSizeClasses : markerSizeClasses;\n\n\t\t\treturn source + ' ' + orientationClasses[options.ort] + ' ' + sizeClasses[type];\n\t\t}\n\n\t\tfunction addSpread ( offset, values ){\n\n\t\t\t// Apply the filter function, if it is set.\n\t\t\tvalues[1] = (values[1] && filterFunc) ? filterFunc(values[0], values[1]) : values[1];\n\n\t\t\t// Add a marker for every point\n\t\t\tvar node = addNodeTo(element, false);\n\t\t\t\tnode.className = getClasses(values[1], options.cssClasses.marker);\n\t\t\t\tnode.style[options.style] = offset + '%';\n\n\t\t\t// Values are only appended for points marked '1' or '2'.\n\t\t\tif ( values[1] ) {\n\t\t\t\tnode = addNodeTo(element, false);\n\t\t\t\tnode.className = getClasses(values[1], options.cssClasses.value);\n\t\t\t\tnode.style[options.style] = offset + '%';\n\t\t\t\tnode.innerText = formatter.to(values[0]);\n\t\t\t}\n\t\t}\n\n\t\t// Append all points.\n\t\tObject.keys(spread).forEach(function(a){\n\t\t\taddSpread(a, spread[a]);\n\t\t});\n\n\t\treturn element;\n\t}\n\n\tfunction removePips ( ) {\n\t\tif ( scope_Pips ) {\n\t\t\tremoveElement(scope_Pips);\n\t\t\tscope_Pips = null;\n\t\t}\n\t}\n\n\tfunction pips ( grid ) {\n\n\t\t// Fix #669\n\t\tremovePips();\n\n\t\tvar mode = grid.mode;\n\t\tvar density = grid.density || 1;\n\t\tvar filter = grid.filter || false;\n\t\tvar values = grid.values || false;\n\t\tvar stepped = grid.stepped || false;\n\t\tvar group = getGroup( mode, values, stepped );\n\t\tvar spread = generateSpread( density, mode, group );\n\t\tvar format = grid.format || {\n\t\t\tto: Math.round\n\t\t};\n\n\t\tscope_Pips = scope_Target.appendChild(addMarking(\n\t\t\tspread,\n\t\t\tfilter,\n\t\t\tformat\n\t\t));\n\n\t\treturn scope_Pips;\n\t}\n\n\n\t// Shorthand for base dimensions.\n\tfunction baseSize ( ) {\n\t\tvar rect = scope_Base.getBoundingClientRect(), alt = 'offset' + ['Width', 'Height'][options.ort];\n\t\treturn options.ort === 0 ? (rect.width||scope_Base[alt]) : (rect.height||scope_Base[alt]);\n\t}\n\n\t// Handler for attaching events trough a proxy.\n\tfunction attachEvent ( events, element, callback, data ) {\n\n\t\t// This function can be used to 'filter' events to the slider.\n\t\t// element is a node, not a nodeList\n\n\t\tvar method = function ( e ){\n\n\t\t\tif ( scope_Target.hasAttribute('disabled') ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Stop if an active 'tap' transition is taking place.\n\t\t\tif ( hasClass(scope_Target, options.cssClasses.tap) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\te = fixEvent(e, data.pageOffset, data.target || element);\n\n\t\t\t// Handle reject of multitouch\n\t\t\tif ( !e ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Ignore right or middle clicks on start #454\n\t\t\tif ( events === actions.start && e.buttons !== undefined && e.buttons > 1 ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Ignore right or middle clicks on start #454\n\t\t\tif ( data.hover && e.buttons ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// 'supportsPassive' is only true if a browser also supports touch-action: none in CSS.\n\t\t\t// iOS safari does not, so it doesn't get to benefit from passive scrolling. iOS does support\n\t\t\t// touch-action: manipulation, but that allows panning, which breaks\n\t\t\t// sliders after zooming/on non-responsive pages.\n\t\t\t// See: https://bugs.webkit.org/show_bug.cgi?id=133112\n\t\t\tif ( !supportsPassive ) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\n\t\t\te.calcPoint = e.points[ options.ort ];\n\n\t\t\t// Call the event handler with the event [ and additional data ].\n\t\t\tcallback ( e, data );\n\t\t};\n\n\t\tvar methods = [];\n\n\t\t// Bind a closure on the target for every event type.\n\t\tevents.split(' ').forEach(function( eventName ){\n\t\t\telement.addEventListener(eventName, method, supportsPassive ? { passive: true } : false);\n\t\t\tmethods.push([eventName, method]);\n\t\t});\n\n\t\treturn methods;\n\t}\n\n\t// Provide a clean event with standardized offset values.\n\tfunction fixEvent ( e, pageOffset, target ) {\n\n\t\t// Filter the event to register the type, which can be\n\t\t// touch, mouse or pointer. Offset changes need to be\n\t\t// made on an event specific basis.\n\t\tvar touch = e.type.indexOf('touch') === 0;\n\t\tvar mouse = e.type.indexOf('mouse') === 0;\n\t\tvar pointer = e.type.indexOf('pointer') === 0;\n\n\t\tvar x;\n\t\tvar y;\n\n\t\t// IE10 implemented pointer events with a prefix;\n\t\tif ( e.type.indexOf('MSPointer') === 0 ) {\n\t\t\tpointer = true;\n\t\t}\n\n\n\t\t// In the event that multitouch is activated, the only thing one handle should be concerned\n\t\t// about is the touches that originated on top of it.\n\t\tif ( touch && options.multitouch ) {\n\t\t\t// Returns true if a touch originated on the target.\n\t\t\tvar isTouchOnTarget = function (touch) {\n\t\t\t\treturn touch.target === target || target.contains(touch.target);\n\t\t\t};\n\t\t\t// In the case of touchstart events, we need to make sure there is still no more than one\n\t\t\t// touch on the target so we look amongst all touches.\n\t\t\tif (e.type === 'touchstart') {\n\t\t\t\tvar targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget);\n\t\t\t\t// Do not support more than one touch per handle.\n\t\t\t\tif ( targetTouches.length > 1 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tx = targetTouches[0].pageX;\n\t\t\t\ty = targetTouches[0].pageY;\n\t\t\t} else {\n\t\t\t// In the other cases, find on changedTouches is enough.\n\t\t\t\tvar targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget);\n\t\t\t\t// Cancel if the target touch has not moved.\n\t\t\t\tif ( !targetTouch ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tx = targetTouch.pageX;\n\t\t\t\ty = targetTouch.pageY;\n\t\t\t}\n\t\t} else if ( touch ) {\n\t\t\t// Fix bug when user touches with two or more fingers on mobile devices.\n\t\t\t// It's useful when you have two or more sliders on one page,\n\t\t\t// that can be touched simultaneously.\n\t\t\t// #649, #663, #668\n\t\t\tif ( e.touches.length > 1 ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// noUiSlider supports one movement at a time,\n\t\t\t// so we can select the first 'changedTouch'.\n\t\t\tx = e.changedTouches[0].pageX;\n\t\t\ty = e.changedTouches[0].pageY;\n\t\t}\n\n\t\tpageOffset = pageOffset || getPageOffset(scope_Document);\n\n\t\tif ( mouse || pointer ) {\n\t\t\tx = e.clientX + pageOffset.x;\n\t\t\ty = e.clientY + pageOffset.y;\n\t\t}\n\n\t\te.pageOffset = pageOffset;\n\t\te.points = [x, y];\n\t\te.cursor = mouse || pointer; // Fix #435\n\n\t\treturn e;\n\t}\n\n\t// Translate a coordinate in the document to a percentage on the slider\n\tfunction calcPointToPercentage ( calcPoint ) {\n\t\tvar location = calcPoint - offset(scope_Base, options.ort);\n\t\tvar proposal = ( location * 100 ) / baseSize();\n\t\treturn options.dir ? 100 - proposal : proposal;\n\t}\n\n\t// Find handle closest to a certain percentage on the slider\n\tfunction getClosestHandle ( proposal ) {\n\n\t\tvar closest = 100;\n\t\tvar handleNumber = false;\n\n\t\tscope_Handles.forEach(function(handle, index){\n\n\t\t\t// Disabled handles are ignored\n\t\t\tif ( handle.hasAttribute('disabled') ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar pos = Math.abs(scope_Locations[index] - proposal);\n\n\t\t\tif ( pos < closest ) {\n\t\t\t\thandleNumber = index;\n\t\t\t\tclosest = pos;\n\t\t\t}\n\t\t});\n\n\t\treturn handleNumber;\n\t}\n\n\t// Moves handle(s) by a percentage\n\t// (bool, % to move, [% where handle started, ...], [index in scope_Handles, ...])\n\tfunction moveHandles ( upward, proposal, locations, handleNumbers ) {\n\n\t\tvar proposals = locations.slice();\n\n\t\tvar b = [!upward, upward];\n\t\tvar f = [upward, !upward];\n\n\t\t// Copy handleNumbers so we don't change the dataset\n\t\thandleNumbers = handleNumbers.slice();\n\n\t\t// Check to see which handle is 'leading'.\n\t\t// If that one can't move the second can't either.\n\t\tif ( upward ) {\n\t\t\thandleNumbers.reverse();\n\t\t}\n\n\t\t// Step 1: get the maximum percentage that any of the handles can move\n\t\tif ( handleNumbers.length > 1 ) {\n\n\t\t\thandleNumbers.forEach(function(handleNumber, o) {\n\n\t\t\t\tvar to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o], false);\n\n\t\t\t\t// Stop if one of the handles can't move.\n\t\t\t\tif ( to === false ) {\n\t\t\t\t\tproposal = 0;\n\t\t\t\t} else {\n\t\t\t\t\tproposal = to - proposals[handleNumber];\n\t\t\t\t\tproposals[handleNumber] = to;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// If using one handle, check backward AND forward\n\t\telse {\n\t\t\tb = f = [true];\n\t\t}\n\n\t\tvar state = false;\n\n\t\t// Step 2: Try to set the handles with the found percentage\n\t\thandleNumbers.forEach(function(handleNumber, o) {\n\t\t\tstate = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o]) || state;\n\t\t});\n\n\t\t// Step 3: If a handle moved, fire events\n\t\tif ( state ) {\n\t\t\thandleNumbers.forEach(function(handleNumber){\n\t\t\t\tfireEvent('update', handleNumber);\n\t\t\t\tfireEvent('slide', handleNumber);\n\t\t\t});\n\t\t}\n\t}\n\n\t// External event handling\n\tfunction fireEvent ( eventName, handleNumber, tap ) {\n\n\t\tObject.keys(scope_Events).forEach(function( targetEvent ) {\n\n\t\t\tvar eventType = targetEvent.split('.')[0];\n\n\t\t\tif ( eventName === eventType ) {\n\t\t\t\tscope_Events[targetEvent].forEach(function( callback ) {\n\n\t\t\t\t\tcallback.call(\n\t\t\t\t\t\t// Use the slider public API as the scope ('this')\n\t\t\t\t\t\tscope_Self,\n\t\t\t\t\t\t// Return values as array, so arg_1[arg_2] is always valid.\n\t\t\t\t\t\tscope_Values.map(options.format.to),\n\t\t\t\t\t\t// Handle index, 0 or 1\n\t\t\t\t\t\thandleNumber,\n\t\t\t\t\t\t// Unformatted slider values\n\t\t\t\t\t\tscope_Values.slice(),\n\t\t\t\t\t\t// Event is fired by tap, true or false\n\t\t\t\t\t\ttap || false,\n\t\t\t\t\t\t// Left offset of the handle, in relation to the slider\n\t\t\t\t\t\tscope_Locations.slice()\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\n\t// Fire 'end' when a mouse or pen leaves the document.\n\tfunction documentLeave ( event, data ) {\n\t\tif ( event.type === \"mouseout\" && event.target.nodeName === \"HTML\" && event.relatedTarget === null ){\n\t\t\teventEnd (event, data);\n\t\t}\n\t}\n\n\t// Handle movement on document for handle and range drag.\n\tfunction eventMove ( event, data ) {\n\n\t\t// Fix #498\n\t\t// Check value of .buttons in 'start' to work around a bug in IE10 mobile (data.buttonsProperty).\n\t\t// https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero\n\t\t// IE9 has .buttons and .which zero on mousemove.\n\t\t// Firefox breaks the spec MDN defines.\n\t\tif ( navigator.appVersion.indexOf(\"MSIE 9\") === -1 && event.buttons === 0 && data.buttonsProperty !== 0 ) {\n\t\t\treturn eventEnd(event, data);\n\t\t}\n\n\t\t// Check if we are moving up or down\n\t\tvar movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);\n\n\t\t// Convert the movement into a percentage of the slider width/height\n\t\tvar proposal = (movement * 100) / data.baseSize;\n\n\t\tmoveHandles(movement > 0, proposal, data.locations, data.handleNumbers);\n\t}\n\n\t// Unbind move events on document, call callbacks.\n\tfunction eventEnd ( event, data ) {\n\n\t\t// The handle is no longer active, so remove the class.\n\t\tif ( data.handle ) {\n\t\t\tremoveClass(data.handle, options.cssClasses.active);\n\t\t\tscope_ActiveHandlesCount -= 1;\n\t\t}\n\n\t\t// Unbind the move and end events, which are added on 'start'.\n\t\tdata.listeners.forEach(function( c ) {\n\t\t\tscope_DocumentElement.removeEventListener(c[0], c[1]);\n\t\t});\n\n\t\tif ( scope_ActiveHandlesCount === 0 ) {\n\t\t\t// Remove dragging class.\n\t\t\tremoveClass(scope_Target, options.cssClasses.drag);\n\t\t\tsetZindex();\n\n\t\t\t// Remove cursor styles and text-selection events bound to the body.\n\t\t\tif ( event.cursor ) {\n\t\t\t\tscope_Body.style.cursor = '';\n\t\t\t\tscope_Body.removeEventListener('selectstart', preventDefault);\n\t\t\t}\n\t\t}\n\n\t\tdata.handleNumbers.forEach(function(handleNumber){\n\t\t\tfireEvent('change', handleNumber);\n\t\t\tfireEvent('set', handleNumber);\n\t\t\tfireEvent('end', handleNumber);\n\t\t});\n\t}\n\n\t// Bind move events on document.\n\tfunction eventStart ( event, data ) {\n\n\t\tvar handle;\n\t\tif ( data.handleNumbers.length === 1 ) {\n\n\t\t\tvar handleOrigin = scope_Handles[data.handleNumbers[0]];\n\n\t\t\t// Ignore 'disabled' handles\n\t\t\tif ( handleOrigin.hasAttribute('disabled') ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\thandle = handleOrigin.children[0];\n\t\t\tscope_ActiveHandlesCount += 1;\n\n\t\t\t// Mark the handle as 'active' so it can be styled.\n\t\t\taddClass(handle, options.cssClasses.active);\n\t\t}\n\n\t\t// A drag should never propagate up to the 'tap' event.\n\t\tevent.stopPropagation();\n\n\t\t// Record the event listeners.\n\t\tvar listeners = [];\n\n\t\t// Attach the move and end events.\n\t\tvar moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {\n\t\t\t// The event target has changed so we need to propagate the original one so that we keep\n\t\t\t// relying on it to extract target touches.\n\t\t\ttarget: event.target,\n\t\t\thandle: handle,\n\t\t\tlisteners: listeners,\n\t\t\tstartCalcPoint: event.calcPoint,\n\t\t\tbaseSize: baseSize(),\n\t\t\tpageOffset: event.pageOffset,\n\t\t\thandleNumbers: data.handleNumbers,\n\t\t\tbuttonsProperty: event.buttons,\n\t\t\tlocations: scope_Locations.slice()\n\t\t});\n\n\t\tvar endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {\n\t\t\ttarget: event.target,\n\t\t\thandle: handle,\n\t\t\tlisteners: listeners,\n\t\t\thandleNumbers: data.handleNumbers\n\t\t});\n\n\t\tvar outEvent = attachEvent(\"mouseout\", scope_DocumentElement, documentLeave, {\n\t\t\ttarget: event.target,\n\t\t\thandle: handle,\n\t\t\tlisteners: listeners,\n\t\t\thandleNumbers: data.handleNumbers\n\t\t});\n\n\t\t// We want to make sure we pushed the listeners in the listener list rather than creating\n\t\t// a new one as it has already been passed to the event handlers.\n\t\tlisteners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));\n\n\t\t// Text selection isn't an issue on touch devices,\n\t\t// so adding cursor styles can be skipped.\n\t\tif ( event.cursor ) {\n\n\t\t\t// Prevent the 'I' cursor and extend the range-drag cursor.\n\t\t\tscope_Body.style.cursor = getComputedStyle(event.target).cursor;\n\n\t\t\t// Mark the target with a dragging state.\n\t\t\tif ( scope_Handles.length > 1 ) {\n\t\t\t\taddClass(scope_Target, options.cssClasses.drag);\n\t\t\t}\n\n\t\t\t// Prevent text selection when dragging the handles.\n\t\t\t// In noUiSlider <= 9.2.0, this was handled by calling preventDefault on mouse/touch start/move,\n\t\t\t// which is scroll blocking. The selectstart event is supported by FireFox starting from version 52,\n\t\t\t// meaning the only holdout is iOS Safari. This doesn't matter: text selection isn't triggered there.\n\t\t\t// The 'cursor' flag is false.\n\t\t\t// See: http://caniuse.com/#search=selectstart\n\t\t\tscope_Body.addEventListener('selectstart', preventDefault, false);\n\t\t}\n\n\t\tdata.handleNumbers.forEach(function(handleNumber){\n\t\t\tfireEvent('start', handleNumber);\n\t\t});\n\t}\n\n\t// Move closest handle to tapped location.\n\tfunction eventTap ( event ) {\n\n\t\t// The tap event shouldn't propagate up\n\t\tevent.stopPropagation();\n\n\t\tvar proposal = calcPointToPercentage(event.calcPoint);\n\t\tvar handleNumber = getClosestHandle(proposal);\n\n\t\t// Tackle the case that all handles are 'disabled'.\n\t\tif ( handleNumber === false ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Flag the slider as it is now in a transitional state.\n\t\t// Transition takes a configurable amount of ms (default 300). Re-enable the slider after that.\n\t\tif ( !options.events.snap ) {\n\t\t\taddClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);\n\t\t}\n\n\t\tsetHandle(handleNumber, proposal, true, true);\n\n\t\tsetZindex();\n\n\t\tfireEvent('slide', handleNumber, true);\n\t\tfireEvent('update', handleNumber, true);\n\t\tfireEvent('change', handleNumber, true);\n\t\tfireEvent('set', handleNumber, true);\n\n\t\tif ( options.events.snap ) {\n\t\t\teventStart(event, { handleNumbers: [handleNumber] });\n\t\t}\n\t}\n\n\t// Fires a 'hover' event for a hovered mouse/pen position.\n\tfunction eventHover ( event ) {\n\n\t\tvar proposal = calcPointToPercentage(event.calcPoint);\n\n\t\tvar to = scope_Spectrum.getStep(proposal);\n\t\tvar value = scope_Spectrum.fromStepping(to);\n\n\t\tObject.keys(scope_Events).forEach(function( targetEvent ) {\n\t\t\tif ( 'hover' === targetEvent.split('.')[0] ) {\n\t\t\t\tscope_Events[targetEvent].forEach(function( callback ) {\n\t\t\t\t\tcallback.call( scope_Self, value );\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t// Attach events to several slider parts.\n\tfunction bindSliderEvents ( behaviour ) {\n\n\t\t// Attach the standard drag event to the handles.\n\t\tif ( !behaviour.fixed ) {\n\n\t\t\tscope_Handles.forEach(function( handle, index ){\n\n\t\t\t\t// These events are only bound to the visual handle\n\t\t\t\t// element, not the 'real' origin element.\n\t\t\t\tattachEvent ( actions.start, handle.children[0], eventStart, {\n\t\t\t\t\thandleNumbers: [index]\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// Attach the tap event to the slider base.\n\t\tif ( behaviour.tap ) {\n\t\t\tattachEvent (actions.start, scope_Base, eventTap, {});\n\t\t}\n\n\t\t// Fire hover events\n\t\tif ( behaviour.hover ) {\n\t\t\tattachEvent (actions.move, scope_Base, eventHover, { hover: true });\n\t\t}\n\n\t\t// Make the range draggable.\n\t\tif ( behaviour.drag ){\n\n\t\t\tscope_Connects.forEach(function( connect, index ){\n\n\t\t\t\tif ( connect === false || index === 0 || index === scope_Connects.length - 1 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar handleBefore = scope_Handles[index - 1];\n\t\t\t\tvar handleAfter = scope_Handles[index];\n\t\t\t\tvar eventHolders = [connect];\n\n\t\t\t\taddClass(connect, options.cssClasses.draggable);\n\n\t\t\t\t// When the range is fixed, the entire range can\n\t\t\t\t// be dragged by the handles. The handle in the first\n\t\t\t\t// origin will propagate the start event upward,\n\t\t\t\t// but it needs to be bound manually on the other.\n\t\t\t\tif ( behaviour.fixed ) {\n\t\t\t\t\teventHolders.push(handleBefore.children[0]);\n\t\t\t\t\teventHolders.push(handleAfter.children[0]);\n\t\t\t\t}\n\n\t\t\t\teventHolders.forEach(function( eventHolder ) {\n\t\t\t\t\tattachEvent ( actions.start, eventHolder, eventStart, {\n\t\t\t\t\t\thandles: [handleBefore, handleAfter],\n\t\t\t\t\t\thandleNumbers: [index - 1, index]\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\n\t// Split out the handle positioning logic so the Move event can use it, too\n\tfunction checkHandlePosition ( reference, handleNumber, to, lookBackward, lookForward, getValue ) {\n\n\t\t// For sliders with multiple handles, limit movement to the other handle.\n\t\t// Apply the margin option by adding it to the handle positions.\n\t\tif ( scope_Handles.length > 1 ) {\n\n\t\t\tif ( lookBackward && handleNumber > 0 ) {\n\t\t\t\tto = Math.max(to, reference[handleNumber - 1] + options.margin);\n\t\t\t}\n\n\t\t\tif ( lookForward && handleNumber < scope_Handles.length - 1 ) {\n\t\t\t\tto = Math.min(to, reference[handleNumber + 1] - options.margin);\n\t\t\t}\n\t\t}\n\n\t\t// The limit option has the opposite effect, limiting handles to a\n\t\t// maximum distance from another. Limit must be > 0, as otherwise\n\t\t// handles would be unmoveable.\n\t\tif ( scope_Handles.length > 1 && options.limit ) {\n\n\t\t\tif ( lookBackward && handleNumber > 0 ) {\n\t\t\t\tto = Math.min(to, reference[handleNumber - 1] + options.limit);\n\t\t\t}\n\n\t\t\tif ( lookForward && handleNumber < scope_Handles.length - 1 ) {\n\t\t\t\tto = Math.max(to, reference[handleNumber + 1] - options.limit);\n\t\t\t}\n\t\t}\n\n\t\t// The padding option keeps the handles a certain distance from the\n\t\t// edges of the slider. Padding must be > 0.\n\t\tif ( options.padding ) {\n\n\t\t\tif ( handleNumber === 0 ) {\n\t\t\t\tto = Math.max(to, options.padding);\n\t\t\t}\n\n\t\t\tif ( handleNumber === scope_Handles.length - 1 ) {\n\t\t\t\tto = Math.min(to, 100 - options.padding);\n\t\t\t}\n\t\t}\n\n\t\tto = scope_Spectrum.getStep(to);\n\n\t\t// Limit percentage to the 0 - 100 range\n\t\tto = limit(to);\n\n\t\t// Return false if handle can't move\n\t\tif ( to === reference[handleNumber] && !getValue ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn to;\n\t}\n\n\tfunction toPct ( pct ) {\n\t\treturn pct + '%';\n\t}\n\n\t// Updates scope_Locations and scope_Values, updates visual state\n\tfunction updateHandlePosition ( handleNumber, to ) {\n\n\t\t// Update locations.\n\t\tscope_Locations[handleNumber] = to;\n\n\t\t// Convert the value to the slider stepping/range.\n\t\tscope_Values[handleNumber] = scope_Spectrum.fromStepping(to);\n\n\t\t// Called synchronously or on the next animationFrame\n\t\tvar stateUpdate = function() {\n\t\t\tscope_Handles[handleNumber].style[options.style] = toPct(to);\n\t\t\tupdateConnect(handleNumber);\n\t\t\tupdateConnect(handleNumber + 1);\n\t\t};\n\n\t\t// Set the handle to the new position.\n\t\t// Use requestAnimationFrame for efficient painting.\n\t\t// No significant effect in Chrome, Edge sees dramatic performace improvements.\n\t\t// Option to disable is useful for unit tests, and single-step debugging.\n\t\tif ( window.requestAnimationFrame && options.useRequestAnimationFrame ) {\n\t\t\twindow.requestAnimationFrame(stateUpdate);\n\t\t} else {\n\t\t\tstateUpdate();\n\t\t}\n\t}\n\n\tfunction setZindex ( ) {\n\n\t\tscope_HandleNumbers.forEach(function(handleNumber){\n\t\t\t// Handles before the slider middle are stacked later = higher,\n\t\t\t// Handles after the middle later is lower\n\t\t\t// [[7] [8] .......... | .......... [5] [4]\n\t\t\tvar dir = (scope_Locations[handleNumber] > 50 ? -1 : 1);\n\t\t\tvar zIndex = 3 + (scope_Handles.length + (dir * handleNumber));\n\t\t\tscope_Handles[handleNumber].childNodes[0].style.zIndex = zIndex;\n\t\t});\n\t}\n\n\t// Test suggested values and apply margin, step.\n\tfunction setHandle ( handleNumber, to, lookBackward, lookForward ) {\n\n\t\tto = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false);\n\n\t\tif ( to === false ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tupdateHandlePosition(handleNumber, to);\n\n\t\treturn true;\n\t}\n\n\t// Updates style attribute for connect nodes\n\tfunction updateConnect ( index ) {\n\n\t\t// Skip connects set to false\n\t\tif ( !scope_Connects[index] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar l = 0;\n\t\tvar h = 100;\n\n\t\tif ( index !== 0 ) {\n\t\t\tl = scope_Locations[index - 1];\n\t\t}\n\n\t\tif ( index !== scope_Connects.length - 1 ) {\n\t\t\th = scope_Locations[index];\n\t\t}\n\n\t\tscope_Connects[index].style[options.style] = toPct(l);\n\t\tscope_Connects[index].style[options.styleOposite] = toPct(100 - h);\n\t}\n\n\t// ...\n\tfunction setValue ( to, handleNumber ) {\n\n\t\t// Setting with null indicates an 'ignore'.\n\t\t// Inputting 'false' is invalid.\n\t\tif ( to === null || to === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If a formatted number was passed, attemt to decode it.\n\t\tif ( typeof to === 'number' ) {\n\t\t\tto = String(to);\n\t\t}\n\n\t\tto = options.format.from(to);\n\n\t\t// Request an update for all links if the value was invalid.\n\t\t// Do so too if setting the handle fails.\n\t\tif ( to !== false && !isNaN(to) ) {\n\t\t\tsetHandle(handleNumber, scope_Spectrum.toStepping(to), false, false);\n\t\t}\n\t}\n\n\t// Set the slider value.\n\tfunction valueSet ( input, fireSetEvent ) {\n\n\t\tvar values = asArray(input);\n\t\tvar isInit = scope_Locations[0] === undefined;\n\n\t\t// Event fires by default\n\t\tfireSetEvent = (fireSetEvent === undefined ? true : !!fireSetEvent);\n\n\t\tvalues.forEach(setValue);\n\n\t\t// Animation is optional.\n\t\t// Make sure the initial values were set before using animated placement.\n\t\tif ( options.animate && !isInit ) {\n\t\t\taddClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);\n\t\t}\n\n\t\t// Now that all base values are set, apply constraints\n\t\tscope_HandleNumbers.forEach(function(handleNumber){\n\t\t\tsetHandle(handleNumber, scope_Locations[handleNumber], true, false);\n\t\t});\n\n\t\tsetZindex();\n\n\t\tscope_HandleNumbers.forEach(function(handleNumber){\n\n\t\t\tfireEvent('update', handleNumber);\n\n\t\t\t// Fire the event only for handles that received a new value, as per #579\n\t\t\tif ( values[handleNumber] !== null && fireSetEvent ) {\n\t\t\t\tfireEvent('set', handleNumber);\n\t\t\t}\n\t\t});\n\t}\n\n\t// Reset slider to initial values\n\tfunction valueReset ( fireSetEvent ) {\n\t\tvalueSet(options.start, fireSetEvent);\n\t}\n\n\t// Get the slider value.\n\tfunction valueGet ( ) {\n\n\t\tvar values = scope_Values.map(options.format.to);\n\n\t\t// If only one handle is used, return a single value.\n\t\tif ( values.length === 1 ){\n\t\t\treturn values[0];\n\t\t}\n\n\t\treturn values;\n\t}\n\n\t// Removes classes from the root and empties it.\n\tfunction destroy ( ) {\n\n\t\tfor ( var key in options.cssClasses ) {\n\t\t\tif ( !options.cssClasses.hasOwnProperty(key) ) { continue; }\n\t\t\tremoveClass(scope_Target, options.cssClasses[key]);\n\t\t}\n\n\t\twhile (scope_Target.firstChild) {\n\t\t\tscope_Target.removeChild(scope_Target.firstChild);\n\t\t}\n\n\t\tdelete scope_Target.noUiSlider;\n\t}\n\n\t// Get the current step size for the slider.\n\tfunction getCurrentStep ( ) {\n\n\t\t// Check all locations, map them to their stepping point.\n\t\t// Get the step point, then find it in the input list.\n\t\treturn scope_Locations.map(function( location, index ){\n\n\t\t\tvar nearbySteps = scope_Spectrum.getNearbySteps( location );\n\t\t\tvar value = scope_Values[index];\n\t\t\tvar increment = nearbySteps.thisStep.step;\n\t\t\tvar decrement = null;\n\n\t\t\t// If the next value in this step moves into the next step,\n\t\t\t// the increment is the start of the next step - the current value\n\t\t\tif ( increment !== false ) {\n\t\t\t\tif ( value + increment > nearbySteps.stepAfter.startValue ) {\n\t\t\t\t\tincrement = nearbySteps.stepAfter.startValue - value;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// If the value is beyond the starting point\n\t\t\tif ( value > nearbySteps.thisStep.startValue ) {\n\t\t\t\tdecrement = nearbySteps.thisStep.step;\n\t\t\t}\n\n\t\t\telse if ( nearbySteps.stepBefore.step === false ) {\n\t\t\t\tdecrement = false;\n\t\t\t}\n\n\t\t\t// If a handle is at the start of a step, it always steps back into the previous step first\n\t\t\telse {\n\t\t\t\tdecrement = value - nearbySteps.stepBefore.highestStep;\n\t\t\t}\n\n\n\t\t\t// Now, if at the slider edges, there is not in/decrement\n\t\t\tif ( location === 100 ) {\n\t\t\t\tincrement = null;\n\t\t\t}\n\n\t\t\telse if ( location === 0 ) {\n\t\t\t\tdecrement = null;\n\t\t\t}\n\n\t\t\t// As per #391, the comparison for the decrement step can have some rounding issues.\n\t\t\tvar stepDecimals = scope_Spectrum.countStepDecimals();\n\n\t\t\t// Round per #391\n\t\t\tif ( increment !== null && increment !== false ) {\n\t\t\t\tincrement = Number(increment.toFixed(stepDecimals));\n\t\t\t}\n\n\t\t\tif ( decrement !== null && decrement !== false ) {\n\t\t\t\tdecrement = Number(decrement.toFixed(stepDecimals));\n\t\t\t}\n\n\t\t\treturn [decrement, increment];\n\t\t});\n\t}\n\n\t// Attach an event to this slider, possibly including a namespace\n\tfunction bindEvent ( namespacedEvent, callback ) {\n\t\tscope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];\n\t\tscope_Events[namespacedEvent].push(callback);\n\n\t\t// If the event bound is 'update,' fire it immediately for all handles.\n\t\tif ( namespacedEvent.split('.')[0] === 'update' ) {\n\t\t\tscope_Handles.forEach(function(a, index){\n\t\t\t\tfireEvent('update', index);\n\t\t\t});\n\t\t}\n\t}\n\n\t// Undo attachment of event\n\tfunction removeEvent ( namespacedEvent ) {\n\n\t\tvar event = namespacedEvent && namespacedEvent.split('.')[0];\n\t\tvar namespace = event && namespacedEvent.substring(event.length);\n\n\t\tObject.keys(scope_Events).forEach(function( bind ){\n\n\t\t\tvar tEvent = bind.split('.')[0],\n\t\t\t\ttNamespace = bind.substring(tEvent.length);\n\n\t\t\tif ( (!event || event === tEvent) && (!namespace || namespace === tNamespace) ) {\n\t\t\t\tdelete scope_Events[bind];\n\t\t\t}\n\t\t});\n\t}\n\n\t// Updateable: margin, limit, padding, step, range, animate, snap\n\tfunction updateOptions ( optionsToUpdate, fireSetEvent ) {\n\n\t\t// Spectrum is created using the range, snap, direction and step options.\n\t\t// 'snap' and 'step' can be updated.\n\t\t// If 'snap' and 'step' are not passed, they should remain unchanged.\n\t\tvar v = valueGet();\n\n\t\tvar updateAble = ['margin', 'limit', 'padding', 'range', 'animate', 'snap', 'step', 'format'];\n\n\t\t// Only change options that we're actually passed to update.\n\t\tupdateAble.forEach(function(name){\n\t\t\tif ( optionsToUpdate[name] !== undefined ) {\n\t\t\t\toriginalOptions[name] = optionsToUpdate[name];\n\t\t\t}\n\t\t});\n\n\t\tvar newOptions = testOptions(originalOptions);\n\n\t\t// Load new options into the slider state\n\t\tupdateAble.forEach(function(name){\n\t\t\tif ( optionsToUpdate[name] !== undefined ) {\n\t\t\t\toptions[name] = newOptions[name];\n\t\t\t}\n\t\t});\n\n\t\tscope_Spectrum = newOptions.spectrum;\n\n\t\t// Limit, margin and padding depend on the spectrum but are stored outside of it. (#677)\n\t\toptions.margin = newOptions.margin;\n\t\toptions.limit = newOptions.limit;\n\t\toptions.padding = newOptions.padding;\n\n\t\t// Update pips, removes existing.\n\t\tif ( options.pips ) {\n\t\t\tpips(options.pips);\n\t\t}\n\n\t\t// Invalidate the current positioning so valueSet forces an update.\n\t\tscope_Locations = [];\n\t\tvalueSet(optionsToUpdate.start || v, fireSetEvent);\n\t}\n\n\t// Throw an error if the slider was already initialized.\n\tif ( scope_Target.noUiSlider ) {\n\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): Slider was already initialized.\");\n\t}\n\n\t// Create the base element, initialise HTML and set classes.\n\t// Add handles and connect elements.\n\taddSlider(scope_Target);\n\taddElements(options.connect, scope_Base);\n\n\tscope_Self = {\n\t\tdestroy: destroy,\n\t\tsteps: getCurrentStep,\n\t\ton: bindEvent,\n\t\toff: removeEvent,\n\t\tget: valueGet,\n\t\tset: valueSet,\n\t\treset: valueReset,\n\t\t// Exposed for unit testing, don't use this in your application.\n\t\t__moveHandles: function(a, b, c) { moveHandles(a, b, scope_Locations, c); },\n\t\toptions: originalOptions, // Issue #600, #678\n\t\tupdateOptions: updateOptions,\n\t\ttarget: scope_Target, // Issue #597\n\t\tremovePips: removePips,\n\t\tpips: pips // Issue #594\n\t};\n\n\t// Attach user events.\n\tbindSliderEvents(options.events);\n\n\t// Use the public value method to set the start values.\n\tvalueSet(options.start);\n\n\tif ( options.pips ) {\n\t\tpips(options.pips);\n\t}\n\n\tif ( options.tooltips ) {\n\t\ttooltips();\n\t}\n\n\taria();\n\n\treturn scope_Self;\n\n}\n\n\n\t// Run the standard initializer\n\tfunction initialize ( target, originalOptions ) {\n\n\t\tif ( !target || !target.nodeName ) {\n\t\t\tthrow new Error(\"noUiSlider (\" + VERSION + \"): create requires a single element, got: \" + target);\n\t\t}\n\n\t\t// Test the options and create the slider environment;\n\t\tvar options = testOptions( originalOptions, target );\n\t\tvar api = closure( target, options, originalOptions );\n\n\t\ttarget.noUiSlider = api;\n\n\t\treturn api;\n\t}\n\n\t// Use an object instead of a function for future expansibility;\n\treturn {\n\t\tversion: VERSION,\n\t\tcreate: initialize\n\t};\n\n}));\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/nouislider/distribute/nouislider.js\n// module id = 3\n// module chunks = 0\n//# sourceURL=webpack:///./~/nouislider/distribute/nouislider.js?")
},function(module,exports){eval('if (window.Element && !Element.prototype.closest) {\n  Element.prototype.closest =\n  function(s) {\n      var matches = (this.document || this.ownerDocument).querySelectorAll(s),\n          i,\n          el = this;\n      do {\n          i = matches.length;\n          while (--i >= 0 && matches.item(i) !== el) {};\n      } while ((i < 0) && (el = el.parentElement));\n      return el;\n  };\n}\n\nfunction Accordion(element) {\n    this.element = element;\n\n    this.setVars();\n    this.setEventListeners();\n    this.init();\n}\n\nAccordion.prototype.setVars = function() {\n    this.css = {\n      classes: {\n        active: "active",\n        rendered: "accordion--rendered"\n      },\n      selectors: {\n        accordion: ".accordion",\n        accordionItem: ".accordion__item",\n        accordionTrigger: ".accordion__item__trigger"\n      }\n    };\n\n    this.accordionTriggers = this.element.querySelectorAll(this.css.selectors.accordionTrigger);\n    this.accordionItems = this.element.querySelectorAll(this.css.selectors.accordionItem);\n    this.openAnswers = 0;\n    this.totalAnswers = this.accordionTriggers.length;\n};\n\nAccordion.prototype.init = function() {\n    this.element.classList.add(this.css.classes.rendered);\n};\n\nAccordion.prototype.setEventListeners = function() {\n    var cxt = this;\n    Array.prototype.forEach.call(this.accordionTriggers, function(el, arr, index){\n        el.addEventListener(\'click\', cxt.toggleContent.bind(cxt));\n    });\n};\n\nAccordion.prototype.toggleContent = function(event) {\n    var accordionItem = event.target.closest(this.css.selectors.accordionItem);\n\n    event.preventDefault();\n\n    if (accordionItem.classList.contains(this.css.classes.active)) {\n        this.openAnswers -= 1;\n    } else {\n        this.openAnswers += 1;\n    }\n\n    if (this.openAnswers === this.totalAnswers) {\n        this.showAllContent();\n    } else if (!this.openAnswers) {\n        this.hideAllContent();\n    } else {\n        accordionItem.classList.toggle(this.css.classes.active);\n    }\n};\n\n\nAccordion.prototype.showAllContent = function() {\n    var cxt = this;\n    Array.prototype.forEach.call(this.accordionItems, function(el, arr, index){\n        el.classList.add(cxt.css.classes.active);\n    });\n    this.openAnswers = this.totalAnswers;\n    console.log(\'openAnswers\', this.openAnswers);\n};\n\nAccordion.prototype.hideAllContent = function() {\n    var cxt = this;\n    Array.prototype.forEach.call(this.accordionItems, function(el, arr, index){\n        el.classList.remove(cxt.css.classes.active);\n    });\n\n    this.openAnswers = 0;\n    console.log(\'openAnswers\', this.openAnswers);\n};\n\nAccordion.prototype.toggleAllContent = function() {\n    if (this.openAnswers < this.totalAnswers) {\n        this.showAllContent();\n    } else {\n        this.hideAllContent();\n    }\n};\n\nmodule.exports = Accordion;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./assets/scripts/widgets/accordion.js\n// module id = 4\n// module chunks = 0\n//# sourceURL=webpack:///./assets/scripts/widgets/accordion.js?')},function(module,exports,__webpack_require__){eval('var GoogleMapsLoader = __webpack_require__(6);\nvar Promise = __webpack_require__(7);\nGoogleMapsLoader.KEY = \'AIzaSyDor4jeGMzVTzl6x5QgpGPvahUSje9I-E0\';\nvar debounce = __webpack_require__(17);\n\nfunction InitGoogleMaps(node){\n    this.$node = node;\n    this.setVars();\n    this.init();\n}\n\nInitGoogleMaps.prototype.setVars = function(){\n    this.css = {\n        states : {\n            \'active\':\'active\',\n            \'init\' : \'initialised\',\n            \'disabled\' : \'disabled\'\n        },\n        selectors : {\n            \'propertiesPanel\' : \'.properties__panel\',\n            \'propertiesContainer\' : \'.properties__container\',\n            \'properties\' : \'propertiesHook\'\n        }\n    }\n}\n\nInitGoogleMaps.prototype.init = function(){\n\n    var cxt = this;\n    var ww = window.innerWidth;\n\n    //mobile selectors\n    this.locationMobSelect = document.getElementById(this.css.selectors.locationMobSelect);\n    this.properties = document.getElementById(this.css.selectors.properties);\n    this.propertiesContainer = this.properties.querySelector(this.css.selectors.propertiesContainer);\n    this.loadMore = this.properties.querySelector(\'a\');\n\n    this.loadMore.addEventListener(\'click\', this.loadData.bind(this));\n    window.addEventListener(\'load\', this.initMap.bind(this));\n    window.addEventListener(\'resize\', debounce(this.initMap.bind(this), 200));\n\n}\n\nInitGoogleMaps.prototype.loadData = function(e){\n    //load more button functionality\n    // NOTE: move json out into seperate method\n    var cxt = this;\n\n    e.preventDefault();\n\n    cxt.propertiesPanels = cxt.properties.querySelectorAll(cxt.css.selectors.propertiesPanel);\n    //prevent action if button is disabled\n    if(!e.currentTarget.classList.contains(cxt.css.states.disabled)) {\n        //current number of panels\n        var panels = cxt.propertiesPanels.length;\n        var panelsMax = panels+3;\n\n        cxt.get(\'json/locations.json\').then(function(locations) {\n\n            var locationsMax = locations.length; //max number of locations\n\n            if(locationsMax < panelsMax) {\n                cxt.loadMore.classList.add(cxt.css.states.disabled);\n                for (i = panels; i < panelsMax; i++) {\n                    cxt.buildMobileList(locations[i], locations[i].location, locations[i].pics[0]); //create property panels\n                }\n            } else {\n                for (i = panels; i < panelsMax; i++) {\n                    cxt.buildMobileList(locations[i], locations[i].location, locations[i].pics[0]); //create property panels\n                }\n            }\n\n        }, function(error) {\n          console.error("Failed!", error);\n        });\n    }\n\n}\n\nInitGoogleMaps.prototype.initMap = function(e) {\n\n    var cxt = this;\n    var ww = window.innerWidth;\n\n    GoogleMapsLoader.load(function(google) {\n        var map;\n          var styles = {\n              silver:\n                [\n                    {\n                        "featureType": "all",\n                        "elementType": "geometry",\n                        "stylers": [\n                            {\n                                "color": "#92d1f4"\n                            }\n                        ]\n                    },\n                    {\n                        "featureType": "all",\n                        "elementType": "labels.text.fill",\n                        "stylers": [\n                            {\n                                "gamma": 0.01\n                            },\n                            {\n                                "lightness": 20\n                            }\n                        ]\n                    },\n                    {\n                        "featureType": "all",\n                        "elementType": "labels.text.stroke",\n                        "stylers": [\n                            {\n                                "saturation": -31\n                            },\n                            {\n                                "lightness": -33\n                            },\n                            {\n                                "weight": 2\n                            },\n                            {\n                                "gamma": 0.8\n                            }\n                        ]\n                    },\n                    {\n                        "featureType": "all",\n                        "elementType": "labels.icon",\n                        "stylers": [\n                            {\n                                "visibility": "off"\n                            }\n                        ]\n                    },\n                    {\n                        "featureType": "landscape",\n                        "elementType": "geometry",\n                        "stylers": [\n                            {\n                                "lightness": 80\n                            },\n                            {\n                                "saturation": 10\n                            }\n                        ]\n                    },\n                    {\n                        "featureType": "poi",\n                        "elementType": "geometry",\n                        "stylers": [\n                            {\n                                "saturation": 20\n                            }\n                        ]\n                    },\n                    {\n                        "featureType": "poi.park",\n                        "elementType": "geometry",\n                        "stylers": [\n                            {\n                                "lightness": 70\n                            },\n                            {\n                                "saturation": -20\n                            }\n                        ]\n                    },\n                    {\n                        "featureType": "road",\n                        "elementType": "geometry",\n                        "stylers": [\n                            {\n                                "lightness": 670\n                            },\n                            {\n                                "saturation": -30\n                            }\n                        ]\n                    },\n                    {\n                        "featureType": "road",\n                        "elementType": "geometry.stroke",\n                        "stylers": [\n                            {\n                                "saturation": 25\n                            },\n                            {\n                                "lightness": 25\n                            }\n                        ]\n                    },\n                    {\n                        "featureType": "water",\n                        "elementType": "all",\n                        "stylers": [\n                            {\n                                "saturation": 35\n                            },\n                            {\n                                "lightness":20\n                            }\n                        ]\n                    }\n                ]\n            };\n\n\n          var myStyles =[\n            {\n                featureType: "poi",\n                elementType: "labels",\n                stylers: [\n                      { visibility: "off" }\n                ]\n            },\n            {\n              featureType: \'transit\',\n              elementType: \'labels.icon\',\n              stylers: [{visibility: \'off\'}]\n            }\n        ];\n\n\n        var locations = [\n          [51.521722, -0.130443],\n          [53.386278, -1.469588],\n          [55.869120, -4.251686],\n          [51.461624, -2.588994]\n        ];\n\n        var options = {\n           draggable: false,\n           scrollwheel: false,\n           panControl: false,\n           maxZoom: 6,\n           minZoom: 6,\n           zoom: 6,\n           disableDefaultUI: true,\n           clickableIcons: false,\n           center: {lat: 53.634566, lng: -3.472727},\n           mapTypeId: google.maps.MapTypeId.ROADMAP,\n           styles: myStyles\n       };\n\n\n      if(ww > 768) {\n          map = new google.maps.Map(cxt.$node, options);\n          map.setOptions({styles: styles[\'silver\']});\n\n          //Resize Function\n          google.maps.event.addDomListener(window, "resize", function() {\n              var center = map.getCenter();\n              google.maps.event.trigger(map, "resize");\n              map.setCenter(center);\n          });\n\n          var image = {\n            url: \'./dist/images/icons/pin.png\',\n            size: new google.maps.Size(37, 40),\n            origin: new google.maps.Point(0, 0),\n            anchor: new google.maps.Point(0, 32)\n          };\n\n\n          var marker, i;\n\n          for (i = 0; i < locations.length; i++) {\n              marker = new google.maps.Marker({\n                  position: new google.maps.LatLng(locations[i][0], locations[i][1]),\n                  map: map,\n                  icon: image\n              });\n           }\n\n      } else {\n\n          //check whether it already contains properties and has initialised\n          if(!cxt.propertiesContainer.classList.contains(cxt.css.states.init)) {\n              cxt.get(\'json/locations.json\').then(function(locations) {\n                  for (i = 0; i < locations.length; i++) {\n                      if(locations.length > 3 && i < 3) {\n                           cxt.buildMobileList(locations[i], locations[i].location, locations[i].pics[0]); //create property panels\n                      }\n                  }\n                 cxt.propertiesContainer.classList.add(cxt.css.states.init);\n              }, function(error) {\n                console.error("Failed!", error);\n              });\n          }\n      }\n\n    });\n\n}\n\nInitGoogleMaps.prototype.buildMobileList = function(data, title, picUrl) {\n\n    var cxt = this;\n    var parent = document.createElement(\'div\');\n    var imgCont = document.createElement(\'div\');\n    var img = document.createElement(\'img\');\n    var p = document.createElement(\'p\');\n\n    parent.classList.add(\'properties__panel\');\n    imgCont.classList.add(\'properties__panel--img-cont\');\n    parent.appendChild(imgCont);\n\n    img.setAttribute(\'src\', picUrl.url);\n    imgCont.appendChild(img);\n\n    p.innerHTML = title;\n    parent.appendChild(p);\n\n    this.propertiesContainer.appendChild(parent);\n}\n\n\nInitGoogleMaps.prototype.get = function(url) {\n\n  return new Promise(function(resolve, reject) {\n\n    var req = new XMLHttpRequest();\n    req.open(\'GET\', url);\n\n    req.onload = function() {\n\n      if (req.status == 200) {\n        resolve(JSON.parse(req.response));\n      }\n      else {\n        reject(Error(req.statusText));\n      }\n    };\n\n    // Handle network errors\n    req.onerror = function() {\n      reject(Error("Network Error"));\n    };\n\n    req.send();\n  });\n}\n\nmodule.exports = InitGoogleMaps;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./assets/scripts/widgets/maps.js\n// module id = 5\n// module chunks = 0\n//# sourceURL=webpack:///./assets/scripts/widgets/maps.js?')},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {\n\n\tif (root === null) {\n\t\tthrow new Error('Google-maps package can be used only in browser');\n\t}\n\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else if (typeof exports === 'object') {\n\t\tmodule.exports = factory();\n\t} else {\n\t\troot.GoogleMapsLoader = factory();\n\t}\n\n})(typeof window !== 'undefined' ? window : null, function() {\n\n\n\t'use strict';\n\n\n\tvar googleVersion = '3.18';\n\n\tvar script = null;\n\n\tvar google = null;\n\n\tvar loading = false;\n\n\tvar callbacks = [];\n\n\tvar onLoadEvents = [];\n\n\tvar originalCreateLoaderMethod = null;\n\n\n\tvar GoogleMapsLoader = {};\n\n\n\tGoogleMapsLoader.URL = 'https://maps.googleapis.com/maps/api/js';\n\n\tGoogleMapsLoader.KEY = null;\n\n\tGoogleMapsLoader.LIBRARIES = [];\n\n\tGoogleMapsLoader.CLIENT = null;\n\n\tGoogleMapsLoader.CHANNEL = null;\n\n\tGoogleMapsLoader.LANGUAGE = null;\n\n\tGoogleMapsLoader.REGION = null;\n\n\tGoogleMapsLoader.VERSION = googleVersion;\n\n\tGoogleMapsLoader.WINDOW_CALLBACK_NAME = '__google_maps_api_provider_initializator__';\n\n\n\tGoogleMapsLoader._googleMockApiObject = {};\n\n\n\tGoogleMapsLoader.load = function(fn) {\n\t\tif (google === null) {\n\t\t\tif (loading === true) {\n\t\t\t\tif (fn) {\n\t\t\t\t\tcallbacks.push(fn);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tloading = true;\n\n\t\t\t\twindow[GoogleMapsLoader.WINDOW_CALLBACK_NAME] = function() {\n\t\t\t\t\tready(fn);\n\t\t\t\t};\n\n\t\t\t\tGoogleMapsLoader.createLoader();\n\t\t\t}\n\t\t} else if (fn) {\n\t\t\tfn(google);\n\t\t}\n\t};\n\n\n\tGoogleMapsLoader.createLoader = function() {\n\t\tscript = document.createElement('script');\n\t\tscript.type = 'text/javascript';\n\t\tscript.src = GoogleMapsLoader.createUrl();\n\n\t\tdocument.body.appendChild(script);\n\t};\n\n\n\tGoogleMapsLoader.isLoaded = function() {\n\t\treturn google !== null;\n\t};\n\n\n\tGoogleMapsLoader.createUrl = function() {\n\t\tvar url = GoogleMapsLoader.URL;\n\n\t\turl += '?callback=' + GoogleMapsLoader.WINDOW_CALLBACK_NAME;\n\n\t\tif (GoogleMapsLoader.KEY) {\n\t\t\turl += '&key=' + GoogleMapsLoader.KEY;\n\t\t}\n\n\t\tif (GoogleMapsLoader.LIBRARIES.length > 0) {\n\t\t\turl += '&libraries=' + GoogleMapsLoader.LIBRARIES.join(',');\n\t\t}\n\n\t\tif (GoogleMapsLoader.CLIENT) {\n\t\t\turl += '&client=' + GoogleMapsLoader.CLIENT + '&v=' + GoogleMapsLoader.VERSION;\n\t\t}\n\n\t\tif (GoogleMapsLoader.CHANNEL) {\n\t\t\turl += '&channel=' + GoogleMapsLoader.CHANNEL;\n\t\t}\n\n\t\tif (GoogleMapsLoader.LANGUAGE) {\n\t\t\turl += '&language=' + GoogleMapsLoader.LANGUAGE;\n\t\t}\n\n\t\tif (GoogleMapsLoader.REGION) {\n\t\t\turl += '&region=' + GoogleMapsLoader.REGION;\n\t\t}\n\n\t\treturn url;\n\t};\n\n\n\tGoogleMapsLoader.release = function(fn) {\n\t\tvar release = function() {\n\t\t\tGoogleMapsLoader.KEY = null;\n\t\t\tGoogleMapsLoader.LIBRARIES = [];\n\t\t\tGoogleMapsLoader.CLIENT = null;\n\t\t\tGoogleMapsLoader.CHANNEL = null;\n\t\t\tGoogleMapsLoader.LANGUAGE = null;\n\t\t\tGoogleMapsLoader.REGION = null;\n\t\t\tGoogleMapsLoader.VERSION = googleVersion;\n\n\t\t\tgoogle = null;\n\t\t\tloading = false;\n\t\t\tcallbacks = [];\n\t\t\tonLoadEvents = [];\n\n\t\t\tif (typeof window.google !== 'undefined') {\n\t\t\t\tdelete window.google;\n\t\t\t}\n\n\t\t\tif (typeof window[GoogleMapsLoader.WINDOW_CALLBACK_NAME] !== 'undefined') {\n\t\t\t\tdelete window[GoogleMapsLoader.WINDOW_CALLBACK_NAME];\n\t\t\t}\n\n\t\t\tif (originalCreateLoaderMethod !== null) {\n\t\t\t\tGoogleMapsLoader.createLoader = originalCreateLoaderMethod;\n\t\t\t\toriginalCreateLoaderMethod = null;\n\t\t\t}\n\n\t\t\tif (script !== null) {\n\t\t\t\tscript.parentElement.removeChild(script);\n\t\t\t\tscript = null;\n\t\t\t}\n\n\t\t\tif (fn) {\n\t\t\t\tfn();\n\t\t\t}\n\t\t};\n\n\t\tif (loading) {\n\t\t\tGoogleMapsLoader.load(function() {\n\t\t\t\trelease();\n\t\t\t});\n\t\t} else {\n\t\t\trelease();\n\t\t}\n\t};\n\n\n\tGoogleMapsLoader.onLoad = function(fn) {\n\t\tonLoadEvents.push(fn);\n\t};\n\n\n\tGoogleMapsLoader.makeMock = function() {\n\t\toriginalCreateLoaderMethod = GoogleMapsLoader.createLoader;\n\n\t\tGoogleMapsLoader.createLoader = function() {\n\t\t\twindow.google = GoogleMapsLoader._googleMockApiObject;\n\t\t\twindow[GoogleMapsLoader.WINDOW_CALLBACK_NAME]();\n\t\t};\n\t};\n\n\n\tvar ready = function(fn) {\n\t\tvar i;\n\n\t\tloading = false;\n\n\t\tif (google === null) {\n\t\t\tgoogle = window.google;\n\t\t}\n\n\t\tfor (i = 0; i < onLoadEvents.length; i++) {\n\t\t\tonLoadEvents[i](google);\n\t\t}\n\n\t\tif (fn) {\n\t\t\tfn(google);\n\t\t}\n\n\t\tfor (i = 0; i < callbacks.length; i++) {\n\t\t\tcallbacks[i](google);\n\t\t}\n\n\t\tcallbacks = [];\n\t};\n\n\n\treturn GoogleMapsLoader;\n\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/google-maps/lib/Google.js\n// module id = 6\n// module chunks = 0\n//# sourceURL=webpack:///./~/google-maps/lib/Google.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nmodule.exports = __webpack_require__(8)\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/index.js\n// module id = 7\n// module chunks = 0\n//# sourceURL=webpack:///./~/promise/index.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nmodule.exports = __webpack_require__(9);\n__webpack_require__(11);\n__webpack_require__(12);\n__webpack_require__(13);\n__webpack_require__(14);\n__webpack_require__(16);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/index.js\n// module id = 8\n// module chunks = 0\n//# sourceURL=webpack:///./~/promise/lib/index.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar asap = __webpack_require__(10);\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('Promise constructor\\'s argument is not a function');\n  }\n  this._75 = 0;\n  this._83 = 0;\n  this._18 = null;\n  this._38 = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._47 = null;\nPromise._71 = null;\nPromise._44 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n}\nfunction handle(self, deferred) {\n  while (self._83 === 3) {\n    self = self._18;\n  }\n  if (Promise._47) {\n    Promise._47(self);\n  }\n  if (self._83 === 0) {\n    if (self._75 === 0) {\n      self._75 = 1;\n      self._38 = deferred;\n      return;\n    }\n    if (self._75 === 1) {\n      self._75 = 2;\n      self._38 = [self._38, deferred];\n      return;\n    }\n    self._38.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._83 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._83 === 1) {\n        resolve(deferred.promise, self._18);\n      } else {\n        reject(deferred.promise, self._18);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._18);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._83 = 3;\n      self._18 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._83 = 1;\n  self._18 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._83 = 2;\n  self._18 = newValue;\n  if (Promise._71) {\n    Promise._71(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._75 === 1) {\n    handle(self, self._38);\n    self._38 = null;\n  }\n  if (self._75 === 2) {\n    for (var i = 0; i < self._38.length; i++) {\n      handle(self, self._38[i]);\n    }\n    self._38 = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  });\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/core.js\n// module id = 9\n// module chunks = 0\n//# sourceURL=webpack:///./~/promise/lib/core.js?")},function(module,exports){
eval('/* WEBPACK VAR INJECTION */(function(global) {"use strict";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser\'s own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don\'t\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n/* globals self */\nvar scope = typeof global !== "undefined" ? global : self;\nvar BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === "function") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser\'s renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.jss\n// `process.on("uncaughtException")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between "1" and "-1".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode("");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page\'s first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don\'t need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we\'re flushing, there\'s no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/asap/browser-raw.js\n// module id = 10\n// module chunks = 0\n//# sourceURL=webpack:///./~/asap/browser-raw.js?')},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar Promise = __webpack_require__(9);\n\nmodule.exports = Promise;\nPromise.prototype.done = function (onFulfilled, onRejected) {\n  var self = arguments.length ? this.then.apply(this, arguments) : this;\n  self.then(null, function (err) {\n    setTimeout(function () {\n      throw err;\n    }, 0);\n  });\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/done.js\n// module id = 11\n// module chunks = 0\n//# sourceURL=webpack:///./~/promise/lib/done.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar Promise = __webpack_require__(9);\n\nmodule.exports = Promise;\nPromise.prototype['finally'] = function (f) {\n  return this.then(function (value) {\n    return Promise.resolve(f()).then(function () {\n      return value;\n    });\n  }, function (err) {\n    return Promise.resolve(f()).then(function () {\n      throw err;\n    });\n  });\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/finally.js\n// module id = 12\n// module chunks = 0\n//# sourceURL=webpack:///./~/promise/lib/finally.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = __webpack_require__(9);\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._44);\n  p._83 = 1;\n  p._18 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._83 === 3) {\n            val = val._18;\n          }\n          if (val._83 === 1) return res(i, val._18);\n          if (val._83 === 2) reject(val._18);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/es6-extensions.js\n// module id = 13\n// module chunks = 0\n//# sourceURL=webpack:///./~/promise/lib/es6-extensions.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\n// This file contains then/promise specific extensions that are only useful\n// for node.js interop\n\nvar Promise = __webpack_require__(9);\nvar asap = __webpack_require__(15);\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nPromise.denodeify = function (fn, argumentCount) {\n  if (\n    typeof argumentCount === 'number' && argumentCount !== Infinity\n  ) {\n    return denodeifyWithCount(fn, argumentCount);\n  } else {\n    return denodeifyWithoutCount(fn);\n  }\n};\n\nvar callbackFn = (\n  'function (err, res) {' +\n  'if (err) { rj(err); } else { rs(res); }' +\n  '}'\n);\nfunction denodeifyWithCount(fn, argumentCount) {\n  var args = [];\n  for (var i = 0; i < argumentCount; i++) {\n    args.push('a' + i);\n  }\n  var body = [\n    'return function (' + args.join(',') + ') {',\n    'var self = this;',\n    'return new Promise(function (rs, rj) {',\n    'var res = fn.call(',\n    ['self'].concat(args).concat([callbackFn]).join(','),\n    ');',\n    'if (res &&',\n    '(typeof res === \"object\" || typeof res === \"function\") &&',\n    'typeof res.then === \"function\"',\n    ') {rs(res);}',\n    '});',\n    '};'\n  ].join('');\n  return Function(['Promise', 'fn'], body)(Promise, fn);\n}\nfunction denodeifyWithoutCount(fn) {\n  var fnLength = Math.max(fn.length - 1, 3);\n  var args = [];\n  for (var i = 0; i < fnLength; i++) {\n    args.push('a' + i);\n  }\n  var body = [\n    'return function (' + args.join(',') + ') {',\n    'var self = this;',\n    'var args;',\n    'var argLength = arguments.length;',\n    'if (arguments.length > ' + fnLength + ') {',\n    'args = new Array(arguments.length + 1);',\n    'for (var i = 0; i < arguments.length; i++) {',\n    'args[i] = arguments[i];',\n    '}',\n    '}',\n    'return new Promise(function (rs, rj) {',\n    'var cb = ' + callbackFn + ';',\n    'var res;',\n    'switch (argLength) {',\n    args.concat(['extra']).map(function (_, index) {\n      return (\n        'case ' + (index) + ':' +\n        'res = fn.call(' + ['self'].concat(args.slice(0, index)).concat('cb').join(',') + ');' +\n        'break;'\n      );\n    }).join(''),\n    'default:',\n    'args[argLength] = cb;',\n    'res = fn.apply(self, args);',\n    '}',\n    \n    'if (res &&',\n    '(typeof res === \"object\" || typeof res === \"function\") &&',\n    'typeof res.then === \"function\"',\n    ') {rs(res);}',\n    '});',\n    '};'\n  ].join('');\n\n  return Function(\n    ['Promise', 'fn'],\n    body\n  )(Promise, fn);\n}\n\nPromise.nodeify = function (fn) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments);\n    var callback =\n      typeof args[args.length - 1] === 'function' ? args.pop() : null;\n    var ctx = this;\n    try {\n      return fn.apply(this, arguments).nodeify(callback, ctx);\n    } catch (ex) {\n      if (callback === null || typeof callback == 'undefined') {\n        return new Promise(function (resolve, reject) {\n          reject(ex);\n        });\n      } else {\n        asap(function () {\n          callback.call(ctx, ex);\n        })\n      }\n    }\n  }\n};\n\nPromise.prototype.nodeify = function (callback, ctx) {\n  if (typeof callback != 'function') return this;\n\n  this.then(function (value) {\n    asap(function () {\n      callback.call(ctx, null, value);\n    });\n  }, function (err) {\n    asap(function () {\n      callback.call(ctx, err);\n    });\n  });\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/node-extensions.js\n// module id = 14\n// module chunks = 0\n//# sourceURL=webpack:///./~/promise/lib/node-extensions.js?")},function(module,exports,__webpack_require__){eval('"use strict";\n\n// rawAsap provides everything we need except exception management.\nvar rawAsap = __webpack_require__(10);\n// RawTasks are recycled to reduce GC churn.\nvar freeTasks = [];\n// We queue errors to ensure they are thrown in right order (FIFO).\n// Array-as-queue is good enough here, since we are just dealing with exceptions.\nvar pendingErrors = [];\nvar requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);\n\nfunction throwFirstError() {\n    if (pendingErrors.length) {\n        throw pendingErrors.shift();\n    }\n}\n\n/**\n * Calls a task as soon as possible after returning, in its own event, with priority\n * over other events like animation, reflow, and repaint. An error thrown from an\n * event will not interrupt, nor even substantially slow down the processing of\n * other events, but will be rather postponed to a lower priority event.\n * @param {{call}} task A callable object, typically a function that takes no\n * arguments.\n */\nmodule.exports = asap;\nfunction asap(task) {\n    var rawTask;\n    if (freeTasks.length) {\n        rawTask = freeTasks.pop();\n    } else {\n        rawTask = new RawTask();\n    }\n    rawTask.task = task;\n    rawAsap(rawTask);\n}\n\n// We wrap tasks with recyclable task objects.  A task object implements\n// `call`, just like a function.\nfunction RawTask() {\n    this.task = null;\n}\n\n// The sole purpose of wrapping the task is to catch the exception and recycle\n// the task object after its single use.\nRawTask.prototype.call = function () {\n    try {\n        this.task.call();\n    } catch (error) {\n        if (asap.onerror) {\n            // This hook exists purely for testing purposes.\n            // Its name will be periodically randomized to break any code that\n            // depends on its existence.\n            asap.onerror(error);\n        } else {\n            // In a web browser, exceptions are not fatal. However, to avoid\n            // slowing down the queue of pending tasks, we rethrow the error in a\n            // lower priority turn.\n            pendingErrors.push(error);\n            requestErrorThrow();\n        }\n    } finally {\n        this.task = null;\n        freeTasks[freeTasks.length] = this;\n    }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/asap/browser-asap.js\n// module id = 15\n// module chunks = 0\n//# sourceURL=webpack:///./~/asap/browser-asap.js?')},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar Promise = __webpack_require__(9);\n\nmodule.exports = Promise;\nPromise.enableSynchronous = function () {\n  Promise.prototype.isPending = function() {\n    return this.getState() == 0;\n  };\n\n  Promise.prototype.isFulfilled = function() {\n    return this.getState() == 1;\n  };\n\n  Promise.prototype.isRejected = function() {\n    return this.getState() == 2;\n  };\n\n  Promise.prototype.getValue = function () {\n    if (this._83 === 3) {\n      return this._18.getValue();\n    }\n\n    if (!this.isFulfilled()) {\n      throw new Error('Cannot get a value of an unfulfilled promise.');\n    }\n\n    return this._18;\n  };\n\n  Promise.prototype.getReason = function () {\n    if (this._83 === 3) {\n      return this._18.getReason();\n    }\n\n    if (!this.isRejected()) {\n      throw new Error('Cannot get a rejection reason of a non-rejected promise.');\n    }\n\n    return this._18;\n  };\n\n  Promise.prototype.getState = function () {\n    if (this._83 === 3) {\n      return this._18.getState();\n    }\n    if (this._83 === -1 || this._83 === -2) {\n      return 0;\n    }\n\n    return this._83;\n  };\n};\n\nPromise.disableSynchronous = function() {\n  Promise.prototype.isPending = undefined;\n  Promise.prototype.isFulfilled = undefined;\n  Promise.prototype.isRejected = undefined;\n  Promise.prototype.getValue = undefined;\n  Promise.prototype.getReason = undefined;\n  Promise.prototype.getState = undefined;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/synchronous.js\n// module id = 16\n// module chunks = 0\n//# sourceURL=webpack:///./~/promise/lib/synchronous.js?")},function(module,exports){eval("/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing. The function also has a property 'clear' \n * that is a function which will clear the timer to prevent previously scheduled executions. \n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\n\nmodule.exports = function debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = Date.now() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n    }\n  };\n\n  var debounced = function(){\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n\n  debounced.clear = function() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debounced;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/debounce/index.js\n// module id = 17\n// module chunks = 0\n//# sourceURL=webpack:///./~/debounce/index.js?")},function(module,exports,__webpack_require__){
eval("var MarkerClusterer = __webpack_require__(19);\nvar GoogleMaps = __webpack_require__(6);\nvar Promise = __webpack_require__(7);\nGoogleMaps.KEY = 'AIzaSyDor4jeGMzVTzl6x5QgpGPvahUSje9I-E0';\nvar debounce = __webpack_require__(17);\n\nfunction PropertyMap(node){\n    this.$node = node;\n    this.setVars();\n    this.init();\n}\n\nPropertyMap.prototype.setVars = function(){\n    this.css = {\n        states : {\n            'active':'active',\n            'init' : 'initialised',\n            'disabled' : 'disabled'\n        },\n        selectors : {\n            'mapOverlay' : 'mapOverlayHook',\n            'mapClose'  : '.map__overlay--close',\n            'mapCarouselTrack' : '.map__overlay--carousel-track',\n            'mapCarouselThumbnails' : '.map__overlay--thumbnails',\n            'mapOverlayTitle'  :  '.map__overlay--title',\n            'mapOverlayContents' : '.map__overlay--contents',\n            'mapOverlaySpotlight'  : '.map__overlay--spotlight',\n            'mapOverlayLoading' : '.map__overlay--loading',\n            'locationMobSelect' : 'locationMobSelectHook',\n            'propertiesPanel' : '.properties__panel',\n            'propertiesContainer' : '.properties__container',\n            'properties' : 'propertiesHook'\n        }\n    }\n}\n\nPropertyMap.prototype.init = function(){\n    var cxt = this;\n\n    this.mapOverlay = document.getElementById(this.css.selectors.mapOverlay);\n    this.mapOverlayClose = this.mapOverlay.querySelector(this.css.selectors.mapClose);\n    this.mapCarouselThumbnails = this.mapOverlay.querySelector(this.css.selectors.mapCarouselThumbnails);\n    this.mapCarouselTrack = this.mapOverlay.querySelector(this.css.selectors.mapCarouselTrack);\n    this.mapOverlayTitle = this.mapOverlay.querySelector(this.css.selectors.mapOverlayTitle);\n    this.mapOverlayContents = this.mapOverlay.querySelector(this.css.selectors.mapOverlayContents);\n    this.mapOverlaySpotlight = this.mapOverlay.querySelector(this.css.selectors.mapOverlaySpotlight);\n    this.mapOverlayLoading = this.mapOverlay.querySelector(this.css.selectors.mapOverlayLoading);\n\n    //mobile selectors\n    this.locationMobSelect = document.getElementById(this.css.selectors.locationMobSelect);\n    this.properties = document.getElementById(this.css.selectors.properties);\n    this.propertiesContainer = this.properties.querySelector(this.css.selectors.propertiesContainer);\n    this.loadMore = this.properties.querySelector('a');\n\n\n    this.locationMobSelect.addEventListener('change', this.loadData.bind(this));\n\n    //same close button for desktop and mobile overlays\n    this.mapOverlayClose.addEventListener('click', function(e){\n        e.preventDefault();\n        cxt.mapOverlay.classList.remove(cxt.css.states.active);\n    });\n\n    this.loadMore.addEventListener('click', this.loadData.bind(this));\n    window.addEventListener('load', this.initMap.bind(this));\n    window.addEventListener('resize', debounce(this.initMap.bind(this), 200));\n\n}\n\nPropertyMap.prototype.loadData = function(e){\n    //load more and select functionality\n    var cxt = this;\n    e.preventDefault();\n\n    //if the select menu changes...\n    if(e.type == 'change') {\n        cxt.propertiesContainer.innerHTML = \"\";\n        this.selectLocations(e);\n    } else {\n        this.selectLocations(e);\n    }\n\n}\n\nPropertyMap.prototype.selectLocations = function(e) {\n    var cxt = this;\n\n    cxt.propertiesPanels = cxt.properties.querySelectorAll(cxt.css.selectors.propertiesPanel);\n    //prevent action if button is disabled\n    if(!e.currentTarget.classList.contains(cxt.css.states.disabled)) {\n        //current number of panels\n        var panels = cxt.propertiesPanels.length;\n        var panelsMax = panels+3;\n        var target = cxt.locationMobSelect.childNodes[1];                 //select menu\n        var value = target.options[ target.selectedIndex ].text;    //value of select\n\n        cxt.get('json/locations.json').then(function(locations) {\n\n            var locationsMax = locations.length;\n            var areaArr = [];\n\n            if(value !== 'Location all') {\n                //create new array of properties\n                for(i=0 ; i<locationsMax ; i++) {\n                    if(locations[i].area == value) {\n                        areaArr.push(locations[i]);\n                    }\n                }\n\n                locationsMax = areaArr.length; //max from new array\n\n                if(locationsMax <= panelsMax) {\n                    cxt.loadMore.classList.add(cxt.css.states.disabled);\n                    for (i = panels; i < panelsMax; i++) {\n                        cxt.buildMobileList(areaArr[i], areaArr[i].location, areaArr[i].pics[0]); //create property panels\n                    }\n                } else {\n                    cxt.loadMore.classList.remove(cxt.css.states.disabled);\n                    for (i = panels; i < panelsMax; i++) {\n                        cxt.buildMobileList(areaArr[i], areaArr[i].location, areaArr[i].pics[0]); //create property panels\n                    }\n                }\n\n            } else {\n\n                if(locationsMax <= panelsMax) {\n                    cxt.loadMore.classList.add(cxt.css.states.disabled);\n                    for (i = panels; i < panelsMax; i++) {\n                        cxt.buildMobileList(locations[i], locations[i].location, locations[i].pics[0]); //create property panels\n                    }\n                } else {\n                    cxt.loadMore.classList.remove(cxt.css.states.disabled);\n                    for (i = panels; i < panelsMax; i++) {\n                        cxt.buildMobileList(locations[i], locations[i].location, locations[i].pics[0]); //create property panels\n                    }\n                }\n\n            }\n\n        }, function(error) {\n          console.error(\"Failed!\", error);\n        });\n    }\n}\n\nPropertyMap.prototype.initMap = function() {\n\n    var cxt = this;\n    var ww = window.innerWidth;\n\n\n    GoogleMaps.load(function(google) {\n        var map;\n          var styles = {\n              silver:\n                [\n                    {\n                        \"featureType\": \"all\",\n                        \"elementType\": \"geometry\",\n                        \"stylers\": [\n                            {\n                                \"color\": \"#92d1f4\"\n                            }\n                        ]\n                    },\n                    {\n                        \"featureType\": \"all\",\n                        \"elementType\": \"labels.text.fill\",\n                        \"stylers\": [\n                            {\n                                \"gamma\": 0.01\n                            },\n                            {\n                                \"lightness\": 20\n                            }\n                        ]\n                    },\n                    {\n                        \"featureType\": \"all\",\n                        \"elementType\": \"labels.text.stroke\",\n                        \"stylers\": [\n                            {\n                                \"saturation\": -31\n                            },\n                            {\n                                \"lightness\": -33\n                            },\n                            {\n                                \"weight\": 2\n                            },\n                            {\n                                \"gamma\": 0.8\n                            }\n                        ]\n                    },\n                    {\n                        \"featureType\": \"all\",\n                        \"elementType\": \"labels.icon\",\n                        \"stylers\": [\n                            {\n                                \"visibility\": \"off\"\n                            }\n                        ]\n                    },\n                    {\n                        \"featureType\": \"landscape\",\n                        \"elementType\": \"geometry\",\n                        \"stylers\": [\n                            {\n                                \"lightness\": 80\n                            },\n                            {\n                                \"saturation\": 10\n                            }\n                        ]\n                    },\n                    {\n                        \"featureType\": \"poi\",\n                        \"elementType\": \"geometry\",\n                        \"stylers\": [\n                            {\n                                \"saturation\": 20\n                            }\n                        ]\n                    },\n                    {\n                        \"featureType\": \"poi.park\",\n                        \"elementType\": \"geometry\",\n                        \"stylers\": [\n                            {\n                                \"lightness\": 70\n                            },\n                            {\n                                \"saturation\": -20\n                            }\n                        ]\n                    },\n                    {\n                        \"featureType\": \"road\",\n                        \"elementType\": \"geometry\",\n                        \"stylers\": [\n                            {\n                                \"lightness\": 670\n                            },\n                            {\n                                \"saturation\": -30\n                            }\n                        ]\n                    },\n                    {\n                        \"featureType\": \"road\",\n                        \"elementType\": \"geometry.stroke\",\n                        \"stylers\": [\n                            {\n                                \"saturation\": 25\n                            },\n                            {\n                                \"lightness\": 25\n                            }\n                        ]\n                    },\n                    {\n                        \"featureType\": \"water\",\n                        \"elementType\": \"all\",\n                        \"stylers\": [\n                            {\n                                \"saturation\": 35\n                            },\n                            {\n                                \"lightness\":20\n                            }\n                        ]\n                    }\n                ]\n            };\n\n\n          var myStyles =[\n            {\n                featureType: \"poi\",\n                elementType: \"labels\",\n                stylers: [\n                      { visibility: \"off\" }\n                ]\n            },\n            {\n              featureType: 'transit',\n              elementType: 'labels.icon',\n              stylers: [{visibility: 'off'}]\n            }\n        ];\n\n\n        var options = {\n           draggable: true,\n           scrollwheel: true,\n           panControl: true,\n           zoom: 6,\n           disableDefaultUI: true,\n           zoomControl: true,\n           clickableIcons: true,\n           center: {lat: 53.634566, lng: -3.472727},\n           mapTypeId: google.maps.MapTypeId.ROADMAP,\n           styles: myStyles\n       };\n\n\n       if(ww > 768) {\n           map = new google.maps.Map(cxt.$node, options);\n           map.setOptions({styles: styles['silver']});\n\n           //Resize Function\n           google.maps.event.addDomListener(window, \"resize\", function() {\n               var center = map.getCenter();\n               google.maps.event.trigger(map, \"resize\");\n               map.setCenter(center);\n           });\n\n           var image = {\n             url: './dist/images/icons/pin.png',\n             size: new google.maps.Size(37, 40),\n             origin: new google.maps.Point(0, 0),\n             anchor: new google.maps.Point(0, 32)\n           };\n\n           var marker, i;\n           var gmarkers = []; //marker for clusters\n\n           cxt.get('json/locations.json').then(function(locations) {\n\n               for (i = 0; i < locations.length; i++) {\n                   marker = new google.maps.Marker({\n                       position: new google.maps.LatLng(locations[i].lat, locations[i].lng),\n                       map: map,\n                       icon: image\n                   });\n\n                   google.maps.event.addListener(marker, \"click\", (function(marker, i) {\n                       return function() {\n                           cxt.mapOverlayLoading.classList.add(cxt.css.states.active);\n                           cxt.mapOverlayLoading.style.zIndex = 3;\n                           setTimeout(function(){\n                               cxt.scrap();\n                               cxt.buildOverlay(locations[i]);\n                           }, 300);\n                       }\n                   })(marker, i));\n\n                   gmarkers.push(marker);\n               }\n\n               //begin cluster definition\n               var clusterStyles = [\n                   {\n                       textColor: 'white',\n                       textSize: 16,\n                       url: 'dist/images/icons/m1.png',\n                       height: 48,\n                       width: 48\n                   },\n                   {\n                       textColor: 'white',\n                       textSize: 16,\n                       url: 'dist/images/icons/m2.png',\n                       height: 48,\n                       width: 48\n                   },\n                   {\n                       textColor: 'white',\n                       textSize: 16,\n                       url: 'dist/images/icons/m3.png',\n                       height: 48,\n                       width: 48\n                   },\n                   {\n                       textColor: 'white',\n                       textSize: 16,\n                       url: 'dist/images/icons/m4.png',\n                       height: 48,\n                       width: 48\n                   },\n                   {\n                       textColor: 'white',\n                       textSize: 16,\n                       url: 'dist/images/icons/m5.png',\n                       height: 48,\n                       width: 48\n                   }\n               ];\n\n\n                 var mcOptions = {\n                     gridSize: 50,\n                     styles: clusterStyles,\n                     maxZoom: 15\n                 };\n\n                 var markerCluster = new MarkerClusterer(map, gmarkers, mcOptions);\n\n           }, function(error) {\n             console.error(\"Failed!\", error);\n           });\n\n       } else {\n\n           //check whether it already contains properties and has initialised\n           if(!cxt.propertiesContainer.classList.contains(cxt.css.states.init)) {\n               cxt.get('json/locations.json').then(function(locations) {\n\n                   for (i = 0; i < locations.length; i++) {\n                       if(locations.length > 3 && i < 3) {\n                            console.log(locations[i].location);\n                            cxt.buildMobileList(locations[i], locations[i].location, locations[i].pics[0]); //create property panels\n                       }\n                   }\n                   cxt.propertiesContainer.classList.add(cxt.css.states.init);\n\n               }, function(error) {\n                 console.error(\"Failed!\", error);\n               });\n           }\n       }\n\n    });\n}\n\nPropertyMap.prototype.buildMobileList = function(data, title, picUrl) {\n\n    var cxt = this;\n    var parent = document.createElement('div');\n    var imgCont = document.createElement('div');\n    var img = document.createElement('img');\n    var p = document.createElement('p');\n\n    parent.classList.add('properties__panel');\n    imgCont.classList.add('properties__panel--img-cont');\n    parent.appendChild(imgCont);\n\n    img.setAttribute('src', picUrl.url);\n    imgCont.appendChild(img);\n\n    p.innerHTML = title;\n    parent.appendChild(p);\n\n    this.propertiesContainer.appendChild(parent);\n\n    //add click handler and build overlay\n    parent.addEventListener('click', function(){\n        cxt.mapOverlayLoading.classList.add(cxt.css.states.active);\n        cxt.mapOverlayLoading.style.zIndex = 3;\n        setTimeout(function(){\n            cxt.scrap();\n            cxt.buildOverlay(data);\n        }, 300);\n    });\n}\n\n\nPropertyMap.prototype.get = function(url) {\n\n  return new Promise(function(resolve, reject) {\n\n    var req = new XMLHttpRequest();\n    req.open('GET', url);\n\n    req.onload = function() {\n\n      if (req.status == 200) {\n        resolve(JSON.parse(req.response));\n      }\n      else {\n        reject(Error(req.statusText));\n      }\n    };\n\n    // Handle network errors\n    req.onerror = function() {\n      reject(Error(\"Network Error\"));\n    };\n\n    req.send();\n  });\n}\n\nPropertyMap.prototype.scrap = function(){\n    var h4 = this.mapOverlayTitle.querySelector('h4');\n    var p = this.mapOverlayContents.querySelector('p');\n    var li = this.mapOverlayContents.querySelectorAll('li');\n\n    h4.innerHTML = '';\n    p.innerHTML = '';\n    [].forEach.call(li, function(el, index, array){\n        el.innerHTML = '';\n    });\n    this.mapCarouselTrack.innerHTML = '';\n    this.mapCarouselThumbnails.innerHTML = '';\n}\n\nPropertyMap.prototype.initCarousel = function(){\n    var cxt = this;\n    var thumbs = this.mapCarouselThumbnails.querySelectorAll('a');\n    var imgs = this.mapCarouselTrack.querySelectorAll('img');\n    var imgsNum = imgs.length;\n    var imgWidth = this.mapOverlaySpotlight.getBoundingClientRect().width;\n\n    [].forEach.call(imgs, function(el, index, array){\n        el.setAttribute('data-imgindex', index);\n        el.style.width = imgWidth + 'px';\n    });\n\n    [].forEach.call(thumbs, function(el, index, array){\n        el.setAttribute('data-thumbindex', index);\n\n        el.addEventListener('click', function(e){\n            e.preventDefault();\n            var active = cxt.mapCarouselThumbnails.querySelector('.'+cxt.css.states.active);\n            active.classList.toggle(cxt.css.states.active);\n            e.currentTarget.classList.toggle(cxt.css.states.active);\n\n            var i = parseInt(e.currentTarget.getAttribute('data-thumbindex'));\n            cxt.mapCarouselTrack.style.webkitTransform = 'translateX('+ -(i*imgWidth) + 'px)';\n            cxt.mapCarouselTrack.style.transform = 'translateX('+ -(i*imgWidth) + 'px)';\n        });\n    });\n\n    this.mapOverlay.classList.add(cxt.css.states.active);\n    this.mapCarouselTrack.style.width = imgWidth*imgsNum + 'px';\n    cxt.mapOverlayLoading.classList.remove(cxt.css.states.active);\n    setTimeout(function(){\n        cxt.mapOverlayLoading.style.zIndex = -1;\n    }, 300);\n}\n\nPropertyMap.prototype.buildOverlay = function(data){\n    var cxt = this;\n\n    //title\n    var h4 = this.mapOverlayTitle.querySelector('h4');\n    h4.innerHTML = data.location;\n\n    //intro and bullets\n    var p = this.mapOverlayContents.querySelector('p');\n    var li = this.mapOverlayContents.querySelectorAll('li');\n\n    [].forEach.call(li, function(el, index, array){\n        el.innerHTML = '<span class=\"check\"></span>' + data.points[index].txt;\n    });\n\n    p.innerHTML = data.intro;\n\n    //fill thumbnails\n    //fill gallery\n    console.log(data.pics.length);\n    data.pics.forEach(function(i){\n        var img = document.createElement('img');\n        var a = document.createElement('a');\n        img.setAttribute('src', i.url);\n        a.innerHTML = \"<img src=\"+ i.url +\" alt=''>\";\n        cxt.mapCarouselTrack.appendChild(img);\n        cxt.mapCarouselThumbnails.appendChild(a);\n    });\n\n    var firstAnchor = cxt.mapCarouselThumbnails.querySelectorAll('a')[0];\n    firstAnchor.classList.add(this.css.states.active);\n\n    cxt.initCarousel();\n}\n\nmodule.exports = PropertyMap;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./assets/scripts/widgets/property-map.js\n// module id = 18\n// module chunks = 0\n//# sourceURL=webpack:///./assets/scripts/widgets/property-map.js?")},function(module,exports){
eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Npm version of markerClusterer works great with browserify and google maps for commonjs\n * https://www.npmjs.com/package/googlemaps\n * Difference from the original - adds a commonjs format and replaces window with global and some unit test\n * The original functionality it's not modified for docs and original source check\n * https://github.com/googlemaps/js-marker-clusterer\n */\n\n/**\n * @name MarkerClusterer for Google Maps v3\n * @version version 1.0\n * @author Luke Mahe\n * @fileoverview\n * The library creates and manages per-zoom-level clusters for large amounts of\n * markers.\n * <br/>\n * This is a v3 implementation of the\n * <a href=\"http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/\"\n * >v2 MarkerClusterer</a>.\n */\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A Marker Clusterer that clusters markers.\n *\n * @param {google.maps.Map} map The Google map to attach to.\n * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to\n *   the cluster.\n * @param {Object=} opt_options support the following options:\n *     'gridSize': (number) The grid size of a cluster in pixels.\n *     'maxZoom': (number) The maximum zoom level that a marker can be part of a\n *                cluster.\n *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a\n *                    cluster is to zoom into it.\n *     'averageCenter': (boolean) Wether the center of each cluster should be\n *                      the average of all markers in the cluster.\n *     'minimumClusterSize': (number) The minimum number of markers to be in a\n *                           cluster before the markers are hidden and a count\n *                           is shown.\n *     'styles': (object) An object that has style properties:\n *       'url': (string) The image url.\n *       'height': (number) The image height.\n *       'width': (number) The image width.\n *       'anchor': (Array) The anchor position of the label text.\n *       'textColor': (string) The text color.\n *       'textSize': (number) The text size.\n *       'backgroundPosition': (string) The position of the backgound x, y.\n * @constructor\n * @extends google.maps.OverlayView\n */\nfunction MarkerClusterer(map, opt_markers, opt_options) {\n  // MarkerClusterer implements google.maps.OverlayView interface. We use the\n  // extend function to extend MarkerClusterer with google.maps.OverlayView\n  // because it might not always be available when the code is defined so we\n  // look for it at the last possible moment. If it doesn't exist now then\n  // there is no point going ahead :)\n  this.extend(MarkerClusterer, google.maps.OverlayView);\n  this.map_ = map;\n\n  /**\n   * @type {Array.<google.maps.Marker>}\n   * @private\n   */\n  this.markers_ = [];\n\n  /**\n   *  @type {Array.<Cluster>}\n   */\n  this.clusters_ = [];\n\n  this.sizes = [53, 56, 66, 78, 90];\n\n  /**\n   * @private\n   */\n  this.styles_ = [];\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.ready_ = false;\n\n  var options = opt_options || {};\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.gridSize_ = options['gridSize'] || 60;\n\n  /**\n   * @private\n   */\n  this.minClusterSize_ = options['minimumClusterSize'] || 2;\n\n\n  /**\n   * @type {?number}\n   * @private\n   */\n  this.maxZoom_ = options['maxZoom'] || null;\n\n  this.styles_ = options['styles'] || [];\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imagePath_ = options['imagePath'] ||\n      this.MARKER_CLUSTER_IMAGE_PATH_;\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imageExtension_ = options['imageExtension'] ||\n      this.MARKER_CLUSTER_IMAGE_EXTENSION_;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.zoomOnClick_ = true;\n\n  if (options['zoomOnClick'] != undefined) {\n    this.zoomOnClick_ = options['zoomOnClick'];\n  }\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.averageCenter_ = false;\n\n  if (options['averageCenter'] != undefined) {\n    this.averageCenter_ = options['averageCenter'];\n  }\n\n  this.setupStyles_();\n\n  this.setMap(map);\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.prevZoom_ = this.map_.getZoom();\n\n  // Add the map event listeners\n  var that = this;\n  google.maps.event.addListener(this.map_, 'zoom_changed', function() {\n    var zoom = that.map_.getZoom();\n\n    if (that.prevZoom_ != zoom) {\n      that.prevZoom_ = zoom;\n      that.resetViewport();\n    }\n  });\n\n  google.maps.event.addListener(this.map_, 'idle', function() {\n    that.redraw();\n  });\n\n  // Finally, add the markers\n  if (opt_markers && opt_markers.length) {\n    this.addMarkers(opt_markers, false);\n  }\n}\n\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ =\n    'http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclusterer/' +\n    'images/m';\n\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';\n\n\n/**\n * Extends a objects prototype by anothers.\n *\n * @param {Object} obj1 The object to be extended.\n * @param {Object} obj2 The object to extend with.\n * @return {Object} The new extended object.\n * @ignore\n */\nMarkerClusterer.prototype.extend = function(obj1, obj2) {\n  return (function(object) {\n    for (var property in object.prototype) {\n      this.prototype[property] = object.prototype[property];\n    }\n    return this;\n  }).apply(obj1, [obj2]);\n};\n\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.onAdd = function() {\n  this.setReady_(true);\n};\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.draw = function() {};\n\n/**\n * Sets up the styles object.\n *\n * @private\n */\nMarkerClusterer.prototype.setupStyles_ = function() {\n  if (this.styles_.length) {\n    return;\n  }\n\n  for (var i = 0, size; size = this.sizes[i]; i++) {\n    this.styles_.push({\n      url: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,\n      height: size,\n      width: size\n    });\n  }\n};\n\n/**\n *  Fit the map to the bounds of the markers in the clusterer.\n */\nMarkerClusterer.prototype.fitMapToMarkers = function() {\n  var markers = this.getMarkers();\n  var bounds = new google.maps.LatLngBounds();\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n\n  this.map_.fitBounds(bounds);\n};\n\n\n/**\n *  Sets the styles.\n *\n *  @param {Object} styles The style to set.\n */\nMarkerClusterer.prototype.setStyles = function(styles) {\n  this.styles_ = styles;\n};\n\n\n/**\n *  Gets the styles.\n *\n *  @return {Object} The styles object.\n */\nMarkerClusterer.prototype.getStyles = function() {\n  return this.styles_;\n};\n\n\n/**\n * Whether zoom on click is set.\n *\n * @return {boolean} True if zoomOnClick_ is set.\n */\nMarkerClusterer.prototype.isZoomOnClick = function() {\n  return this.zoomOnClick_;\n};\n\n/**\n * Whether average center is set.\n *\n * @return {boolean} True if averageCenter_ is set.\n */\nMarkerClusterer.prototype.isAverageCenter = function() {\n  return this.averageCenter_;\n};\n\n\n/**\n *  Returns the array of markers in the clusterer.\n *\n *  @return {Array.<google.maps.Marker>} The markers.\n */\nMarkerClusterer.prototype.getMarkers = function() {\n  return this.markers_;\n};\n\n\n/**\n *  Returns the number of markers in the clusterer\n *\n *  @return {Number} The number of markers.\n */\nMarkerClusterer.prototype.getTotalMarkers = function() {\n  return this.markers_.length;\n};\n\n\n/**\n *  Sets the max zoom for the clusterer.\n *\n *  @param {number} maxZoom The max zoom level.\n */\nMarkerClusterer.prototype.setMaxZoom = function(maxZoom) {\n  this.maxZoom_ = maxZoom;\n};\n\n\n/**\n *  Gets the max zoom for the clusterer.\n *\n *  @return {number} The max zoom level.\n */\nMarkerClusterer.prototype.getMaxZoom = function() {\n  return this.maxZoom_;\n};\n\n\n/**\n *  The function for calculating the cluster icon image.\n *\n *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.\n *  @param {number} numStyles The number of styles available.\n *  @return {Object} A object properties: 'text' (string) and 'index' (number).\n *  @private\n */\nMarkerClusterer.prototype.calculator_ = function(markers, numStyles) {\n  var index = 0;\n  var count = markers.length;\n  var dv = count;\n  while (dv !== 0) {\n    dv = parseInt(dv / 10, 10);\n    index++;\n  }\n\n  index = Math.min(index, numStyles);\n  return {\n    text: count,\n    index: index\n  };\n};\n\n\n/**\n * Set the calculator function.\n *\n * @param {function(Array, number)} calculator The function to set as the\n *     calculator. The function should return a object properties:\n *     'text' (string) and 'index' (number).\n *\n */\nMarkerClusterer.prototype.setCalculator = function(calculator) {\n  this.calculator_ = calculator;\n};\n\n\n/**\n * Get the calculator function.\n *\n * @return {function(Array, number)} the calculator function.\n */\nMarkerClusterer.prototype.getCalculator = function() {\n  return this.calculator_;\n};\n\n\n/**\n * Add an array of markers to the clusterer.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    this.pushMarkerTo_(marker);\n  }\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n\n/**\n * Pushes a marker to the clusterer.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.pushMarkerTo_ = function(marker) {\n  marker.isAdded = false;\n  if (marker['draggable']) {\n    // If the marker is draggable add a listener so we update the clusters on\n    // the drag end.\n    var that = this;\n    google.maps.event.addListener(marker, 'dragend', function() {\n      marker.isAdded = false;\n      that.repaint();\n    });\n  }\n  this.markers_.push(marker);\n};\n\n\n/**\n * Adds a marker to the clusterer and redraws if needed.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {\n  this.pushMarkerTo_(marker);\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n\n/**\n * Removes a marker and returns true if removed, false if not\n *\n * @param {google.maps.Marker} marker The marker to remove\n * @return {boolean} Whether the marker was removed or not\n * @private\n */\nMarkerClusterer.prototype.removeMarker_ = function(marker) {\n  var index = -1;\n  if (this.markers_.indexOf) {\n    index = this.markers_.indexOf(marker);\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        index = i;\n        break;\n      }\n    }\n  }\n\n  if (index == -1) {\n    // Marker is not in our list of markers.\n    return false;\n  }\n\n  marker.setMap(null);\n\n  this.markers_.splice(index, 1);\n\n  return true;\n};\n\n\n/**\n * Remove a marker from the cluster.\n *\n * @param {google.maps.Marker} marker The marker to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n * @return {boolean} True if the marker was removed.\n */\nMarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {\n  var removed = this.removeMarker_(marker);\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  } else {\n   return false;\n  }\n};\n\n\n/**\n * Removes an array of markers from the cluster.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n */\nMarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {\n  var removed = false;\n\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    var r = this.removeMarker_(marker);\n    removed = removed || r;\n  }\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  }\n};\n\n\n/**\n * Sets the clusterer's ready state.\n *\n * @param {boolean} ready The state.\n * @private\n */\nMarkerClusterer.prototype.setReady_ = function(ready) {\n  if (!this.ready_) {\n    this.ready_ = ready;\n    this.createClusters_();\n  }\n};\n\n\n/**\n * Returns the number of clusters in the clusterer.\n *\n * @return {number} The number of clusters.\n */\nMarkerClusterer.prototype.getTotalClusters = function() {\n  return this.clusters_.length;\n};\n\n\n/**\n * Returns the google map that the clusterer is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nMarkerClusterer.prototype.getMap = function() {\n  return this.map_;\n};\n\n\n/**\n * Sets the google map that the clusterer is associated with.\n *\n * @param {google.maps.Map} map The map.\n */\nMarkerClusterer.prototype.setMap = function(map) {\n  this.map_ = map;\n};\n\n\n/**\n * Returns the size of the grid.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getGridSize = function() {\n  return this.gridSize_;\n};\n\n\n/**\n * Sets the size of the grid.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setGridSize = function(size) {\n  this.gridSize_ = size;\n};\n\n\n/**\n * Returns the min cluster size.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getMinClusterSize = function() {\n  return this.minClusterSize_;\n};\n\n/**\n * Sets the min cluster size.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setMinClusterSize = function(size) {\n  this.minClusterSize_ = size;\n};\n\n\n/**\n * Extends a bounds object by the grid size.\n *\n * @param {google.maps.LatLngBounds} bounds The bounds to extend.\n * @return {google.maps.LatLngBounds} The extended bounds.\n */\nMarkerClusterer.prototype.getExtendedBounds = function(bounds) {\n  var projection = this.getProjection();\n\n  // Turn the bounds into latlng.\n  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),\n      bounds.getNorthEast().lng());\n  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),\n      bounds.getSouthWest().lng());\n\n  // Convert the points to pixels and the extend out by the grid size.\n  var trPix = projection.fromLatLngToDivPixel(tr);\n  trPix.x += this.gridSize_;\n  trPix.y -= this.gridSize_;\n\n  var blPix = projection.fromLatLngToDivPixel(bl);\n  blPix.x -= this.gridSize_;\n  blPix.y += this.gridSize_;\n\n  // Convert the pixel points back to LatLng\n  var ne = projection.fromDivPixelToLatLng(trPix);\n  var sw = projection.fromDivPixelToLatLng(blPix);\n\n  // Extend the bounds to contain the new bounds.\n  bounds.extend(ne);\n  bounds.extend(sw);\n\n  return bounds;\n};\n\n\n/**\n * Determins if a marker is contained in a bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @param {google.maps.LatLngBounds} bounds The bounds to check against.\n * @return {boolean} True if the marker is in the bounds.\n * @private\n */\nMarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {\n  return bounds.contains(marker.getPosition());\n};\n\n\n/**\n * Clears all clusters and markers from the clusterer.\n */\nMarkerClusterer.prototype.clearMarkers = function() {\n  this.resetViewport(true);\n\n  // Set the markers a empty array.\n  this.markers_ = [];\n};\n\n\n/**\n * Clears all existing clusters and recreates them.\n * @param {boolean} opt_hide To also hide the marker.\n */\nMarkerClusterer.prototype.resetViewport = function(opt_hide) {\n  // Remove all the clusters\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    cluster.remove();\n  }\n\n  // Reset the markers to not be added and to be invisible.\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    marker.isAdded = false;\n    if (opt_hide) {\n      marker.setMap(null);\n    }\n  }\n\n  this.clusters_ = [];\n};\n\n/**\n *\n */\nMarkerClusterer.prototype.repaint = function() {\n  var oldClusters = this.clusters_.slice();\n  this.clusters_.length = 0;\n  this.resetViewport();\n  this.redraw();\n\n  // Remove the old clusters.\n  // Do it in a timeout so the other clusters have been drawn first.\n  window.setTimeout(function() {\n    for (var i = 0, cluster; cluster = oldClusters[i]; i++) {\n      cluster.remove();\n    }\n  }, 0);\n};\n\n\n/**\n * Redraws the clusters.\n */\nMarkerClusterer.prototype.redraw = function() {\n  this.createClusters_();\n};\n\n\n/**\n * Calculates the distance between two latlng locations in km.\n * @see http://www.movable-type.co.uk/scripts/latlong.html\n *\n * @param {google.maps.LatLng} p1 The first lat lng point.\n * @param {google.maps.LatLng} p2 The second lat lng point.\n * @return {number} The distance between the two points in km.\n * @private\n*/\nMarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {\n  if (!p1 || !p2) {\n    return 0;\n  }\n\n  var R = 6371; // Radius of the Earth in km\n  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;\n  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;\n  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *\n    Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  var d = R * c;\n  return d;\n};\n\n\n/**\n * Add a marker to a cluster, or creates a new cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.addToClosestCluster_ = function(marker) {\n  var distance = 40000; // Some large number\n  var clusterToAddTo = null;\n  var pos = marker.getPosition();\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    var center = cluster.getCenter();\n    if (center) {\n      var d = this.distanceBetweenPoints_(center, marker.getPosition());\n      if (d < distance) {\n        distance = d;\n        clusterToAddTo = cluster;\n      }\n    }\n  }\n\n  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n    clusterToAddTo.addMarker(marker);\n  } else {\n    var cluster = new Cluster(this);\n    cluster.addMarker(marker);\n    this.clusters_.push(cluster);\n  }\n};\n\n\n/**\n * Creates the clusters.\n *\n * @private\n */\nMarkerClusterer.prototype.createClusters_ = function() {\n  if (!this.ready_) {\n    return;\n  }\n\n  // Get our current map view bounds.\n  // Create a new bounds object so we don't affect the map.\n  var mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(),\n      this.map_.getBounds().getNorthEast());\n  var bounds = this.getExtendedBounds(mapBounds);\n\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\n      this.addToClosestCluster_(marker);\n    }\n  }\n};\n\n\n/**\n * A cluster that contains markers.\n *\n * @param {MarkerClusterer} markerClusterer The markerclusterer that this\n *     cluster is associated with.\n * @constructor\n * @ignore\n */\nfunction Cluster(markerClusterer) {\n  this.markerClusterer_ = markerClusterer;\n  this.map_ = markerClusterer.getMap();\n  this.gridSize_ = markerClusterer.getGridSize();\n  this.minClusterSize_ = markerClusterer.getMinClusterSize();\n  this.averageCenter_ = markerClusterer.isAverageCenter();\n  this.center_ = null;\n  this.markers_ = [];\n  this.bounds_ = null;\n  this.clusterIcon_ = new ClusterIcon(this, markerClusterer.getStyles(),\n      markerClusterer.getGridSize());\n}\n\n/**\n * Determins if a marker is already added to the cluster.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker is already added.\n */\nCluster.prototype.isMarkerAlreadyAdded = function(marker) {\n  if (this.markers_.indexOf) {\n    return this.markers_.indexOf(marker) != -1;\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n\n/**\n * Add a marker the cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @return {boolean} True if the marker was added.\n */\nCluster.prototype.addMarker = function(marker) {\n  if (this.isMarkerAlreadyAdded(marker)) {\n    return false;\n  }\n\n  if (!this.center_) {\n    this.center_ = marker.getPosition();\n    this.calculateBounds_();\n  } else {\n    if (this.averageCenter_) {\n      var l = this.markers_.length + 1;\n      var lat = (this.center_.lat() * (l-1) + marker.getPosition().lat()) / l;\n      var lng = (this.center_.lng() * (l-1) + marker.getPosition().lng()) / l;\n      this.center_ = new google.maps.LatLng(lat, lng);\n      this.calculateBounds_();\n    }\n  }\n\n  marker.isAdded = true;\n  this.markers_.push(marker);\n\n  var len = this.markers_.length;\n  if (len < this.minClusterSize_ && marker.getMap() != this.map_) {\n    // Min cluster size not reached so show the marker.\n    marker.setMap(this.map_);\n  }\n\n  if (len == this.minClusterSize_) {\n    // Hide the markers that were showing.\n    for (var i = 0; i < len; i++) {\n      this.markers_[i].setMap(null);\n    }\n  }\n\n  if (len >= this.minClusterSize_) {\n    marker.setMap(null);\n  }\n\n  this.updateIcon();\n  return true;\n};\n\n\n/**\n * Returns the marker clusterer that the cluster is associated with.\n *\n * @return {MarkerClusterer} The associated marker clusterer.\n */\nCluster.prototype.getMarkerClusterer = function() {\n  return this.markerClusterer_;\n};\n\n\n/**\n * Returns the bounds of the cluster.\n *\n * @return {google.maps.LatLngBounds} the cluster bounds.\n */\nCluster.prototype.getBounds = function() {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  var markers = this.getMarkers();\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n  return bounds;\n};\n\n\n/**\n * Removes the cluster\n */\nCluster.prototype.remove = function() {\n  this.clusterIcon_.remove();\n  this.markers_.length = 0;\n  delete this.markers_;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {number} The cluster center.\n */\nCluster.prototype.getSize = function() {\n  return this.markers_.length;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {Array.<google.maps.Marker>} The cluster center.\n */\nCluster.prototype.getMarkers = function() {\n  return this.markers_;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {google.maps.LatLng} The cluster center.\n */\nCluster.prototype.getCenter = function() {\n  return this.center_;\n};\n\n\n/**\n * Calculated the extended bounds of the cluster with the grid.\n *\n * @private\n */\nCluster.prototype.calculateBounds_ = function() {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\n};\n\n\n/**\n * Determines if a marker lies in the clusters bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker lies in the bounds.\n */\nCluster.prototype.isMarkerInClusterBounds = function(marker) {\n  return this.bounds_.contains(marker.getPosition());\n};\n\n\n/**\n * Returns the map that the cluster is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nCluster.prototype.getMap = function() {\n  return this.map_;\n};\n\n\n/**\n * Updates the cluster icon\n */\nCluster.prototype.updateIcon = function() {\n  var zoom = this.map_.getZoom();\n  var mz = this.markerClusterer_.getMaxZoom();\n\n  if (mz && zoom > mz) {\n    // The zoom is greater than our max zoom so show all the markers in cluster.\n    for (var i = 0, marker; marker = this.markers_[i]; i++) {\n      marker.setMap(this.map_);\n    }\n    return;\n  }\n\n  if (this.markers_.length < this.minClusterSize_) {\n    // Min cluster size not yet reached.\n    this.clusterIcon_.hide();\n    return;\n  }\n\n  var numStyles = this.markerClusterer_.getStyles().length;\n  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);\n  this.clusterIcon_.setCenter(this.center_);\n  this.clusterIcon_.setSums(sums);\n  this.clusterIcon_.show();\n};\n\n\n/**\n * A cluster icon\n *\n * @param {Cluster} cluster The cluster to be associated with.\n * @param {Object} styles An object that has style properties:\n *     'url': (string) The image url.\n *     'height': (number) The image height.\n *     'width': (number) The image width.\n *     'anchor': (Array) The anchor position of the label text.\n *     'textColor': (string) The text color.\n *     'textSize': (number) The text size.\n *     'backgroundPosition: (string) The background postition x, y.\n * @param {number=} opt_padding Optional padding to apply to the cluster icon.\n * @constructor\n * @extends google.maps.OverlayView\n * @ignore\n */\nfunction ClusterIcon(cluster, styles, opt_padding) {\n  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);\n\n  this.styles_ = styles;\n  this.padding_ = opt_padding || 0;\n  this.cluster_ = cluster;\n  this.center_ = null;\n  this.map_ = cluster.getMap();\n  this.div_ = null;\n  this.sums_ = null;\n  this.visible_ = false;\n\n  this.setMap(this.map_);\n}\n\n\n/**\n * Triggers the clusterclick event and zoom's if the option is set.\n */\nClusterIcon.prototype.triggerClusterClick = function() {\n  var markerClusterer = this.cluster_.getMarkerClusterer();\n\n  // Trigger the clusterclick event.\n  google.maps.event.trigger(markerClusterer, 'clusterclick', this.cluster_);\n\n  if (markerClusterer.isZoomOnClick()) {\n    // Zoom into the cluster.\n    this.map_.fitBounds(this.cluster_.getBounds());\n  }\n};\n\n\n/**\n * Adding the cluster icon to the dom.\n * @ignore\n */\nClusterIcon.prototype.onAdd = function() {\n  this.div_ = document.createElement('DIV');\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.innerHTML = this.sums_.text;\n  }\n\n  var panes = this.getPanes();\n  panes.overlayMouseTarget.appendChild(this.div_);\n\n  var that = this;\n  google.maps.event.addDomListener(this.div_, 'click', function() {\n    that.triggerClusterClick();\n  });\n};\n\n\n/**\n * Returns the position to place the div dending on the latlng.\n *\n * @param {google.maps.LatLng} latlng The position in latlng.\n * @return {google.maps.Point} The position in pixels.\n * @private\n */\nClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {\n  var pos = this.getProjection().fromLatLngToDivPixel(latlng);\n  pos.x -= parseInt(this.width_ / 2, 10);\n  pos.y -= parseInt(this.height_ / 2, 10);\n  return pos;\n};\n\n\n/**\n * Draw the icon.\n * @ignore\n */\nClusterIcon.prototype.draw = function() {\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.top = pos.y + 'px';\n    this.div_.style.left = pos.x + 'px';\n  }\n};\n\n\n/**\n * Hide the icon.\n */\nClusterIcon.prototype.hide = function() {\n  if (this.div_) {\n    this.div_.style.display = 'none';\n  }\n  this.visible_ = false;\n};\n\n\n/**\n * Position and show the icon.\n */\nClusterIcon.prototype.show = function() {\n  if (this.div_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.style.display = '';\n  }\n  this.visible_ = true;\n};\n\n\n/**\n * Remove the icon from the map\n */\nClusterIcon.prototype.remove = function() {\n  this.setMap(null);\n};\n\n\n/**\n * Implementation of the onRemove interface.\n * @ignore\n */\nClusterIcon.prototype.onRemove = function() {\n  if (this.div_ && this.div_.parentNode) {\n    this.hide();\n    this.div_.parentNode.removeChild(this.div_);\n    this.div_ = null;\n  }\n};\n\n\n/**\n * Set the sums of the icon.\n *\n * @param {Object} sums The sums containing:\n *   'text': (string) The text to display in the icon.\n *   'index': (number) The style index of the icon.\n */\nClusterIcon.prototype.setSums = function(sums) {\n  this.sums_ = sums;\n  this.text_ = sums.text;\n  this.index_ = sums.index;\n  if (this.div_) {\n    this.div_.innerHTML = sums.text;\n  }\n\n  this.useStyle();\n};\n\n\n/**\n * Sets the icon to the the styles.\n */\nClusterIcon.prototype.useStyle = function() {\n  var index = Math.max(0, this.sums_.index - 1);\n  index = Math.min(this.styles_.length - 1, index);\n  var style = this.styles_[index];\n  this.url_ = style['url'];\n  this.height_ = style['height'];\n  this.width_ = style['width'];\n  this.textColor_ = style['textColor'];\n  this.anchor_ = style['anchor'];\n  this.textSize_ = style['textSize'];\n  this.backgroundPosition_ = style['backgroundPosition'];\n};\n\n\n/**\n * Sets the center of the icon.\n *\n * @param {google.maps.LatLng} center The latlng to set as the center.\n */\nClusterIcon.prototype.setCenter = function(center) {\n  this.center_ = center;\n};\n\n\n/**\n * Create the css text based on the position of the icon.\n *\n * @param {google.maps.Point} pos The position.\n * @return {string} The css style text.\n */\nClusterIcon.prototype.createCss = function(pos) {\n  var style = [];\n  style.push('background-image:url(' + this.url_ + ');');\n  var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';\n  style.push('background-position:' + backgroundPosition + ';');\n\n  if (typeof this.anchor_ === 'object') {\n    if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&\n        this.anchor_[0] < this.height_) {\n      style.push('height:' + (this.height_ - this.anchor_[0]) +\n          'px; padding-top:' + this.anchor_[0] + 'px;');\n    } else {\n      style.push('height:' + this.height_ + 'px; line-height:' + this.height_ +\n          'px;');\n    }\n    if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&\n        this.anchor_[1] < this.width_) {\n      style.push('width:' + (this.width_ - this.anchor_[1]) +\n          'px; padding-left:' + this.anchor_[1] + 'px;');\n    } else {\n      style.push('width:' + this.width_ + 'px; text-align:center;');\n    }\n  } else {\n    style.push('height:' + this.height_ + 'px; line-height:' +\n        this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');\n  }\n\n  var txtColor = this.textColor_ ? this.textColor_ : 'black';\n  var txtSize = this.textSize_ ? this.textSize_ : 11;\n\n  style.push('cursor:pointer; top:' + pos.y + 'px; left:' +\n      pos.x + 'px; color:' + txtColor + '; position:absolute; font-size:' +\n      txtSize + 'px; font-family:Arial,sans-serif; font-weight:bold');\n  return style.join('');\n};\n\n\n// Export Symbols for Closure\n// If you are not going to compile with closure then you can remove the\n// code below.\nglobal['MarkerClusterer'] = MarkerClusterer;\nMarkerClusterer.prototype['addMarker'] = MarkerClusterer.prototype.addMarker;\nMarkerClusterer.prototype['addMarkers'] = MarkerClusterer.prototype.addMarkers;\nMarkerClusterer.prototype['clearMarkers'] =\n    MarkerClusterer.prototype.clearMarkers;\nMarkerClusterer.prototype['fitMapToMarkers'] =\n    MarkerClusterer.prototype.fitMapToMarkers;\nMarkerClusterer.prototype['getCalculator'] =\n    MarkerClusterer.prototype.getCalculator;\nMarkerClusterer.prototype['getGridSize'] =\n    MarkerClusterer.prototype.getGridSize;\nMarkerClusterer.prototype['getExtendedBounds'] =\n    MarkerClusterer.prototype.getExtendedBounds;\nMarkerClusterer.prototype['getMap'] = MarkerClusterer.prototype.getMap;\nMarkerClusterer.prototype['getMarkers'] = MarkerClusterer.prototype.getMarkers;\nMarkerClusterer.prototype['getMaxZoom'] = MarkerClusterer.prototype.getMaxZoom;\nMarkerClusterer.prototype['getStyles'] = MarkerClusterer.prototype.getStyles;\nMarkerClusterer.prototype['getTotalClusters'] =\n    MarkerClusterer.prototype.getTotalClusters;\nMarkerClusterer.prototype['getTotalMarkers'] =\n    MarkerClusterer.prototype.getTotalMarkers;\nMarkerClusterer.prototype['redraw'] = MarkerClusterer.prototype.redraw;\nMarkerClusterer.prototype['removeMarker'] =\n    MarkerClusterer.prototype.removeMarker;\nMarkerClusterer.prototype['removeMarkers'] =\n    MarkerClusterer.prototype.removeMarkers;\nMarkerClusterer.prototype['resetViewport'] =\n    MarkerClusterer.prototype.resetViewport;\nMarkerClusterer.prototype['repaint'] =\n    MarkerClusterer.prototype.repaint;\nMarkerClusterer.prototype['setCalculator'] =\n    MarkerClusterer.prototype.setCalculator;\nMarkerClusterer.prototype['setGridSize'] =\n    MarkerClusterer.prototype.setGridSize;\nMarkerClusterer.prototype['setMaxZoom'] =\n    MarkerClusterer.prototype.setMaxZoom;\nMarkerClusterer.prototype['onAdd'] = MarkerClusterer.prototype.onAdd;\nMarkerClusterer.prototype['draw'] = MarkerClusterer.prototype.draw;\n\nCluster.prototype['getCenter'] = Cluster.prototype.getCenter;\nCluster.prototype['getSize'] = Cluster.prototype.getSize;\nCluster.prototype['getMarkers'] = Cluster.prototype.getMarkers;\n\nClusterIcon.prototype['onAdd'] = ClusterIcon.prototype.onAdd;\nClusterIcon.prototype['draw'] = ClusterIcon.prototype.draw;\nClusterIcon.prototype['onRemove'] = ClusterIcon.prototype.onRemove;\n\n\nmodule.exports = MarkerClusterer;\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/node-js-marker-clusterer/src/markerclusterer.js\n// module id = 19\n// module chunks = 0\n//# sourceURL=webpack:///./~/node-js-marker-clusterer/src/markerclusterer.js?")
},function(module,exports,__webpack_require__){eval("var Swiper = __webpack_require__(21);\n\nfunction Carousel(node){\n    this.node = node;\n    this.init();\n}\n\nCarousel.prototype.init = function(){\n\n    var ww = window.innerWidth;\n    var slider = this.node;\n    var dot_count         = slider.querySelectorAll('.js_slide').length;\n    var dot_container     = slider.querySelector('.js_dots');\n    var dot_list_item     = document.createElement('li');\n\n    var swiper = new Swiper(slider, {\n      slidesPerView: 3,\n      spaceBetween: 30,\n      loop: true,\n      pagination: {\n         el: '.swiper-pagination',\n      },\n      navigation: {\n         nextEl: '.swiper-button-next',\n         prevEl: '.swiper-button-prev',\n      },\n      breakpoints: {\n        998: {\n          slidesPerView: 2,\n          spaceBetween: 20,\n        },\n        500: {\n          slidesPerView: 1,\n          spaceBetween: 10,\n        }\n      }\n    });\n\n}\n\nmodule.exports = Carousel;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./assets/scripts/widgets/carousel.js\n// module id = 20\n// module chunks = 0\n//# sourceURL=webpack:///./assets/scripts/widgets/carousel.js?")},function(module,exports,__webpack_require__){
eval("/**\n * Swiper 4.0.7\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * http://www.idangero.us/swiper/\n *\n * Copyright 2014-2017 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: November 28, 2017\n */\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.Swiper = factory());\n}(this, (function () { 'use strict';\n\nvar w;\nif (typeof window === 'undefined') {\n  w = {\n    navigator: {\n      userAgent: '',\n    },\n    location: {},\n    history: {},\n    addEventListener: function addEventListener() {},\n    removeEventListener: function removeEventListener() {},\n    getComputedStyle: function getComputedStyle() {\n      return {};\n    },\n    Image: function Image() {},\n    Date: function Date() {},\n    screen: {},\n  };\n} else {\n  w = window;\n}\n\nvar win = w;\n\n/**\n * Dom7 2.0.1\n * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API\n * http://framework7.io/docs/dom.html\n *\n * Copyright 2017, Vladimir Kharlampidi\n * The iDangero.us\n * http://www.idangero.us/\n *\n * Licensed under MIT\n *\n * Released on: October 2, 2017\n */\nvar Dom7 = function Dom7(arr) {\n  var self = this;\n  // Create array-like object\n  for (var i = 0; i < arr.length; i += 1) {\n    self[i] = arr[i];\n  }\n  self.length = arr.length;\n  // Return collection with methods\n  return this;\n};\n\nfunction $$1(selector, context) {\n  var arr = [];\n  var i = 0;\n  if (selector && !context) {\n    if (selector instanceof Dom7) {\n      return selector;\n    }\n  }\n  if (selector) {\n      // String\n    if (typeof selector === 'string') {\n      var els;\n      var tempParent;\n      var html = selector.trim();\n      if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {\n        var toCreate = 'div';\n        if (html.indexOf('<li') === 0) { toCreate = 'ul'; }\n        if (html.indexOf('<tr') === 0) { toCreate = 'tbody'; }\n        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) { toCreate = 'tr'; }\n        if (html.indexOf('<tbody') === 0) { toCreate = 'table'; }\n        if (html.indexOf('<option') === 0) { toCreate = 'select'; }\n        tempParent = document.createElement(toCreate);\n        tempParent.innerHTML = html;\n        for (i = 0; i < tempParent.childNodes.length; i += 1) {\n          arr.push(tempParent.childNodes[i]);\n        }\n      } else {\n        if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {\n          // Pure ID selector\n          els = [document.getElementById(selector.trim().split('#')[1])];\n        } else {\n          // Other selectors\n          els = (context || document).querySelectorAll(selector.trim());\n        }\n        for (i = 0; i < els.length; i += 1) {\n          if (els[i]) { arr.push(els[i]); }\n        }\n      }\n    } else if (selector.nodeType || selector === window || selector === document) {\n      // Node/element\n      arr.push(selector);\n    } else if (selector.length > 0 && selector[0].nodeType) {\n      // Array of elements or instance of Dom\n      for (i = 0; i < selector.length; i += 1) {\n        arr.push(selector[i]);\n      }\n    }\n  }\n  return new Dom7(arr);\n}\n\n$$1.fn = Dom7.prototype;\n$$1.Class = Dom7;\n$$1.Dom7 = Dom7;\n\nfunction unique(arr) {\n  var uniqueArray = [];\n  for (var i = 0; i < arr.length; i += 1) {\n    if (uniqueArray.indexOf(arr[i]) === -1) { uniqueArray.push(arr[i]); }\n  }\n  return uniqueArray;\n}\n// Classes and attributes\nfunction addClass(className) {\n  var this$1 = this;\n\n  if (typeof className === 'undefined') {\n    return this;\n  }\n  var classes = className.split(' ');\n  for (var i = 0; i < classes.length; i += 1) {\n    for (var j = 0; j < this.length; j += 1) {\n      if (typeof this$1[j].classList !== 'undefined') { this$1[j].classList.add(classes[i]); }\n    }\n  }\n  return this;\n}\nfunction removeClass(className) {\n  var this$1 = this;\n\n  var classes = className.split(' ');\n  for (var i = 0; i < classes.length; i += 1) {\n    for (var j = 0; j < this.length; j += 1) {\n      if (typeof this$1[j].classList !== 'undefined') { this$1[j].classList.remove(classes[i]); }\n    }\n  }\n  return this;\n}\nfunction hasClass(className) {\n  if (!this[0]) { return false; }\n  return this[0].classList.contains(className);\n}\nfunction toggleClass(className) {\n  var this$1 = this;\n\n  var classes = className.split(' ');\n  for (var i = 0; i < classes.length; i += 1) {\n    for (var j = 0; j < this.length; j += 1) {\n      if (typeof this$1[j].classList !== 'undefined') { this$1[j].classList.toggle(classes[i]); }\n    }\n  }\n  return this;\n}\nfunction attr(attrs, value) {\n  var arguments$1 = arguments;\n  var this$1 = this;\n\n  if (arguments.length === 1 && typeof attrs === 'string') {\n    // Get attr\n    if (this[0]) { return this[0].getAttribute(attrs); }\n    return undefined;\n  }\n\n  // Set attrs\n  for (var i = 0; i < this.length; i += 1) {\n    if (arguments$1.length === 2) {\n      // String\n      this$1[i].setAttribute(attrs, value);\n    } else {\n      // Object\n      // eslint-disable-next-line\n      for (var attrName in attrs) {\n        this$1[i][attrName] = attrs[attrName];\n        this$1[i].setAttribute(attrName, attrs[attrName]);\n      }\n    }\n  }\n  return this;\n}\n// eslint-disable-next-line\nfunction removeAttr(attr) {\n  var this$1 = this;\n\n  for (var i = 0; i < this.length; i += 1) {\n    this$1[i].removeAttribute(attr);\n  }\n  return this;\n}\nfunction data(key, value) {\n  var this$1 = this;\n\n  var el;\n  if (typeof value === 'undefined') {\n    el = this[0];\n    // Get value\n    if (el) {\n      if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {\n        return el.dom7ElementDataStorage[key];\n      }\n\n      var dataKey = el.getAttribute((\"data-\" + key));\n      if (dataKey) {\n        return dataKey;\n      }\n      return undefined;\n    }\n    return undefined;\n  }\n\n  // Set value\n  for (var i = 0; i < this.length; i += 1) {\n    el = this$1[i];\n    if (!el.dom7ElementDataStorage) { el.dom7ElementDataStorage = {}; }\n    el.dom7ElementDataStorage[key] = value;\n  }\n  return this;\n}\n// Transforms\n// eslint-disable-next-line\nfunction transform(transform) {\n  var this$1 = this;\n\n  for (var i = 0; i < this.length; i += 1) {\n    var elStyle = this$1[i].style;\n    elStyle.webkitTransform = transform;\n    elStyle.transform = transform;\n  }\n  return this;\n}\nfunction transition(duration) {\n  var this$1 = this;\n\n  if (typeof duration !== 'string') {\n    duration = duration + \"ms\"; // eslint-disable-line\n  }\n  for (var i = 0; i < this.length; i += 1) {\n    var elStyle = this$1[i].style;\n    elStyle.webkitTransitionDuration = duration;\n    elStyle.transitionDuration = duration;\n  }\n  return this;\n}\n// Events\nfunction on() {\n  var this$1 = this;\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n\n  var eventType = args[0];\n  var targetSelector = args[1];\n  var listener = args[2];\n  var capture = args[3];\n  if (typeof args[1] === 'function') {\n    var assign;\n    (assign = args, eventType = assign[0], listener = assign[1], capture = assign[2]);\n    targetSelector = undefined;\n  }\n  if (!capture) { capture = false; }\n\n  function handleLiveEvent(e) {\n    var target = e.target;\n    if (!target) { return; }\n    var eventData = e.target.dom7EventData || [];\n    eventData.unshift(e);\n    if ($$1(target).is(targetSelector)) { listener.apply(target, eventData); }\n    else {\n      var parents = $$1(target).parents(); // eslint-disable-line\n      for (var k = 0; k < parents.length; k += 1) {\n        if ($$1(parents[k]).is(targetSelector)) { listener.apply(parents[k], eventData); }\n      }\n    }\n  }\n  function handleEvent(e) {\n    var eventData = e && e.target ? e.target.dom7EventData || [] : [];\n    eventData.unshift(e);\n    listener.apply(this, eventData);\n  }\n  var events = eventType.split(' ');\n  var j;\n  for (var i = 0; i < this.length; i += 1) {\n    var el = this$1[i];\n    if (!targetSelector) {\n      for (j = 0; j < events.length; j += 1) {\n        if (!el.dom7Listeners) { el.dom7Listeners = []; }\n        el.dom7Listeners.push({\n          type: eventType,\n          listener: listener,\n          proxyListener: handleEvent,\n        });\n        el.addEventListener(events[j], handleEvent, capture);\n      }\n    } else {\n      // Live events\n      for (j = 0; j < events.length; j += 1) {\n        if (!el.dom7LiveListeners) { el.dom7LiveListeners = []; }\n        el.dom7LiveListeners.push({\n          type: eventType,\n          listener: listener,\n          proxyListener: handleLiveEvent,\n        });\n        el.addEventListener(events[j], handleLiveEvent, capture);\n      }\n    }\n  }\n  return this;\n}\nfunction off() {\n  var this$1 = this;\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n\n  var eventType = args[0];\n  var targetSelector = args[1];\n  var listener = args[2];\n  var capture = args[3];\n  if (typeof args[1] === 'function') {\n    var assign;\n    (assign = args, eventType = assign[0], listener = assign[1], capture = assign[2]);\n    targetSelector = undefined;\n  }\n  if (!capture) { capture = false; }\n\n  var events = eventType.split(' ');\n  for (var i = 0; i < events.length; i += 1) {\n    for (var j = 0; j < this.length; j += 1) {\n      var el = this$1[j];\n      if (!targetSelector) {\n        if (el.dom7Listeners) {\n          for (var k = 0; k < el.dom7Listeners.length; k += 1) {\n            if (listener) {\n              if (el.dom7Listeners[k].listener === listener) {\n                el.removeEventListener(events[i], el.dom7Listeners[k].proxyListener, capture);\n              }\n            } else if (el.dom7Listeners[k].type === events[i]) {\n              el.removeEventListener(events[i], el.dom7Listeners[k].proxyListener, capture);\n            }\n          }\n        }\n      } else if (el.dom7LiveListeners) {\n        for (var k$1 = 0; k$1 < el.dom7LiveListeners.length; k$1 += 1) {\n          if (listener) {\n            if (el.dom7LiveListeners[k$1].listener === listener) {\n              el.removeEventListener(events[i], el.dom7LiveListeners[k$1].proxyListener, capture);\n            }\n          } else if (el.dom7LiveListeners[k$1].type === events[i]) {\n            el.removeEventListener(events[i], el.dom7LiveListeners[k$1].proxyListener, capture);\n          }\n        }\n      }\n    }\n  }\n  return this;\n}\nfunction trigger() {\n  var this$1 = this;\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n\n  var events = args[0].split(' ');\n  var eventData = args[1];\n  for (var i = 0; i < events.length; i += 1) {\n    for (var j = 0; j < this.length; j += 1) {\n      var evt = (void 0);\n      try {\n        evt = new window.CustomEvent(events[i], {\n          detail: eventData,\n          bubbles: true,\n          cancelable: true,\n        });\n      } catch (e) {\n        evt = document.createEvent('Event');\n        evt.initEvent(events[i], true, true);\n        evt.detail = eventData;\n      }\n      // eslint-disable-next-line\n      this$1[j].dom7EventData = args.filter(function (data, dataIndex) { return dataIndex > 0; });\n      this$1[j].dispatchEvent(evt);\n      this$1[j].dom7EventData = [];\n      delete this$1[j].dom7EventData;\n    }\n  }\n  return this;\n}\nfunction transitionEnd(callback) {\n  var events = ['webkitTransitionEnd', 'transitionend'];\n  var dom = this;\n  var i;\n  function fireCallBack(e) {\n    /* jshint validthis:true */\n    if (e.target !== this) { return; }\n    callback.call(this, e);\n    for (i = 0; i < events.length; i += 1) {\n      dom.off(events[i], fireCallBack);\n    }\n  }\n  if (callback) {\n    for (i = 0; i < events.length; i += 1) {\n      dom.on(events[i], fireCallBack);\n    }\n  }\n  return this;\n}\nfunction outerWidth(includeMargins) {\n  if (this.length > 0) {\n    if (includeMargins) {\n      // eslint-disable-next-line\n      var styles = this.styles();\n      return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));\n    }\n    return this[0].offsetWidth;\n  }\n  return null;\n}\nfunction outerHeight(includeMargins) {\n  if (this.length > 0) {\n    if (includeMargins) {\n      // eslint-disable-next-line\n      var styles = this.styles();\n      return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));\n    }\n    return this[0].offsetHeight;\n  }\n  return null;\n}\nfunction offset() {\n  if (this.length > 0) {\n    var el = this[0];\n    var box = el.getBoundingClientRect();\n    var body = document.body;\n    var clientTop = el.clientTop || body.clientTop || 0;\n    var clientLeft = el.clientLeft || body.clientLeft || 0;\n    var scrollTop = el === window ? window.scrollY : el.scrollTop;\n    var scrollLeft = el === window ? window.scrollX : el.scrollLeft;\n    return {\n      top: (box.top + scrollTop) - clientTop,\n      left: (box.left + scrollLeft) - clientLeft,\n    };\n  }\n\n  return null;\n}\nfunction styles() {\n  if (this[0]) { return window.getComputedStyle(this[0], null); }\n  return {};\n}\nfunction css(props, value) {\n  var this$1 = this;\n\n  var i;\n  if (arguments.length === 1) {\n    if (typeof props === 'string') {\n      if (this[0]) { return window.getComputedStyle(this[0], null).getPropertyValue(props); }\n    } else {\n      for (i = 0; i < this.length; i += 1) {\n        // eslint-disable-next-line\n        for (var prop in props) {\n          this$1[i].style[prop] = props[prop];\n        }\n      }\n      return this;\n    }\n  }\n  if (arguments.length === 2 && typeof props === 'string') {\n    for (i = 0; i < this.length; i += 1) {\n      this$1[i].style[props] = value;\n    }\n    return this;\n  }\n  return this;\n}\n\n// Iterate over the collection passing elements to `callback`\nfunction each(callback) {\n  var this$1 = this;\n\n  // Don't bother continuing without a callback\n  if (!callback) { return this; }\n  // Iterate over the current collection\n  for (var i = 0; i < this.length; i += 1) {\n    // If the callback returns false\n    if (callback.call(this$1[i], i, this$1[i]) === false) {\n      // End the loop early\n      return this$1;\n    }\n  }\n  // Return `this` to allow chained DOM operations\n  return this;\n}\n// eslint-disable-next-line\nfunction html(html) {\n  var this$1 = this;\n\n  if (typeof html === 'undefined') {\n    return this[0] ? this[0].innerHTML : undefined;\n  }\n\n  for (var i = 0; i < this.length; i += 1) {\n    this$1[i].innerHTML = html;\n  }\n  return this;\n}\n// eslint-disable-next-line\nfunction text(text) {\n  var this$1 = this;\n\n  if (typeof text === 'undefined') {\n    if (this[0]) {\n      return this[0].textContent.trim();\n    }\n    return null;\n  }\n\n  for (var i = 0; i < this.length; i += 1) {\n    this$1[i].textContent = text;\n  }\n  return this;\n}\nfunction is(selector) {\n  var el = this[0];\n  var compareWith;\n  var i;\n  if (!el || typeof selector === 'undefined') { return false; }\n  if (typeof selector === 'string') {\n    if (el.matches) { return el.matches(selector); }\n    else if (el.webkitMatchesSelector) { return el.webkitMatchesSelector(selector); }\n    else if (el.msMatchesSelector) { return el.msMatchesSelector(selector); }\n\n    compareWith = $$1(selector);\n    for (i = 0; i < compareWith.length; i += 1) {\n      if (compareWith[i] === el) { return true; }\n    }\n    return false;\n  } else if (selector === document) { return el === document; }\n  else if (selector === window) { return el === window; }\n\n  if (selector.nodeType || selector instanceof Dom7) {\n    compareWith = selector.nodeType ? [selector] : selector;\n    for (i = 0; i < compareWith.length; i += 1) {\n      if (compareWith[i] === el) { return true; }\n    }\n    return false;\n  }\n  return false;\n}\nfunction index() {\n  var child = this[0];\n  var i;\n  if (child) {\n    i = 0;\n    // eslint-disable-next-line\n    while ((child = child.previousSibling) !== null) {\n      if (child.nodeType === 1) { i += 1; }\n    }\n    return i;\n  }\n  return undefined;\n}\n// eslint-disable-next-line\nfunction eq(index) {\n  if (typeof index === 'undefined') { return this; }\n  var length = this.length;\n  var returnIndex;\n  if (index > length - 1) {\n    return new Dom7([]);\n  }\n  if (index < 0) {\n    returnIndex = length + index;\n    if (returnIndex < 0) { return new Dom7([]); }\n    return new Dom7([this[returnIndex]]);\n  }\n  return new Dom7([this[index]]);\n}\nfunction append() {\n  var this$1 = this;\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n\n  var newChild;\n\n  for (var k = 0; k < args.length; k += 1) {\n    newChild = args[k];\n    for (var i = 0; i < this.length; i += 1) {\n      if (typeof newChild === 'string') {\n        var tempDiv = document.createElement('div');\n        tempDiv.innerHTML = newChild;\n        while (tempDiv.firstChild) {\n          this$1[i].appendChild(tempDiv.firstChild);\n        }\n      } else if (newChild instanceof Dom7) {\n        for (var j = 0; j < newChild.length; j += 1) {\n          this$1[i].appendChild(newChild[j]);\n        }\n      } else {\n        this$1[i].appendChild(newChild);\n      }\n    }\n  }\n\n  return this;\n}\n function prepend(newChild) {\n  var this$1 = this;\n\n  var i;\n  var j;\n  for (i = 0; i < this.length; i += 1) {\n    if (typeof newChild === 'string') {\n      var tempDiv = document.createElement('div');\n      tempDiv.innerHTML = newChild;\n      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {\n        this$1[i].insertBefore(tempDiv.childNodes[j], this$1[i].childNodes[0]);\n      }\n    } else if (newChild instanceof Dom7) {\n      for (j = 0; j < newChild.length; j += 1) {\n        this$1[i].insertBefore(newChild[j], this$1[i].childNodes[0]);\n      }\n    } else {\n      this$1[i].insertBefore(newChild, this$1[i].childNodes[0]);\n    }\n  }\n  return this;\n}\n function next(selector) {\n  if (this.length > 0) {\n    if (selector) {\n      if (this[0].nextElementSibling && $$1(this[0].nextElementSibling).is(selector)) {\n        return new Dom7([this[0].nextElementSibling]);\n      }\n      return new Dom7([]);\n    }\n\n    if (this[0].nextElementSibling) { return new Dom7([this[0].nextElementSibling]); }\n    return new Dom7([]);\n  }\n  return new Dom7([]);\n}\nfunction nextAll(selector) {\n  var nextEls = [];\n  var el = this[0];\n  if (!el) { return new Dom7([]); }\n  while (el.nextElementSibling) {\n    var next = el.nextElementSibling; // eslint-disable-line\n    if (selector) {\n      if ($$1(next).is(selector)) { nextEls.push(next); }\n    } else { nextEls.push(next); }\n    el = next;\n  }\n  return new Dom7(nextEls);\n}\nfunction prev(selector) {\n  if (this.length > 0) {\n    var el = this[0];\n    if (selector) {\n      if (el.previousElementSibling && $$1(el.previousElementSibling).is(selector)) {\n        return new Dom7([el.previousElementSibling]);\n      }\n      return new Dom7([]);\n    }\n\n    if (el.previousElementSibling) { return new Dom7([el.previousElementSibling]); }\n    return new Dom7([]);\n  }\n  return new Dom7([]);\n}\nfunction prevAll(selector) {\n  var prevEls = [];\n  var el = this[0];\n  if (!el) { return new Dom7([]); }\n  while (el.previousElementSibling) {\n    var prev = el.previousElementSibling; // eslint-disable-line\n    if (selector) {\n      if ($$1(prev).is(selector)) { prevEls.push(prev); }\n    } else { prevEls.push(prev); }\n    el = prev;\n  }\n  return new Dom7(prevEls);\n}\nfunction parent(selector) {\n  var this$1 = this;\n\n  var parents = []; // eslint-disable-line\n  for (var i = 0; i < this.length; i += 1) {\n    if (this$1[i].parentNode !== null) {\n      if (selector) {\n        if ($$1(this$1[i].parentNode).is(selector)) { parents.push(this$1[i].parentNode); }\n      } else {\n        parents.push(this$1[i].parentNode);\n      }\n    }\n  }\n  return $$1(unique(parents));\n}\nfunction parents(selector) {\n  var this$1 = this;\n\n  var parents = []; // eslint-disable-line\n  for (var i = 0; i < this.length; i += 1) {\n    var parent = this$1[i].parentNode; // eslint-disable-line\n    while (parent) {\n      if (selector) {\n        if ($$1(parent).is(selector)) { parents.push(parent); }\n      } else {\n        parents.push(parent);\n      }\n      parent = parent.parentNode;\n    }\n  }\n  return $$1(unique(parents));\n}\nfunction closest(selector) {\n  var closest = this; // eslint-disable-line\n  if (typeof selector === 'undefined') {\n    return new Dom7([]);\n  }\n  if (!closest.is(selector)) {\n    closest = closest.parents(selector).eq(0);\n  }\n  return closest;\n}\nfunction find(selector) {\n  var this$1 = this;\n\n  var foundElements = [];\n  for (var i = 0; i < this.length; i += 1) {\n    var found = this$1[i].querySelectorAll(selector);\n    for (var j = 0; j < found.length; j += 1) {\n      foundElements.push(found[j]);\n    }\n  }\n  return new Dom7(foundElements);\n}\nfunction children(selector) {\n  var this$1 = this;\n\n  var children = []; // eslint-disable-line\n  for (var i = 0; i < this.length; i += 1) {\n    var childNodes = this$1[i].childNodes;\n\n    for (var j = 0; j < childNodes.length; j += 1) {\n      if (!selector) {\n        if (childNodes[j].nodeType === 1) { children.push(childNodes[j]); }\n      } else if (childNodes[j].nodeType === 1 && $$1(childNodes[j]).is(selector)) {\n        children.push(childNodes[j]);\n      }\n    }\n  }\n  return new Dom7(unique(children));\n}\nfunction remove() {\n  var this$1 = this;\n\n  for (var i = 0; i < this.length; i += 1) {\n    if (this$1[i].parentNode) { this$1[i].parentNode.removeChild(this$1[i]); }\n  }\n  return this;\n}\nfunction add() {\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n\n  var dom = this;\n  var i;\n  var j;\n  for (i = 0; i < args.length; i += 1) {\n    var toAdd = $$1(args[i]);\n    for (j = 0; j < toAdd.length; j += 1) {\n      dom[dom.length] = toAdd[j];\n      dom.length += 1;\n    }\n  }\n  return dom;\n}\nvar noTrigger = ('resize scroll').split(' ');\n\nvar Methods = {\n  addClass: addClass,\n  removeClass: removeClass,\n  hasClass: hasClass,\n  toggleClass: toggleClass,\n  attr: attr,\n  removeAttr: removeAttr,\n  data: data,\n  transform: transform,\n  transition: transition,\n  on: on,\n  off: off,\n  trigger: trigger,\n  transitionEnd: transitionEnd,\n  outerWidth: outerWidth,\n  outerHeight: outerHeight,\n  offset: offset,\n  css: css,\n  each: each,\n  html: html,\n  text: text,\n  is: is,\n  index: index,\n  eq: eq,\n  append: append,\n  prepend: prepend,\n  next: next,\n  nextAll: nextAll,\n  prev: prev,\n  prevAll: prevAll,\n  parent: parent,\n  parents: parents,\n  closest: closest,\n  find: find,\n  children: children,\n  remove: remove,\n  add: add,\n  styles: styles,\n};\n\nObject.keys(Methods).forEach(function (methodName) {\n  $$1.fn[methodName] = Methods[methodName];\n});\n\nvar Utils = {\n  deleteProps: function deleteProps(obj) {\n    var object = obj;\n    Object.keys(object).forEach(function (key) {\n      try {\n        object[key] = null;\n      } catch (e) {\n        // no getter for object\n      }\n      try {\n        delete object[key];\n      } catch (e) {\n        // something got wrong\n      }\n    });\n  },\n  nextTick: function nextTick(callback, delay) {\n    if ( delay === void 0 ) delay = 0;\n\n    return setTimeout(callback, delay);\n  },\n  now: function now() {\n    return Date.now();\n  },\n  getTranslate: function getTranslate(el, axis) {\n    if ( axis === void 0 ) axis = 'x';\n\n    var matrix;\n    var curTransform;\n    var transformMatrix;\n\n    var curStyle = win.getComputedStyle(el, null);\n\n    if (win.WebKitCSSMatrix) {\n      curTransform = curStyle.transform || curStyle.webkitTransform;\n      if (curTransform.split(',').length > 6) {\n        curTransform = curTransform.split(', ').map(function (a) { return a.replace(',', '.'); }).join(', ');\n      }\n      // Some old versions of Webkit choke when 'none' is passed; pass\n      // empty string instead in this case\n      transformMatrix = new win.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n    } else {\n      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n      matrix = transformMatrix.toString().split(',');\n    }\n\n    if (axis === 'x') {\n      // Latest Chrome and webkits Fix\n      if (win.WebKitCSSMatrix) { curTransform = transformMatrix.m41; }\n      // Crazy IE10 Matrix\n      else if (matrix.length === 16) { curTransform = parseFloat(matrix[12]); }\n      // Normal Browsers\n      else { curTransform = parseFloat(matrix[4]); }\n    }\n    if (axis === 'y') {\n      // Latest Chrome and webkits Fix\n      if (win.WebKitCSSMatrix) { curTransform = transformMatrix.m42; }\n      // Crazy IE10 Matrix\n      else if (matrix.length === 16) { curTransform = parseFloat(matrix[13]); }\n      // Normal Browsers\n      else { curTransform = parseFloat(matrix[5]); }\n    }\n    return curTransform || 0;\n  },\n  parseUrlQuery: function parseUrlQuery(url) {\n    var query = {};\n    var urlToParse = url || win.location.href;\n    var i;\n    var params;\n    var param;\n    var length;\n    if (typeof urlToParse === 'string' && urlToParse.length) {\n      urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\\S*\\?/, '') : '';\n      params = urlToParse.split('&').filter(function (paramsPart) { return paramsPart !== ''; });\n      length = params.length;\n\n      for (i = 0; i < length; i += 1) {\n        param = params[i].replace(/#\\S+/g, '').split('=');\n        query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';\n      }\n    }\n    return query;\n  },\n  isObject: function isObject(o) {\n    return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;\n  },\n  extend: function extend() {\n    var args = [], len$1 = arguments.length;\n    while ( len$1-- ) args[ len$1 ] = arguments[ len$1 ];\n\n    var to = Object(args[0]);\n    for (var i = 1; i < args.length; i += 1) {\n      var nextSource = args[i];\n      if (nextSource !== undefined && nextSource !== null) {\n        var keysArray = Object.keys(Object(nextSource));\n        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n          var nextKey = keysArray[nextIndex];\n          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n          if (desc !== undefined && desc.enumerable) {\n            if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {\n              Utils.extend(to[nextKey], nextSource[nextKey]);\n            } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {\n              to[nextKey] = {};\n              Utils.extend(to[nextKey], nextSource[nextKey]);\n            } else {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n    }\n    return to;\n  },\n};\n\nvar d;\nif (typeof document === 'undefined') {\n  d = {\n    addEventListener: function addEventListener() {},\n    removeEventListener: function removeEventListener() {},\n    activeElement: {\n      blur: function blur() {},\n      nodeName: '',\n    },\n    querySelector: function querySelector() {\n      return {};\n    },\n    querySelectorAll: function querySelectorAll() {\n      return [];\n    },\n    createElement: function createElement() {\n      return {\n        style: {},\n        setAttribute: function setAttribute() {},\n        getElementsByTagName: function getElementsByTagName() {\n          return [];\n        },\n      };\n    },\n    location: { hash: '' },\n  };\n} else {\n  d = document;\n}\n\nvar doc = d;\n\nvar Support = (function Support() {\n  return {\n    touch: (win.Modernizr && win.Modernizr.touch === true) || (function checkTouch() {\n      return !!(('ontouchstart' in win) || (win.DocumentTouch && doc instanceof win.DocumentTouch));\n    }()),\n\n    transforms3d: (win.Modernizr && win.Modernizr.csstransforms3d === true) || (function checkTransforms3d() {\n      var div = doc.createElement('div').style;\n      return ('webkitPerspective' in div || 'MozPerspective' in div || 'OPerspective' in div || 'MsPerspective' in div || 'perspective' in div);\n    }()),\n\n    flexbox: (function checkFlexbox() {\n      var div = doc.createElement('div').style;\n      var styles = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');\n      for (var i = 0; i < styles.length; i += 1) {\n        if (styles[i] in div) { return true; }\n      }\n      return false;\n    }()),\n\n    observer: (function checkObserver() {\n      return ('MutationObserver' in win || 'WebkitMutationObserver' in win);\n    }()),\n\n    passiveListener: (function checkPassiveListener() {\n      var supportsPassive = false;\n      try {\n        var opts = Object.defineProperty({}, 'passive', {\n          get: function get() {\n            supportsPassive = true;\n          },\n        });\n        win.addEventListener('testPassiveListener', null, opts);\n      } catch (e) {\n        // No support\n      }\n      return supportsPassive;\n    }()),\n\n    gestures: (function checkGestures() {\n      return 'ongesturestart' in win;\n    }()),\n  };\n}());\n\nvar SwiperClass = function SwiperClass(params) {\n  if ( params === void 0 ) params = {};\n\n  var self = this;\n  self.params = params;\n\n  // Events\n  self.eventsListeners = {};\n\n  if (self.params && self.params.on) {\n    Object.keys(self.params.on).forEach(function (eventName) {\n      self.on(eventName, self.params.on[eventName]);\n    });\n  }\n};\n\nvar staticAccessors = { components: {} };\nSwiperClass.prototype.on = function on (events, handler) {\n  var self = this;\n  if (typeof handler !== 'function') { return self; }\n  events.split(' ').forEach(function (event) {\n    if (!self.eventsListeners[event]) { self.eventsListeners[event] = []; }\n    self.eventsListeners[event].push(handler);\n  });\n  return self;\n};\nSwiperClass.prototype.once = function once (events, handler) {\n  var self = this;\n  if (typeof handler !== 'function') { return self; }\n  function onceHandler() {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n    handler.apply(self, args);\n    self.off(events, onceHandler);\n  }\n  return self.on(events, onceHandler);\n};\nSwiperClass.prototype.off = function off (events, handler) {\n  var self = this;\n  events.split(' ').forEach(function (event) {\n    if (typeof handler === 'undefined') {\n      self.eventsListeners[event] = [];\n    } else {\n      self.eventsListeners[event].forEach(function (eventHandler, index) {\n        if (eventHandler === handler) {\n          self.eventsListeners[event].splice(index, 1);\n        }\n      });\n    }\n  });\n  return self;\n};\nSwiperClass.prototype.emit = function emit () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n  var self = this;\n  if (!self.eventsListeners) { return self; }\n  var events;\n  var data;\n  var context;\n  if (typeof args[0] === 'string' || Array.isArray(args[0])) {\n    events = args[0];\n    data = args.slice(1, args.length);\n    context = self;\n  } else {\n    events = args[0].events;\n    data = args[0].data;\n    context = args[0].context || self;\n  }\n  var eventsArray = Array.isArray(events) ? events : events.split(' ');\n  eventsArray.forEach(function (event) {\n    if (self.eventsListeners[event]) {\n      var handlers = [];\n      self.eventsListeners[event].forEach(function (eventHandler) {\n        handlers.push(eventHandler);\n      });\n      handlers.forEach(function (eventHandler) {\n        eventHandler.apply(context, data);\n      });\n    }\n  });\n  return self;\n};\nSwiperClass.prototype.useModulesParams = function useModulesParams (instanceParams) {\n  var instance = this;\n  if (!instance.modules) { return; }\n  Object.keys(instance.modules).forEach(function (moduleName) {\n    var module = instance.modules[moduleName];\n    // Extend params\n    if (module.params) {\n      Utils.extend(instanceParams, module.params);\n    }\n  });\n};\nSwiperClass.prototype.useModules = function useModules (modulesParams) {\n    if ( modulesParams === void 0 ) modulesParams = {};\n\n  var instance = this;\n  if (!instance.modules) { return; }\n  Object.keys(instance.modules).forEach(function (moduleName) {\n    var module = instance.modules[moduleName];\n    var moduleParams = modulesParams[moduleName] || {};\n    // Extend instance methods and props\n    if (module.instance) {\n      Object.keys(module.instance).forEach(function (modulePropName) {\n        var moduleProp = module.instance[modulePropName];\n        if (typeof moduleProp === 'function') {\n          instance[modulePropName] = moduleProp.bind(instance);\n        } else {\n          instance[modulePropName] = moduleProp;\n        }\n      });\n    }\n    // Add event listeners\n    if (module.on && instance.on) {\n      Object.keys(module.on).forEach(function (moduleEventName) {\n        instance.on(moduleEventName, module.on[moduleEventName]);\n      });\n    }\n\n    // Module create callback\n    if (module.create) {\n      module.create.bind(instance)(moduleParams);\n    }\n  });\n};\nstaticAccessors.components.set = function (components) {\n  var Class = this;\n  if (!Class.use) { return; }\n  Class.use(components);\n};\nSwiperClass.installModule = function installModule (module) {\n    var params = [], len = arguments.length - 1;\n    while ( len-- > 0 ) params[ len ] = arguments[ len + 1 ];\n\n  var Class = this;\n  if (!Class.prototype.modules) { Class.prototype.modules = {}; }\n  var name = module.name || (((Object.keys(Class.prototype.modules).length) + \"_\" + (Utils.now())));\n  Class.prototype.modules[name] = module;\n  // Prototype\n  if (module.proto) {\n    Object.keys(module.proto).forEach(function (key) {\n      Class.prototype[key] = module.proto[key];\n    });\n  }\n  // Class\n  if (module.static) {\n    Object.keys(module.static).forEach(function (key) {\n      Class[key] = module.static[key];\n    });\n  }\n  // Callback\n  if (module.install) {\n    module.install.apply(Class, params);\n  }\n  return Class;\n};\nSwiperClass.use = function use (module) {\n    var params = [], len = arguments.length - 1;\n    while ( len-- > 0 ) params[ len ] = arguments[ len + 1 ];\n\n  var Class = this;\n  if (Array.isArray(module)) {\n    module.forEach(function (m) { return Class.installModule(m); });\n    return Class;\n  }\n  return Class.installModule.apply(Class, [ module ].concat( params ));\n};\n\nObject.defineProperties( SwiperClass, staticAccessors );\n\nvar updateSize = function () {\n  var swiper = this;\n  var width;\n  var height;\n  var $el = swiper.$el;\n  if (typeof swiper.params.width !== 'undefined') {\n    width = swiper.params.width;\n  } else {\n    width = $el[0].clientWidth;\n  }\n  if (typeof swiper.params.height !== 'undefined') {\n    height = swiper.params.height;\n  } else {\n    height = $el[0].clientHeight;\n  }\n  if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {\n    return;\n  }\n\n  // Subtract paddings\n  width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);\n  height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);\n\n  Utils.extend(swiper, {\n    width: width,\n    height: height,\n    size: swiper.isHorizontal() ? width : height,\n  });\n};\n\nvar updateSlides = function () {\n  var swiper = this;\n  var params = swiper.params;\n\n  var $wrapperEl = swiper.$wrapperEl;\n  var swiperSize = swiper.size;\n  var rtl = swiper.rtl;\n  var wrongRTL = swiper.wrongRTL;\n  var slides = $wrapperEl.children((\".\" + (swiper.params.slideClass)));\n  var isVirtual = swiper.virtual && params.virtual.enabled;\n  var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n  var snapGrid = [];\n  var slidesGrid = [];\n  var slidesSizesGrid = [];\n\n  var offsetBefore = params.slidesOffsetBefore;\n  if (typeof offsetBefore === 'function') {\n    offsetBefore = params.slidesOffsetBefore.call(swiper);\n  }\n\n  var offsetAfter = params.slidesOffsetAfter;\n  if (typeof offsetAfter === 'function') {\n    offsetAfter = params.slidesOffsetAfter.call(swiper);\n  }\n\n  var previousSlidesLength = slidesLength;\n  var previousSnapGridLength = swiper.snapGrid.length;\n  var previousSlidesGridLength = swiper.snapGrid.length;\n\n  var spaceBetween = params.spaceBetween;\n  var slidePosition = -offsetBefore;\n  var prevSlideSize = 0;\n  var index = 0;\n  if (typeof swiperSize === 'undefined') {\n    return;\n  }\n  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n    spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;\n  }\n\n  swiper.virtualSize = -spaceBetween;\n\n  // reset margins\n  if (rtl) { slides.css({ marginLeft: '', marginTop: '' }); }\n  else { slides.css({ marginRight: '', marginBottom: '' }); }\n\n  var slidesNumberEvenToRows;\n  if (params.slidesPerColumn > 1) {\n    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {\n      slidesNumberEvenToRows = slidesLength;\n    } else {\n      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;\n    }\n    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {\n      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);\n    }\n  }\n\n  // Calc slides\n  var slideSize;\n  var slidesPerColumn = params.slidesPerColumn;\n  var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;\n  var numFullColumns = slidesPerRow - ((params.slidesPerColumn * slidesPerRow) - slidesLength);\n  for (var i = 0; i < slidesLength; i += 1) {\n    slideSize = 0;\n    var slide = slides.eq(i);\n    if (params.slidesPerColumn > 1) {\n      // Set slides order\n      var newSlideOrderIndex = (void 0);\n      var column = (void 0);\n      var row = (void 0);\n      if (params.slidesPerColumnFill === 'column') {\n        column = Math.floor(i / slidesPerColumn);\n        row = i - (column * slidesPerColumn);\n        if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {\n          row += 1;\n          if (row >= slidesPerColumn) {\n            row = 0;\n            column += 1;\n          }\n        }\n        newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);\n        slide\n          .css({\n            '-webkit-box-ordinal-group': newSlideOrderIndex,\n            '-moz-box-ordinal-group': newSlideOrderIndex,\n            '-ms-flex-order': newSlideOrderIndex,\n            '-webkit-order': newSlideOrderIndex,\n            order: newSlideOrderIndex,\n          });\n      } else {\n        row = Math.floor(i / slidesPerRow);\n        column = i - (row * slidesPerRow);\n      }\n      slide\n        .css(\n          (\"margin-\" + (swiper.isHorizontal() ? 'top' : 'left')),\n          (row !== 0 && params.spaceBetween) && (((params.spaceBetween) + \"px\"))\n        )\n        .attr('data-swiper-column', column)\n        .attr('data-swiper-row', row);\n    }\n    if (slide.css('display') === 'none') { continue; } // eslint-disable-line\n    if (params.slidesPerView === 'auto') {\n      slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);\n      if (params.roundLengths) { slideSize = Math.floor(slideSize); }\n    } else {\n      slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;\n      if (params.roundLengths) { slideSize = Math.floor(slideSize); }\n\n      if (slides[i]) {\n        if (swiper.isHorizontal()) {\n          slides[i].style.width = slideSize + \"px\";\n        } else {\n          slides[i].style.height = slideSize + \"px\";\n        }\n      }\n    }\n    if (slides[i]) {\n      slides[i].swiperSlideSize = slideSize;\n    }\n    slidesSizesGrid.push(slideSize);\n\n\n    if (params.centeredSlides) {\n      slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;\n      if (prevSlideSize === 0 && i !== 0) { slidePosition = slidePosition - (swiperSize / 2) - spaceBetween; }\n      if (i === 0) { slidePosition = slidePosition - (swiperSize / 2) - spaceBetween; }\n      if (Math.abs(slidePosition) < 1 / 1000) { slidePosition = 0; }\n      if ((index) % params.slidesPerGroup === 0) { snapGrid.push(slidePosition); }\n      slidesGrid.push(slidePosition);\n    } else {\n      if ((index) % params.slidesPerGroup === 0) { snapGrid.push(slidePosition); }\n      slidesGrid.push(slidePosition);\n      slidePosition = slidePosition + slideSize + spaceBetween;\n    }\n\n    swiper.virtualSize += slideSize + spaceBetween;\n\n    prevSlideSize = slideSize;\n\n    index += 1;\n  }\n  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n  var newSlidesGrid;\n\n  if (\n    rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n    $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + \"px\") });\n  }\n  if (!Support.flexbox || params.setWrapperSize) {\n    if (swiper.isHorizontal()) { $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + \"px\") }); }\n    else { $wrapperEl.css({ height: ((swiper.virtualSize + params.spaceBetween) + \"px\") }); }\n  }\n\n  if (params.slidesPerColumn > 1) {\n    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;\n    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;\n    if (swiper.isHorizontal()) { $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + \"px\") }); }\n    else { $wrapperEl.css({ height: ((swiper.virtualSize + params.spaceBetween) + \"px\") }); }\n    if (params.centeredSlides) {\n      newSlidesGrid = [];\n      for (var i$1 = 0; i$1 < snapGrid.length; i$1 += 1) {\n        if (snapGrid[i$1] < swiper.virtualSize + snapGrid[0]) { newSlidesGrid.push(snapGrid[i$1]); }\n      }\n      snapGrid = newSlidesGrid;\n    }\n  }\n\n  // Remove last grid elements depending on width\n  if (!params.centeredSlides) {\n    newSlidesGrid = [];\n    for (var i$2 = 0; i$2 < snapGrid.length; i$2 += 1) {\n      if (snapGrid[i$2] <= swiper.virtualSize - swiperSize) {\n        newSlidesGrid.push(snapGrid[i$2]);\n      }\n    }\n    snapGrid = newSlidesGrid;\n    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n      snapGrid.push(swiper.virtualSize - swiperSize);\n    }\n  }\n  if (snapGrid.length === 0) { snapGrid = [0]; }\n\n  if (params.spaceBetween !== 0) {\n    if (swiper.isHorizontal()) {\n      if (rtl) { slides.css({ marginLeft: (spaceBetween + \"px\") }); }\n      else { slides.css({ marginRight: (spaceBetween + \"px\") }); }\n    } else { slides.css({ marginBottom: (spaceBetween + \"px\") }); }\n  }\n\n  Utils.extend(swiper, {\n    slides: slides,\n    snapGrid: snapGrid,\n    slidesGrid: slidesGrid,\n    slidesSizesGrid: slidesSizesGrid,\n  });\n\n  if (slidesLength !== previousSlidesLength) {\n    swiper.emit('slidesLengthChange');\n  }\n  if (snapGrid.length !== previousSnapGridLength) {\n    swiper.emit('snapGridLengthChange');\n  }\n  if (slidesGrid.length !== previousSlidesGridLength) {\n    swiper.emit('slidesGridLengthChange');\n  }\n\n  if (params.watchSlidesProgress || params.watchSlidesVisibility) {\n    swiper.updateSlidesOffset();\n  }\n};\n\nvar updateAutoHeight = function () {\n  var swiper = this;\n  var activeSlides = [];\n  var newHeight = 0;\n  var i;\n\n  // Find slides currently in view\n  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\n    for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n      var index = swiper.activeIndex + i;\n      if (index > swiper.slides.length) { break; }\n      activeSlides.push(swiper.slides.eq(index)[0]);\n    }\n  } else {\n    activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);\n  }\n\n  // Find new height from highest slide in view\n  for (i = 0; i < activeSlides.length; i += 1) {\n    if (typeof activeSlides[i] !== 'undefined') {\n      var height = activeSlides[i].offsetHeight;\n      newHeight = height > newHeight ? height : newHeight;\n    }\n  }\n\n  // Update Height\n  if (newHeight) { swiper.$wrapperEl.css('height', (newHeight + \"px\")); }\n};\n\nvar updateSlidesOffset = function () {\n  var swiper = this;\n  var slides = swiper.slides;\n  for (var i = 0; i < slides.length; i += 1) {\n    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;\n  }\n};\n\nvar updateSlidesProgress = function (translate) {\n  if ( translate === void 0 ) translate = this.translate || 0;\n\n  var swiper = this;\n  var params = swiper.params;\n\n  var slides = swiper.slides;\n  var rtl = swiper.rtl;\n\n  if (slides.length === 0) { return; }\n  if (typeof slides[0].swiperSlideOffset === 'undefined') { swiper.updateSlidesOffset(); }\n\n  var offsetCenter = -translate;\n  if (rtl) { offsetCenter = translate; }\n\n  // Visible Slides\n  slides.removeClass(params.slideVisibleClass);\n\n  for (var i = 0; i < slides.length; i += 1) {\n    var slide = slides[i];\n    var slideProgress =\n      (\n        (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset\n      ) / (slide.swiperSlideSize + params.spaceBetween);\n    if (params.watchSlidesVisibility) {\n      var slideBefore = -(offsetCenter - slide.swiperSlideOffset);\n      var slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n      var isVisible =\n                (slideBefore >= 0 && slideBefore < swiper.size) ||\n                (slideAfter > 0 && slideAfter <= swiper.size) ||\n                (slideBefore <= 0 && slideAfter >= swiper.size);\n      if (isVisible) {\n        slides.eq(i).addClass(params.slideVisibleClass);\n      }\n    }\n    slide.progress = rtl ? -slideProgress : slideProgress;\n  }\n};\n\nvar updateProgress = function (translate) {\n  if ( translate === void 0 ) translate = this.translate || 0;\n\n  var swiper = this;\n  var params = swiper.params;\n\n  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  var progress = swiper.progress;\n  var isBeginning = swiper.isBeginning;\n  var isEnd = swiper.isEnd;\n  var wasBeginning = isBeginning;\n  var wasEnd = isEnd;\n  if (translatesDiff === 0) {\n    progress = 0;\n    isBeginning = true;\n    isEnd = true;\n  } else {\n    progress = (translate - swiper.minTranslate()) / (translatesDiff);\n    isBeginning = progress <= 0;\n    isEnd = progress >= 1;\n  }\n  Utils.extend(swiper, {\n    progress: progress,\n    isBeginning: isBeginning,\n    isEnd: isEnd,\n  });\n\n  if (params.watchSlidesProgress || params.watchSlidesVisibility) { swiper.updateSlidesProgress(translate); }\n\n  if (isBeginning && !wasBeginning) {\n    swiper.emit('reachBeginning toEdge');\n  }\n  if (isEnd && !wasEnd) {\n    swiper.emit('reachEnd toEdge');\n  }\n  if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {\n    swiper.emit('fromEdge');\n  }\n\n  swiper.emit('progress', progress);\n};\n\nvar updateSlidesClasses = function () {\n  var swiper = this;\n\n  var slides = swiper.slides;\n  var params = swiper.params;\n  var $wrapperEl = swiper.$wrapperEl;\n  var activeIndex = swiper.activeIndex;\n  var realIndex = swiper.realIndex;\n  var isVirtual = swiper.virtual && params.virtual.enabled;\n\n  slides.removeClass(((params.slideActiveClass) + \" \" + (params.slideNextClass) + \" \" + (params.slidePrevClass) + \" \" + (params.slideDuplicateActiveClass) + \" \" + (params.slideDuplicateNextClass) + \" \" + (params.slideDuplicatePrevClass)));\n\n  var activeSlide;\n  if (isVirtual) {\n    activeSlide = swiper.$wrapperEl.find((\".\" + (params.slideClass) + \"[data-swiper-slide-index=\\\"\" + activeIndex + \"\\\"]\"));\n  } else {\n    activeSlide = slides.eq(activeIndex);\n  }\n\n  // Active classes\n  activeSlide.addClass(params.slideActiveClass);\n\n  if (params.loop) {\n    // Duplicate to all looped slides\n    if (activeSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl\n        .children((\".\" + (params.slideClass) + \":not(.\" + (params.slideDuplicateClass) + \")[data-swiper-slide-index=\\\"\" + realIndex + \"\\\"]\"))\n        .addClass(params.slideDuplicateActiveClass);\n    } else {\n      $wrapperEl\n        .children((\".\" + (params.slideClass) + \".\" + (params.slideDuplicateClass) + \"[data-swiper-slide-index=\\\"\" + realIndex + \"\\\"]\"))\n        .addClass(params.slideDuplicateActiveClass);\n    }\n  }\n  // Next Slide\n  var nextSlide = activeSlide.nextAll((\".\" + (params.slideClass))).eq(0).addClass(params.slideNextClass);\n  if (params.loop && nextSlide.length === 0) {\n    nextSlide = slides.eq(0);\n    nextSlide.addClass(params.slideNextClass);\n  }\n  // Prev Slide\n  var prevSlide = activeSlide.prevAll((\".\" + (params.slideClass))).eq(0).addClass(params.slidePrevClass);\n  if (params.loop && prevSlide.length === 0) {\n    prevSlide = slides.eq(-1);\n    prevSlide.addClass(params.slidePrevClass);\n  }\n  if (params.loop) {\n    // Duplicate to all looped slides\n    if (nextSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl\n        .children((\".\" + (params.slideClass) + \":not(.\" + (params.slideDuplicateClass) + \")[data-swiper-slide-index=\\\"\" + (nextSlide.attr('data-swiper-slide-index')) + \"\\\"]\"))\n        .addClass(params.slideDuplicateNextClass);\n    } else {\n      $wrapperEl\n        .children((\".\" + (params.slideClass) + \".\" + (params.slideDuplicateClass) + \"[data-swiper-slide-index=\\\"\" + (nextSlide.attr('data-swiper-slide-index')) + \"\\\"]\"))\n        .addClass(params.slideDuplicateNextClass);\n    }\n    if (prevSlide.hasClass(params.slideDuplicateClass)) {\n      $wrapperEl\n        .children((\".\" + (params.slideClass) + \":not(.\" + (params.slideDuplicateClass) + \")[data-swiper-slide-index=\\\"\" + (prevSlide.attr('data-swiper-slide-index')) + \"\\\"]\"))\n        .addClass(params.slideDuplicatePrevClass);\n    } else {\n      $wrapperEl\n        .children((\".\" + (params.slideClass) + \".\" + (params.slideDuplicateClass) + \"[data-swiper-slide-index=\\\"\" + (prevSlide.attr('data-swiper-slide-index')) + \"\\\"]\"))\n        .addClass(params.slideDuplicatePrevClass);\n    }\n  }\n};\n\nvar updateActiveIndex = function (newActiveIndex) {\n  var swiper = this;\n  var translate = swiper.rtl ? swiper.translate : -swiper.translate;\n  var slidesGrid = swiper.slidesGrid;\n  var snapGrid = swiper.snapGrid;\n  var params = swiper.params;\n  var previousIndex = swiper.activeIndex;\n  var previousRealIndex = swiper.realIndex;\n  var previousSnapIndex = swiper.snapIndex;\n  var activeIndex = newActiveIndex;\n  var snapIndex;\n  if (typeof activeIndex === 'undefined') {\n    for (var i = 0; i < slidesGrid.length; i += 1) {\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {\n          activeIndex = i;\n        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n          activeIndex = i + 1;\n        }\n      } else if (translate >= slidesGrid[i]) {\n        activeIndex = i;\n      }\n    }\n    // Normalize slideIndex\n    if (params.normalizeSlideIndex) {\n      if (activeIndex < 0 || typeof activeIndex === 'undefined') { activeIndex = 0; }\n    }\n  }\n  if (snapGrid.indexOf(translate) >= 0) {\n    snapIndex = snapGrid.indexOf(translate);\n  } else {\n    snapIndex = Math.floor(activeIndex / params.slidesPerGroup);\n  }\n  if (snapIndex >= snapGrid.length) { snapIndex = snapGrid.length - 1; }\n  if (activeIndex === previousIndex) {\n    if (snapIndex !== previousSnapIndex) {\n      swiper.snapIndex = snapIndex;\n      swiper.emit('snapIndexChange');\n    }\n    return;\n  }\n\n  // Get real index\n  var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);\n\n  Utils.extend(swiper, {\n    snapIndex: snapIndex,\n    realIndex: realIndex,\n    previousIndex: previousIndex,\n    activeIndex: activeIndex,\n  });\n  swiper.emit('activeIndexChange');\n  swiper.emit('snapIndexChange');\n  if (previousRealIndex !== realIndex) {\n    swiper.emit('realIndexChange');\n  }\n  swiper.emit('slideChange');\n};\n\nvar updateClickedSlide = function (e) {\n  var swiper = this;\n  var params = swiper.params;\n  var slide = $$1(e.target).closest((\".\" + (params.slideClass)))[0];\n  var slideFound = false;\n  if (slide) {\n    for (var i = 0; i < swiper.slides.length; i += 1) {\n      if (swiper.slides[i] === slide) { slideFound = true; }\n    }\n  }\n\n  if (slide && slideFound) {\n    swiper.clickedSlide = slide;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.clickedIndex = parseInt($$1(slide).attr('data-swiper-slide-index'), 10);\n    } else {\n      swiper.clickedIndex = $$1(slide).index();\n    }\n  } else {\n    swiper.clickedSlide = undefined;\n    swiper.clickedIndex = undefined;\n    return;\n  }\n  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\n    swiper.slideToClickedSlide();\n  }\n};\n\nvar update = {\n  updateSize: updateSize,\n  updateSlides: updateSlides,\n  updateAutoHeight: updateAutoHeight,\n  updateSlidesOffset: updateSlidesOffset,\n  updateSlidesProgress: updateSlidesProgress,\n  updateProgress: updateProgress,\n  updateSlidesClasses: updateSlidesClasses,\n  updateActiveIndex: updateActiveIndex,\n  updateClickedSlide: updateClickedSlide,\n};\n\nvar getTranslate = function (axis) {\n  if ( axis === void 0 ) axis = this.isHorizontal() ? 'x' : 'y';\n\n  var swiper = this;\n\n  var params = swiper.params;\n  var rtl = swiper.rtl;\n  var translate = swiper.translate;\n  var $wrapperEl = swiper.$wrapperEl;\n\n  if (params.virtualTranslate) {\n    return rtl ? -translate : translate;\n  }\n\n  var currentTranslate = Utils.getTranslate($wrapperEl[0], axis);\n  if (rtl) { currentTranslate = -currentTranslate; }\n\n  return currentTranslate || 0;\n};\n\nvar setTranslate = function (translate, byController) {\n  var swiper = this;\n  var rtl = swiper.rtl;\n  var params = swiper.params;\n  var $wrapperEl = swiper.$wrapperEl;\n  var progress = swiper.progress;\n  var x = 0;\n  var y = 0;\n  var z = 0;\n\n  if (swiper.isHorizontal()) {\n    x = rtl ? -translate : translate;\n  } else {\n    y = translate;\n  }\n\n  if (params.roundLengths) {\n    x = Math.floor(x);\n    y = Math.floor(y);\n  }\n\n  if (!params.virtualTranslate) {\n    if (Support.transforms3d) { $wrapperEl.transform((\"translate3d(\" + x + \"px, \" + y + \"px, \" + z + \"px)\")); }\n    else { $wrapperEl.transform((\"translate(\" + x + \"px, \" + y + \"px)\")); }\n  }\n\n  swiper.translate = swiper.isHorizontal() ? x : y;\n\n  // Check if we need to update progress\n  var newProgress;\n  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (translate - swiper.minTranslate()) / (translatesDiff);\n  }\n  if (newProgress !== progress) {\n    swiper.updateProgress(translate);\n  }\n\n  swiper.emit('setTranslate', swiper.translate, byController);\n};\n\nvar minTranslate = function () {\n  return (-this.snapGrid[0]);\n};\n\nvar maxTranslate = function () {\n  return (-this.snapGrid[this.snapGrid.length - 1]);\n};\n\nvar translate = {\n  getTranslate: getTranslate,\n  setTranslate: setTranslate,\n  minTranslate: minTranslate,\n  maxTranslate: maxTranslate,\n};\n\nvar setTransition = function (duration, byController) {\n  var swiper = this;\n\n  swiper.$wrapperEl.transition(duration);\n\n  swiper.emit('setTransition', duration, byController);\n};\n\nvar transitionStart = function (runCallbacks) {\n  if ( runCallbacks === void 0 ) runCallbacks = true;\n\n  var swiper = this;\n  var activeIndex = swiper.activeIndex;\n  var params = swiper.params;\n  var previousIndex = swiper.previousIndex;\n  if (params.autoHeight) {\n    swiper.updateAutoHeight();\n  }\n  swiper.emit('transitionStart');\n\n  if (!runCallbacks) { return; }\n  if (activeIndex !== previousIndex) {\n    swiper.emit('slideChangeTransitionStart');\n    if (activeIndex > previousIndex) {\n      swiper.emit('slideNextTransitionStart');\n    } else {\n      swiper.emit('slidePrevTransitionStart');\n    }\n  }\n};\n\nvar transitionEnd$1 = function (runCallbacks) {\n  if ( runCallbacks === void 0 ) runCallbacks = true;\n\n  var swiper = this;\n  var activeIndex = swiper.activeIndex;\n  var previousIndex = swiper.previousIndex;\n  swiper.animating = false;\n  swiper.setTransition(0);\n\n  swiper.emit('transitionEnd');\n  if (runCallbacks) {\n    if (activeIndex !== previousIndex) {\n      swiper.emit('slideChangeTransitionEnd');\n      if (activeIndex > previousIndex) {\n        swiper.emit('slideNextTransitionEnd');\n      } else {\n        swiper.emit('slidePrevTransitionEnd');\n      }\n    }\n  }\n};\n\nvar transition$1 = {\n  setTransition: setTransition,\n  transitionStart: transitionStart,\n  transitionEnd: transitionEnd$1,\n};\n\nvar Browser = (function Browser() {\n  function isIE9() {\n    // create temporary DIV\n    var div = doc.createElement('div');\n    // add content to tmp DIV which is wrapped into the IE HTML conditional statement\n    div.innerHTML = '\x3c!--[if lte IE 9]><i></i><![endif]--\x3e';\n    // return true / false value based on what will browser render\n    return div.getElementsByTagName('i').length === 1;\n  }\n  function isSafari() {\n    var ua = win.navigator.userAgent.toLowerCase();\n    return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);\n  }\n  return {\n    isSafari: isSafari(),\n    isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(win.navigator.userAgent),\n    ie: win.navigator.pointerEnabled || win.navigator.msPointerEnabled,\n    ieTouch: (win.navigator.msPointerEnabled && win.navigator.msMaxTouchPoints > 1) ||\n             (win.navigator.pointerEnabled && win.navigator.maxTouchPoints > 1),\n    lteIE9: isIE9(),\n  };\n}());\n\nvar slideTo = function (index, speed, runCallbacks, internal) {\n  if ( index === void 0 ) index = 0;\n  if ( speed === void 0 ) speed = this.params.speed;\n  if ( runCallbacks === void 0 ) runCallbacks = true;\n\n  var swiper = this;\n  var slideIndex = index;\n  if (slideIndex < 0) { slideIndex = 0; }\n\n  var params = swiper.params;\n  var snapGrid = swiper.snapGrid;\n  var slidesGrid = swiper.slidesGrid;\n  var previousIndex = swiper.previousIndex;\n  var activeIndex = swiper.activeIndex;\n  var rtl = swiper.rtl;\n  var $wrapperEl = swiper.$wrapperEl;\n\n  var snapIndex = Math.floor(slideIndex / params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length) { snapIndex = snapGrid.length - 1; }\n\n  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {\n    swiper.emit('beforeSlideChangeStart');\n  }\n\n  var translate = -snapGrid[snapIndex];\n\n  // Update progress\n  swiper.updateProgress(translate);\n\n  // Normalize slideIndex\n  if (params.normalizeSlideIndex) {\n    for (var i = 0; i < slidesGrid.length; i += 1) {\n      if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {\n        slideIndex = i;\n      }\n    }\n  }\n\n  // Directions locks\n  if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {\n    return false;\n  }\n  if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n    if ((activeIndex || 0) !== slideIndex) { return false; }\n  }\n\n  // Update Index\n  if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {\n    swiper.updateActiveIndex(slideIndex);\n    // Update Height\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n    swiper.updateSlidesClasses();\n    if (params.effect !== 'slide') {\n      swiper.setTranslate(translate);\n    }\n    return false;\n  }\n\n  if (speed === 0 || Browser.lteIE9) {\n    swiper.setTransition(0);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit('beforeTransitionStart', speed, internal);\n    swiper.transitionStart(runCallbacks);\n    swiper.transitionEnd(runCallbacks);\n  } else {\n    swiper.setTransition(speed);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit('beforeTransitionStart', speed, internal);\n    swiper.transitionStart(runCallbacks);\n    if (!swiper.animating) {\n      swiper.animating = true;\n      $wrapperEl.transitionEnd(function () {\n        if (!swiper || swiper.destroyed) { return; }\n        swiper.transitionEnd(runCallbacks);\n      });\n    }\n  }\n\n  return true;\n};\n\n/* eslint no-unused-vars: \"off\" */\nvar slideNext = function (speed, runCallbacks, internal) {\n  if ( speed === void 0 ) speed = this.params.speed;\n  if ( runCallbacks === void 0 ) runCallbacks = true;\n\n  var swiper = this;\n  var params = swiper.params;\n  var animating = swiper.animating;\n  if (params.loop) {\n    if (animating) { return false; }\n    swiper.loopFix();\n    // eslint-disable-next-line\n    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n    return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);\n  }\n  return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);\n};\n\n/* eslint no-unused-vars: \"off\" */\nvar slidePrev = function (speed, runCallbacks, internal) {\n  if ( speed === void 0 ) speed = this.params.speed;\n  if ( runCallbacks === void 0 ) runCallbacks = true;\n\n  var swiper = this;\n  var params = swiper.params;\n  var animating = swiper.animating;\n\n  if (params.loop) {\n    if (animating) { return false; }\n    swiper.loopFix();\n    // eslint-disable-next-line\n    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n    return swiper.slideTo(swiper.activeIndex - 1, speed, runCallbacks, internal);\n  }\n  return swiper.slideTo(swiper.activeIndex - 1, speed, runCallbacks, internal);\n};\n\n/* eslint no-unused-vars: \"off\" */\nvar slideReset = function (speed, runCallbacks, internal) {\n  if ( speed === void 0 ) speed = this.params.speed;\n  if ( runCallbacks === void 0 ) runCallbacks = true;\n\n  var swiper = this;\n  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n};\n\nvar slideToClickedSlide = function () {\n  var swiper = this;\n  var params = swiper.params;\n  var $wrapperEl = swiper.$wrapperEl;\n\n  var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n  var slideToIndex = swiper.clickedIndex;\n  var realIndex;\n  if (params.loop) {\n    if (swiper.animating) { return; }\n    realIndex = parseInt($$1(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);\n    if (params.centeredSlides) {\n      if (\n        (slideToIndex < swiper.loopedSlides - (slidesPerView / 2)) ||\n        (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))\n      ) {\n        swiper.loopFix();\n        slideToIndex = $wrapperEl\n          .children((\".\" + (params.slideClass) + \"[data-swiper-slide-index=\\\"\" + realIndex + \"\\\"]:not(.\" + (params.slideDuplicateClass) + \")\"))\n          .eq(0)\n          .index();\n\n        Utils.nextTick(function () {\n          swiper.slideTo(slideToIndex);\n        });\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n      swiper.loopFix();\n      slideToIndex = $wrapperEl\n        .children((\".\" + (params.slideClass) + \"[data-swiper-slide-index=\\\"\" + realIndex + \"\\\"]:not(.\" + (params.slideDuplicateClass) + \")\"))\n        .eq(0)\n        .index();\n\n      Utils.nextTick(function () {\n        swiper.slideTo(slideToIndex);\n      });\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  } else {\n    swiper.slideTo(slideToIndex);\n  }\n};\n\nvar slide = {\n  slideTo: slideTo,\n  slideNext: slideNext,\n  slidePrev: slidePrev,\n  slideReset: slideReset,\n  slideToClickedSlide: slideToClickedSlide,\n};\n\nvar loopCreate = function () {\n  var swiper = this;\n  var params = swiper.params;\n  var $wrapperEl = swiper.$wrapperEl;\n  // Remove duplicated slides\n  $wrapperEl.children((\".\" + (params.slideClass) + \".\" + (params.slideDuplicateClass))).remove();\n\n  var slides = $wrapperEl.children((\".\" + (params.slideClass)));\n\n  if (params.loopFillGroupWithBlank) {\n    var blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);\n    if (blankSlidesNum !== params.slidesPerGroup) {\n      for (var i = 0; i < blankSlidesNum; i += 1) {\n        var blankNode = $$1(doc.createElement('div')).addClass(((params.slideClass) + \" \" + (params.slideBlankClass)));\n        $wrapperEl.append(blankNode);\n      }\n      slides = $wrapperEl.children((\".\" + (params.slideClass)));\n    }\n  }\n\n  if (params.slidesPerView === 'auto' && !params.loopedSlides) { params.loopedSlides = slides.length; }\n\n  swiper.loopedSlides = parseInt(params.loopedSlides || params.slidesPerView, 10);\n  swiper.loopedSlides += params.loopAdditionalSlides;\n  if (swiper.loopedSlides > slides.length) {\n    swiper.loopedSlides = slides.length;\n  }\n\n  var prependSlides = [];\n  var appendSlides = [];\n  slides.each(function (index, el) {\n    var slide = $$1(el);\n    if (index < swiper.loopedSlides) { appendSlides.push(el); }\n    if (index < slides.length && index >= slides.length - swiper.loopedSlides) { prependSlides.push(el); }\n    slide.attr('data-swiper-slide-index', index);\n  });\n  for (var i$1 = 0; i$1 < appendSlides.length; i$1 += 1) {\n    $wrapperEl.append($$1(appendSlides[i$1].cloneNode(true)).addClass(params.slideDuplicateClass));\n  }\n  for (var i$2 = prependSlides.length - 1; i$2 >= 0; i$2 -= 1) {\n    $wrapperEl.prepend($$1(prependSlides[i$2].cloneNode(true)).addClass(params.slideDuplicateClass));\n  }\n};\n\nvar loopFix = function () {\n  var swiper = this;\n  var params = swiper.params;\n  var activeIndex = swiper.activeIndex;\n  var slides = swiper.slides;\n  var loopedSlides = swiper.loopedSlides;\n  var allowSlidePrev = swiper.allowSlidePrev;\n  var allowSlideNext = swiper.allowSlideNext;\n  var newIndex;\n  swiper.allowSlidePrev = true;\n  swiper.allowSlideNext = true;\n  // Fix For Negative Oversliding\n  if (activeIndex < loopedSlides) {\n    newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;\n    newIndex += loopedSlides;\n    swiper.slideTo(newIndex, 0, false, true);\n  } else if ((params.slidesPerView === 'auto' && activeIndex >= loopedSlides * 2) || (activeIndex > slides.length - (params.slidesPerView * 2))) {\n    // Fix For Positive Oversliding\n    newIndex = -slides.length + activeIndex + loopedSlides;\n    newIndex += loopedSlides;\n    swiper.slideTo(newIndex, 0, false, true);\n  }\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n};\n\nvar loopDestroy = function () {\n  var swiper = this;\n  var $wrapperEl = swiper.$wrapperEl;\n  var params = swiper.params;\n  var slides = swiper.slides;\n  $wrapperEl.children((\".\" + (params.slideClass) + \".\" + (params.slideDuplicateClass))).remove();\n  slides.removeAttr('data-swiper-slide-index');\n};\n\nvar loop = {\n  loopCreate: loopCreate,\n  loopFix: loopFix,\n  loopDestroy: loopDestroy,\n};\n\nvar setGrabCursor = function (moving) {\n  var swiper = this;\n  if (Support.touch || !swiper.params.simulateTouch) { return; }\n  var el = swiper.el;\n  el.style.cursor = 'move';\n  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';\n  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';\n  el.style.cursor = moving ? 'grabbing' : 'grab';\n};\n\nvar unsetGrabCursor = function () {\n  var swiper = this;\n  if (Support.touch) { return; }\n  swiper.el.style.cursor = '';\n};\n\nvar grabCursor = {\n  setGrabCursor: setGrabCursor,\n  unsetGrabCursor: unsetGrabCursor,\n};\n\nvar appendSlide = function (slides) {\n  var swiper = this;\n  var $wrapperEl = swiper.$wrapperEl;\n  var params = swiper.params;\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (var i = 0; i < slides.length; i += 1) {\n      if (slides[i]) { $wrapperEl.append(slides[i]); }\n    }\n  } else {\n    $wrapperEl.append(slides);\n  }\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!(params.observer && Support.observer)) {\n    swiper.update();\n  }\n};\n\nvar prependSlide = function (slides) {\n  var swiper = this;\n  var params = swiper.params;\n  var $wrapperEl = swiper.$wrapperEl;\n  var activeIndex = swiper.activeIndex;\n\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n  var newActiveIndex = activeIndex + 1;\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (var i = 0; i < slides.length; i += 1) {\n      if (slides[i]) { $wrapperEl.prepend(slides[i]); }\n    }\n    newActiveIndex = activeIndex + slides.length;\n  } else {\n    $wrapperEl.prepend(slides);\n  }\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!(params.observer && Support.observer)) {\n    swiper.update();\n  }\n  swiper.slideTo(newActiveIndex, 0, false);\n};\n\nvar removeSlide = function (slidesIndexes) {\n  var swiper = this;\n  var params = swiper.params;\n  var $wrapperEl = swiper.$wrapperEl;\n  var activeIndex = swiper.activeIndex;\n\n  if (params.loop) {\n    swiper.loopDestroy();\n    swiper.slides = $wrapperEl.children((\".\" + (params.slideClass)));\n  }\n  var newActiveIndex = activeIndex;\n  var indexToRemove;\n\n  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {\n    for (var i = 0; i < slidesIndexes.length; i += 1) {\n      indexToRemove = slidesIndexes[i];\n      if (swiper.slides[indexToRemove]) { swiper.slides.eq(indexToRemove).remove(); }\n      if (indexToRemove < newActiveIndex) { newActiveIndex -= 1; }\n    }\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  } else {\n    indexToRemove = slidesIndexes;\n    if (swiper.slides[indexToRemove]) { swiper.slides.eq(indexToRemove).remove(); }\n    if (indexToRemove < newActiveIndex) { newActiveIndex -= 1; }\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  }\n\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n\n  if (!(params.observer && Support.observer)) {\n    swiper.update();\n  }\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n};\n\nvar removeAllSlides = function () {\n  var swiper = this;\n\n  var slidesIndexes = [];\n  for (var i = 0; i < swiper.slides.length; i += 1) {\n    slidesIndexes.push(i);\n  }\n  swiper.removeSlide(slidesIndexes);\n};\n\nvar manipulation = {\n  appendSlide: appendSlide,\n  prependSlide: prependSlide,\n  removeSlide: removeSlide,\n  removeAllSlides: removeAllSlides,\n};\n\nvar Device = (function Device() {\n  var ua = win.navigator.userAgent;\n\n  var device = {\n    ios: false,\n    android: false,\n    androidChrome: false,\n    desktop: false,\n    windows: false,\n    iphone: false,\n    ipod: false,\n    ipad: false,\n    cordova: win.cordova || win.phonegap,\n    phonegap: win.cordova || win.phonegap,\n  };\n\n  var windows = ua.match(/(Windows Phone);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n  var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n  var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  var iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n\n\n  // Windows\n  if (windows) {\n    device.os = 'windows';\n    device.osVersion = windows[2];\n    device.windows = true;\n  }\n  // Android\n  if (android && !windows) {\n    device.os = 'android';\n    device.osVersion = android[2];\n    device.android = true;\n    device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;\n  }\n  if (ipad || iphone || ipod) {\n    device.os = 'ios';\n    device.ios = true;\n  }\n  // iOS\n  if (iphone && !ipod) {\n    device.osVersion = iphone[2].replace(/_/g, '.');\n    device.iphone = true;\n  }\n  if (ipad) {\n    device.osVersion = ipad[2].replace(/_/g, '.');\n    device.ipad = true;\n  }\n  if (ipod) {\n    device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n    device.iphone = true;\n  }\n  // iOS 8+ changed UA\n  if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {\n    if (device.osVersion.split('.')[0] === '10') {\n      device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];\n    }\n  }\n\n  // Desktop\n  device.desktop = !(device.os || device.android || device.webView);\n\n  // Webview\n  device.webView = (iphone || ipad || ipod) && ua.match(/.*AppleWebKit(?!.*Safari)/i);\n\n  // Minimal UI\n  if (device.os && device.os === 'ios') {\n    var osVersionArr = device.osVersion.split('.');\n    var metaViewport = doc.querySelector('meta[name=\"viewport\"]');\n    device.minimalUi =\n      !device.webView &&\n      (ipod || iphone) &&\n      (osVersionArr[0] * 1 === 7 ? osVersionArr[1] * 1 >= 1 : osVersionArr[0] * 1 > 7) &&\n      metaViewport && metaViewport.getAttribute('content').indexOf('minimal-ui') >= 0;\n  }\n\n  // Pixel Ratio\n  device.pixelRatio = win.devicePixelRatio || 1;\n\n  // Export object\n  return device;\n}());\n\nvar onTouchStart = function (event) {\n  var swiper = this;\n  var data = swiper.touchEventsData;\n  var params = swiper.params;\n  var touches = swiper.touches;\n  var e = event;\n  if (e.originalEvent) { e = e.originalEvent; }\n  data.isTouchEvent = e.type === 'touchstart';\n  if (!data.isTouchEvent && 'which' in e && e.which === 3) { return; }\n  if (data.isTouched && data.isMoved) { return; }\n  if (params.noSwiping && $$1(e.target).closest((\".\" + (params.noSwipingClass)))[0]) {\n    swiper.allowClick = true;\n    return;\n  }\n  if (params.swipeHandler) {\n    if (!$$1(e).closest(params.swipeHandler)[0]) { return; }\n  }\n\n  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;\n  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;\n  var startX = touches.currentX;\n  var startY = touches.currentY;\n\n  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore\n\n  if (\n    Device.ios &&\n    !Device.cordova &&\n    params.iOSEdgeSwipeDetection &&\n    (startX <= params.iOSEdgeSwipeThreshold) &&\n    (startX >= window.screen.width - params.iOSEdgeSwipeThreshold)\n  ) {\n    return;\n  }\n\n  Utils.extend(data, {\n    isTouched: true,\n    isMoved: false,\n    allowTouchCallbacks: true,\n    isScrolling: undefined,\n    startMoving: undefined,\n  });\n\n  touches.startX = startX;\n  touches.startY = startY;\n  data.touchStartTime = Utils.now();\n  swiper.allowClick = true;\n  swiper.updateSize();\n  swiper.swipeDirection = undefined;\n  if (params.threshold > 0) { data.allowThresholdMove = false; }\n  if (e.type !== 'touchstart') {\n    var preventDefault = true;\n    if ($$1(e.target).is(data.formElements)) { preventDefault = false; }\n    if (doc.activeElement && $$1(doc.activeElement).is(data.formElements)) {\n      doc.activeElement.blur();\n    }\n    if (preventDefault && swiper.allowTouchMove) {\n      e.preventDefault();\n    }\n  }\n  swiper.emit('touchStart', e);\n};\n\nvar onTouchMove = function (event) {\n  var swiper = this;\n  var data = swiper.touchEventsData;\n  var params = swiper.params;\n  var touches = swiper.touches;\n  var rtl = swiper.rtl;\n  var e = event;\n  if (e.originalEvent) { e = e.originalEvent; }\n  if (data.isTouchEvent && e.type === 'mousemove') { return; }\n  var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;\n  var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;\n  if (e.preventedByNestedSwiper) {\n    touches.startX = pageX;\n    touches.startY = pageY;\n    return;\n  }\n  if (!swiper.allowTouchMove) {\n    // isMoved = true;\n    swiper.allowClick = false;\n    if (data.isTouched) {\n      Utils.extend(touches, {\n        startX: pageX,\n        startY: pageY,\n        currentX: pageX,\n        currentY: pageY,\n      });\n      data.touchStartTime = Utils.now();\n    }\n    return;\n  }\n  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {\n    if (swiper.isVertical()) {\n      // Vertical\n      if (\n        (pageY < touches.startY && swiper.translate <= swiper.maxTranslate()) ||\n        (pageY > touches.startY && swiper.translate >= swiper.minTranslate())\n      ) {\n        data.isTouched = false;\n        data.isMoved = false;\n        return;\n      }\n    } else if (\n      (pageX < touches.startX && swiper.translate <= swiper.maxTranslate()) ||\n      (pageX > touches.startX && swiper.translate >= swiper.minTranslate())\n    ) {\n      return;\n    }\n  }\n  if (data.isTouchEvent && doc.activeElement) {\n    if (e.target === doc.activeElement && $$1(e.target).is(data.formElements)) {\n      data.isMoved = true;\n      swiper.allowClick = false;\n      return;\n    }\n  }\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchMove', e);\n  }\n  if (e.targetTouches && e.targetTouches.length > 1) { return; }\n\n  touches.currentX = pageX;\n  touches.currentY = pageY;\n\n  var diffX = touches.currentX - touches.startX;\n  var diffY = touches.currentY - touches.startY;\n\n  if (typeof data.isScrolling === 'undefined') {\n    var touchAngle;\n    if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {\n      data.isScrolling = false;\n    } else {\n      // eslint-disable-next-line\n      if ((diffX * diffX) + (diffY * diffY) >= 25) {\n        touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;\n        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);\n      }\n    }\n  }\n  if (data.isScrolling) {\n    swiper.emit('touchMoveOpposite', e);\n  }\n  if (typeof startMoving === 'undefined') {\n    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n      data.startMoving = true;\n    }\n  }\n  if (!data.isTouched) { return; }\n  if (data.isScrolling) {\n    data.isTouched = false;\n    return;\n  }\n  if (!data.startMoving) {\n    return;\n  }\n  swiper.allowClick = false;\n  e.preventDefault();\n  if (params.touchMoveStopPropagation && !params.nested) {\n    e.stopPropagation();\n  }\n\n  if (!data.isMoved) {\n    if (params.loop) {\n      swiper.loopFix();\n    }\n    data.startTranslate = swiper.getTranslate();\n    swiper.setTransition(0);\n    if (swiper.animating) {\n      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');\n    }\n    data.allowMomentumBounce = false;\n    // Grab Cursor\n    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n      swiper.setGrabCursor(true);\n    }\n    swiper.emit('sliderFirstMove', e);\n  }\n  swiper.emit('sliderMove', e);\n  data.isMoved = true;\n\n  var diff = swiper.isHorizontal() ? diffX : diffY;\n  touches.diff = diff;\n\n  diff *= params.touchRatio;\n  if (rtl) { diff = -diff; }\n\n  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';\n  data.currentTranslate = diff + data.startTranslate;\n\n  var disableParentSwiper = true;\n  var resistanceRatio = params.resistanceRatio;\n  if (params.touchReleaseOnEdges) {\n    resistanceRatio = 0;\n  }\n  if ((diff > 0 && data.currentTranslate > swiper.minTranslate())) {\n    disableParentSwiper = false;\n    if (params.resistance) { data.currentTranslate = (swiper.minTranslate() - 1) + (Math.pow( (-swiper.minTranslate() + data.startTranslate + diff), resistanceRatio )); }\n  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {\n    disableParentSwiper = false;\n    if (params.resistance) { data.currentTranslate = (swiper.maxTranslate() + 1) - (Math.pow( (swiper.maxTranslate() - data.startTranslate - diff), resistanceRatio )); }\n  }\n\n  if (disableParentSwiper) {\n    e.preventedByNestedSwiper = true;\n  }\n\n  // Directions locks\n  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n\n\n  // Threshold\n  if (params.threshold > 0) {\n    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n      if (!data.allowThresholdMove) {\n        data.allowThresholdMove = true;\n        touches.startX = touches.currentX;\n        touches.startY = touches.currentY;\n        data.currentTranslate = data.startTranslate;\n        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n        return;\n      }\n    } else {\n      data.currentTranslate = data.startTranslate;\n      return;\n    }\n  }\n\n  if (!params.followFinger) { return; }\n\n  // Update active index in free mode\n  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  if (params.freeMode) {\n    // Velocity\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n        time: data.touchStartTime,\n      });\n    }\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n      time: Utils.now(),\n    });\n  }\n  // Update progress\n  swiper.updateProgress(data.currentTranslate);\n  // Update translate\n  swiper.setTranslate(data.currentTranslate);\n};\n\nvar onTouchEnd = function (event) {\n  var swiper = this;\n  var data = swiper.touchEventsData;\n\n  var params = swiper.params;\n  var touches = swiper.touches;\n  var rtl = swiper.rtl;\n  var $wrapperEl = swiper.$wrapperEl;\n  var slidesGrid = swiper.slidesGrid;\n  var snapGrid = swiper.snapGrid;\n  var e = event;\n  if (e.originalEvent) { e = e.originalEvent; }\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n  data.allowTouchCallbacks = false;\n  if (!data.isTouched) { return; }\n  // Return Grab Cursor\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  }\n\n  // Time diff\n  var touchEndTime = Utils.now();\n  var timeDiff = touchEndTime - data.touchStartTime;\n\n  // Tap, doubleTap, Click\n  if (swiper.allowClick) {\n    swiper.updateClickedSlide(e);\n    swiper.emit('tap', e);\n    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) > 300) {\n      if (data.clickTimeout) { clearTimeout(data.clickTimeout); }\n      data.clickTimeout = Utils.nextTick(function () {\n        if (!swiper || swiper.destroyed) { return; }\n        swiper.emit('click', e);\n      }, 300);\n    }\n    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {\n      if (data.clickTimeout) { clearTimeout(data.clickTimeout); }\n      swiper.emit('doubleTap', e);\n    }\n  }\n\n  data.lastClickTime = Utils.now();\n  Utils.nextTick(function () {\n    if (!swiper.destroyed) { swiper.allowClick = true; }\n  });\n\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n    data.isTouched = false;\n    data.isMoved = false;\n    return;\n  }\n  data.isTouched = false;\n  data.isMoved = false;\n\n  var currentPos;\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n  if (params.freeMode) {\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    } else if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n      return;\n    }\n\n    if (params.freeModeMomentum) {\n      if (data.velocities.length > 1) {\n        var lastMoveEvent = data.velocities.pop();\n        var velocityEvent = data.velocities.pop();\n\n        var distance = lastMoveEvent.position - velocityEvent.position;\n        var time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {\n          swiper.velocity = 0;\n        }\n        // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n        if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n      swiper.velocity *= params.freeModeMomentumVelocityRatio;\n\n      data.velocities.length = 0;\n      var momentumDuration = 1000 * params.freeModeMomentumRatio;\n      var momentumDistance = swiper.velocity * momentumDuration;\n\n      var newPosition = swiper.translate + momentumDistance;\n      if (rtl) { newPosition = -newPosition; }\n      var doBounce = false;\n      var afterBouncePosition;\n      var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n      } else if (params.freeModeSticky) {\n        var nextSlide;\n        for (var j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n        newPosition = -newPosition;\n      }\n      // Fix duration\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n      } else if (params.freeModeSticky) {\n        swiper.slideReset();\n        return;\n      }\n\n      if (params.freeModeMomentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart();\n        swiper.animating = true;\n        $wrapperEl.transitionEnd(function () {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) { return; }\n          swiper.emit('momentumBounce');\n\n          swiper.setTransition(params.speed);\n          swiper.setTranslate(afterBouncePosition);\n          $wrapperEl.transitionEnd(function () {\n            if (!swiper || swiper.destroyed) { return; }\n            swiper.transitionEnd();\n          });\n        });\n      } else if (swiper.velocity) {\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart();\n        if (!swiper.animating) {\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(function () {\n            if (!swiper || swiper.destroyed) { return; }\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    return;\n  }\n\n  // Find current slide\n  var stopIndex = 0;\n  var groupSize = swiper.slidesSizesGrid[0];\n  for (var i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {\n    if (typeof slidesGrid[i + params.slidesPerGroup] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  }\n\n  // Find current slide size\n  var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio) { swiper.slideTo(stopIndex + params.slidesPerGroup); }\n      else { swiper.slideTo(stopIndex); }\n    }\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > (1 - params.longSwipesRatio)) { swiper.slideTo(stopIndex + params.slidesPerGroup); }\n      else { swiper.slideTo(stopIndex); }\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (swiper.swipeDirection === 'next') {\n      swiper.slideTo(stopIndex + params.slidesPerGroup);\n    }\n    if (swiper.swipeDirection === 'prev') {\n      swiper.slideTo(stopIndex);\n    }\n  }\n};\n\nvar onResize = function () {\n  var swiper = this;\n\n  var params = swiper.params;\n  var el = swiper.el;\n\n  if (el && el.offsetWidth === 0) { return; }\n\n  // Breakpoints\n  if (params.breakpoints) {\n    swiper.setBreakpoint();\n  }\n\n  // Save locks\n  var allowSlideNext = swiper.allowSlideNext;\n  var allowSlidePrev = swiper.allowSlidePrev;\n\n  // Disable locks on resize\n  swiper.allowSlideNext = true;\n  swiper.allowSlidePrev = true;\n\n  swiper.updateSize();\n  swiper.updateSlides();\n\n  if (params.freeMode) {\n    var newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());\n    swiper.setTranslate(newTranslate);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n  } else {\n    swiper.updateSlidesClasses();\n    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {\n      swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n    } else {\n      swiper.slideTo(swiper.activeIndex, 0, false, true);\n    }\n  }\n  // Return locks after resize\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n};\n\nvar onClick = function (e) {\n  var swiper = this;\n  if (!swiper.allowClick) {\n    if (swiper.params.preventClicks) { e.preventDefault(); }\n    if (swiper.params.preventClicksPropagation && swiper.animating) {\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n};\n\nfunction attachEvents() {\n  var swiper = this;\n\n  var params = swiper.params;\n  var touchEvents = swiper.touchEvents;\n  var el = swiper.el;\n  var wrapperEl = swiper.wrapperEl;\n\n  {\n    swiper.onTouchStart = onTouchStart.bind(swiper);\n    swiper.onTouchMove = onTouchMove.bind(swiper);\n    swiper.onTouchEnd = onTouchEnd.bind(swiper);\n  }\n\n  swiper.onClick = onClick.bind(swiper);\n\n  var target = params.touchEventsTarget === 'container' ? el : wrapperEl;\n  var capture = !!params.nested;\n\n  // Touch Events\n  {\n    if (Browser.ie) {\n      target.addEventListener(touchEvents.start, swiper.onTouchStart, false);\n      (Support.touch ? target : doc).addEventListener(touchEvents.move, swiper.onTouchMove, capture);\n      (Support.touch ? target : doc).addEventListener(touchEvents.end, swiper.onTouchEnd, false);\n    } else {\n      if (Support.touch) {\n        var passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;\n        target.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);\n        target.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? { passive: false, capture: capture } : capture);\n        target.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);\n      }\n      if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {\n        target.addEventListener('mousedown', swiper.onTouchStart, false);\n        doc.addEventListener('mousemove', swiper.onTouchMove, capture);\n        doc.addEventListener('mouseup', swiper.onTouchEnd, false);\n      }\n    }\n    // Prevent Links Clicks\n    if (params.preventClicks || params.preventClicksPropagation) {\n      target.addEventListener('click', swiper.onClick, true);\n    }\n  }\n\n  // Resize handler\n  swiper.on('resize observerUpdate', onResize);\n}\n\nfunction detachEvents() {\n  var swiper = this;\n\n  var params = swiper.params;\n  var touchEvents = swiper.touchEvents;\n  var el = swiper.el;\n  var wrapperEl = swiper.wrapperEl;\n\n  var target = params.touchEventsTarget === 'container' ? el : wrapperEl;\n  var capture = !!params.nested;\n\n  // Touch Events\n  {\n    if (Browser.ie) {\n      target.removeEventListener(touchEvents.start, swiper.onTouchStart, false);\n      (Support.touch ? target : doc).removeEventListener(touchEvents.move, swiper.onTouchMove, capture);\n      (Support.touch ? target : doc).removeEventListener(touchEvents.end, swiper.onTouchEnd, false);\n    } else {\n      if (Support.touch) {\n        var passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;\n        target.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);\n        target.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);\n        target.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);\n      }\n      if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {\n        target.removeEventListener('mousedown', swiper.onTouchStart, false);\n        doc.removeEventListener('mousemove', swiper.onTouchMove, capture);\n        doc.removeEventListener('mouseup', swiper.onTouchEnd, false);\n      }\n    }\n    // Prevent Links Clicks\n    if (params.preventClicks || params.preventClicksPropagation) {\n      target.removeEventListener('click', swiper.onClick, true);\n    }\n  }\n\n  // Resize handler\n  swiper.off('resize observerUpdate', onResize);\n}\n\nvar events = {\n  attachEvents: attachEvents,\n  detachEvents: detachEvents,\n};\n\nvar setBreakpoint = function () {\n  var swiper = this;\n  var activeIndex = swiper.activeIndex;\n  var loopedSlides = swiper.loopedSlides; if ( loopedSlides === void 0 ) loopedSlides = 0;\n  var params = swiper.params;\n  var breakpoints = params.breakpoints;\n  if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) { return; }\n  // Set breakpoint for window width and update parameters\n  var breakpoint = swiper.getBreakpoint(breakpoints);\n  if (breakpoint && swiper.currentBreakpoint !== breakpoint) {\n    var breakPointsParams = breakpoint in breakpoints ? breakpoints[breakpoint] : swiper.originalParams;\n    var needsReLoop = params.loop && (breakPointsParams.slidesPerView !== params.slidesPerView);\n\n    Utils.extend(swiper.params, breakPointsParams);\n\n    Utils.extend(swiper, {\n      allowTouchMove: swiper.params.allowTouchMove,\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev,\n    });\n\n    swiper.currentBreakpoint = breakpoint;\n\n    if (needsReLoop) {\n      swiper.loopDestroy();\n      swiper.loopCreate();\n      swiper.updateSlides();\n      swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);\n    }\n    swiper.emit('breakpoint', breakPointsParams);\n  }\n};\n\nvar getBreakpoint = function (breakpoints) {\n  // Get breakpoint for window width\n  if (!breakpoints) { return undefined; }\n  var breakpoint = false;\n  var points = [];\n  Object.keys(breakpoints).forEach(function (point) {\n    points.push(point);\n  });\n  points.sort(function (a, b) { return parseInt(a, 10) - parseInt(b, 10); });\n  for (var i = 0; i < points.length; i += 1) {\n    var point = points[i];\n    if (point >= win.innerWidth && !breakpoint) {\n      breakpoint = point;\n    }\n  }\n  return breakpoint || 'max';\n};\n\nvar breakpoints = { setBreakpoint: setBreakpoint, getBreakpoint: getBreakpoint };\n\nvar addClasses = function () {\n  var swiper = this;\n  var classNames = swiper.classNames;\n  var params = swiper.params;\n  var rtl = swiper.rtl;\n  var $el = swiper.$el;\n  var suffixes = [];\n\n  suffixes.push(params.direction);\n\n  if (params.freeMode) {\n    suffixes.push('free-mode');\n  }\n  if (!Support.flexbox) {\n    suffixes.push('no-flexbox');\n  }\n  if (params.autoHeight) {\n    suffixes.push('autoheight');\n  }\n  if (rtl) {\n    suffixes.push('rtl');\n  }\n  if (params.slidesPerColumn > 1) {\n    suffixes.push('multirow');\n  }\n  if (Device.android) {\n    suffixes.push('android');\n  }\n  if (Device.ios) {\n    suffixes.push('ios');\n  }\n  // WP8 Touch Events Fix\n  if (win.navigator.pointerEnabled || win.navigator.msPointerEnabled) {\n    suffixes.push((\"wp8-\" + (params.direction)));\n  }\n\n  suffixes.forEach(function (suffix) {\n    classNames.push(params.containerModifierClass + suffix);\n  });\n\n  $el.addClass(classNames.join(' '));\n};\n\nvar removeClasses = function () {\n  var swiper = this;\n  var $el = swiper.$el;\n  var classNames = swiper.classNames;\n\n  $el.removeClass(classNames.join(' '));\n};\n\nvar classes = { addClasses: addClasses, removeClasses: removeClasses };\n\nvar loadImage = function (imageEl, src, srcset, sizes, checkForComplete, callback) {\n  var image;\n  function onReady() {\n    if (callback) { callback(); }\n  }\n  if (!imageEl.complete || !checkForComplete) {\n    if (src) {\n      image = new win.Image();\n      image.onload = onReady;\n      image.onerror = onReady;\n      if (sizes) {\n        image.sizes = sizes;\n      }\n      if (srcset) {\n        image.srcset = srcset;\n      }\n      if (src) {\n        image.src = src;\n      }\n    } else {\n      onReady();\n    }\n  } else {\n    // image already loaded...\n    onReady();\n  }\n};\n\nvar preloadImages = function () {\n  var swiper = this;\n  swiper.imagesToLoad = swiper.$el.find('img');\n  function onReady() {\n    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) { return; }\n    if (swiper.imagesLoaded !== undefined) { swiper.imagesLoaded += 1; }\n    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {\n      if (swiper.params.updateOnImagesReady) { swiper.update(); }\n      swiper.emit('imagesReady');\n    }\n  }\n  for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {\n    var imageEl = swiper.imagesToLoad[i];\n    swiper.loadImage(\n      imageEl,\n      imageEl.currentSrc || imageEl.getAttribute('src'),\n      imageEl.srcset || imageEl.getAttribute('srcset'),\n      imageEl.sizes || imageEl.getAttribute('sizes'),\n      true,\n      onReady\n    );\n  }\n};\n\nvar images = {\n  loadImage: loadImage,\n  preloadImages: preloadImages,\n};\n\nvar defaults = {\n  init: true,\n  direction: 'horizontal',\n  touchEventsTarget: 'container',\n  initialSlide: 0,\n  speed: 300,\n\n  // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).\n  iOSEdgeSwipeDetection: false,\n  iOSEdgeSwipeThreshold: 20,\n\n  // Free mode\n  freeMode: false,\n  freeModeMomentum: true,\n  freeModeMomentumRatio: 1,\n  freeModeMomentumBounce: true,\n  freeModeMomentumBounceRatio: 1,\n  freeModeMomentumVelocityRatio: 1,\n  freeModeSticky: false,\n  freeModeMinimumVelocity: 0.02,\n\n  // Autoheight\n  autoHeight: false,\n\n  // Set wrapper width\n  setWrapperSize: false,\n\n  // Virtual Translate\n  virtualTranslate: false,\n\n  // Effects\n  effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n\n  // Breakpoints\n  breakpoints: undefined,\n\n  // Slides grid\n  spaceBetween: 0,\n  slidesPerView: 1,\n  slidesPerColumn: 1,\n  slidesPerColumnFill: 'column',\n  slidesPerGroup: 1,\n  centeredSlides: false,\n  slidesOffsetBefore: 0, // in px\n  slidesOffsetAfter: 0, // in px\n  normalizeSlideIndex: true,\n\n  // Round length\n  roundLengths: false,\n\n  // Touches\n  touchRatio: 1,\n  touchAngle: 45,\n  simulateTouch: true,\n  shortSwipes: true,\n  longSwipes: true,\n  longSwipesRatio: 0.5,\n  longSwipesMs: 300,\n  followFinger: true,\n  allowTouchMove: true,\n  threshold: 0,\n  touchMoveStopPropagation: true,\n  touchReleaseOnEdges: false,\n\n  // Unique Navigation Elements\n  uniqueNavElements: true,\n\n  // Resistance\n  resistance: true,\n  resistanceRatio: 0.85,\n\n  // Progress\n  watchSlidesProgress: false,\n  watchSlidesVisibility: false,\n\n  // Cursor\n  grabCursor: false,\n\n  // Clicks\n  preventClicks: true,\n  preventClicksPropagation: true,\n  slideToClickedSlide: false,\n\n  // Images\n  preloadImages: true,\n  updateOnImagesReady: true,\n\n  // loop\n  loop: false,\n  loopAdditionalSlides: 0,\n  loopedSlides: null,\n  loopFillGroupWithBlank: false,\n\n  // Swiping/no swiping\n  allowSlidePrev: true,\n  allowSlideNext: true,\n  swipeHandler: null, // '.swipe-handler',\n  noSwiping: true,\n  noSwipingClass: 'swiper-no-swiping',\n\n  // Passive Listeners\n  passiveListeners: true,\n\n  // NS\n  containerModifierClass: 'swiper-container-', // NEW\n  slideClass: 'swiper-slide',\n  slideBlankClass: 'swiper-slide-invisible-blank',\n  slideActiveClass: 'swiper-slide-active',\n  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',\n  slideVisibleClass: 'swiper-slide-visible',\n  slideDuplicateClass: 'swiper-slide-duplicate',\n  slideNextClass: 'swiper-slide-next',\n  slideDuplicateNextClass: 'swiper-slide-duplicate-next',\n  slidePrevClass: 'swiper-slide-prev',\n  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',\n  wrapperClass: 'swiper-wrapper',\n\n  // Callbacks\n  runCallbacksOnInit: true,\n};\n\nvar prototypes = {\n  update: update,\n  translate: translate,\n  transition: transition$1,\n  slide: slide,\n  loop: loop,\n  grabCursor: grabCursor,\n  manipulation: manipulation,\n  events: events,\n  breakpoints: breakpoints,\n  classes: classes,\n  images: images,\n};\n\nvar extendedDefaults = {};\n\nvar Swiper$1 = (function (SwiperClass$$1) {\n  function Swiper() {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var el;\n    var params;\n    if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {\n      params = args[0];\n    } else {\n      var assign;\n      (assign = args, el = assign[0], params = assign[1]);\n    }\n    if (!params) { params = {}; }\n\n    params = Utils.extend({}, params);\n    if (el && !params.el) { params.el = el; }\n\n    SwiperClass$$1.call(this, params);\n\n    Object.keys(prototypes).forEach(function (prototypeGroup) {\n      Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {\n        if (!Swiper.prototype[protoMethod]) {\n          Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n        }\n      });\n    });\n\n    // Swiper Instance\n    var swiper = this;\n    if (typeof swiper.modules === 'undefined') {\n      swiper.modules = {};\n    }\n    Object.keys(swiper.modules).forEach(function (moduleName) {\n      var module = swiper.modules[moduleName];\n      if (module.params) {\n        var moduleParamName = Object.keys(module.params)[0];\n        var moduleParams = module.params[moduleParamName];\n        if (typeof moduleParams !== 'object') { return; }\n        if (!(moduleParamName in params && 'enabled' in moduleParams)) { return; }\n        if (params[moduleParamName] === true) {\n          params[moduleParamName] = { enabled: true };\n        }\n        if (\n          typeof params[moduleParamName] === 'object' &&\n          !('enabled' in params[moduleParamName])\n        ) {\n          params[moduleParamName].enabled = true;\n        }\n        if (!params[moduleParamName]) { params[moduleParamName] = { enabled: false }; }\n      }\n    });\n\n    // Extend defaults with modules params\n    var swiperParams = Utils.extend({}, defaults);\n    swiper.useModulesParams(swiperParams);\n\n    // Extend defaults with passed params\n    swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);\n    swiper.originalParams = Utils.extend({}, swiper.params);\n    swiper.passedParams = Utils.extend({}, params);\n\n    // Find el\n    var $el = $$1(swiper.params.el);\n    el = $el[0];\n\n    if (!el) {\n      return undefined;\n    }\n\n    if ($el.length > 1) {\n      var swipers = [];\n      $el.each(function (index, containerEl) {\n        var newParams = Utils.extend({}, params, { el: containerEl });\n        swipers.push(new Swiper(newParams));\n      });\n      return swipers;\n    }\n\n    el.swiper = swiper;\n    $el.data('swiper', swiper);\n\n    // Find Wrapper\n    var $wrapperEl = $el.children((\".\" + (swiper.params.wrapperClass)));\n\n    // Extend Swiper\n    Utils.extend(swiper, {\n      $el: $el,\n      el: el,\n      $wrapperEl: $wrapperEl,\n      wrapperEl: $wrapperEl[0],\n\n      // Classes\n      classNames: [],\n\n      // Slides\n      slides: $$1(),\n      slidesGrid: [],\n      snapGrid: [],\n      slidesSizesGrid: [],\n\n      // isDirection\n      isHorizontal: function isHorizontal() {\n        return swiper.params.direction === 'horizontal';\n      },\n      isVertical: function isVertical() {\n        return swiper.params.direction === 'vertical';\n      },\n      // RTL\n      rtl: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),\n      wrongRTL: $wrapperEl.css('display') === '-webkit-box',\n\n      // Indexes\n      activeIndex: 0,\n      realIndex: 0,\n\n      //\n      isBeginning: true,\n      isEnd: false,\n\n      // Props\n      translate: 0,\n      progress: 0,\n      velocity: 0,\n      animating: false,\n\n      // Locks\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev,\n\n      // Touch Events\n      touchEvents: (function touchEvents() {\n        var touch = ['touchstart', 'touchmove', 'touchend'];\n        var desktop = ['mousedown', 'mousemove', 'mouseup'];\n        if (win.navigator.pointerEnabled) {\n          desktop = ['pointerdown', 'pointermove', 'pointerup'];\n        } else if (win.navigator.msPointerEnabled) {\n          desktop = ['MSPointerDown', 'MsPointerMove', 'MsPointerUp'];\n        }\n\n        return {\n          start: Support.touch || !swiper.params.simulateTouch ? touch[0] : desktop[0],\n          move: Support.touch || !swiper.params.simulateTouch ? touch[1] : desktop[1],\n          end: Support.touch || !swiper.params.simulateTouch ? touch[2] : desktop[2],\n        };\n      }()),\n      touchEventsData: {\n        isTouched: undefined,\n        isMoved: undefined,\n        allowTouchCallbacks: undefined,\n        touchStartTime: undefined,\n        isScrolling: undefined,\n        currentTranslate: undefined,\n        startTranslate: undefined,\n        allowThresholdMove: undefined,\n        // Form elements to match\n        formElements: 'input, select, option, textarea, button, video',\n        // Last click time\n        lastClickTime: Utils.now(),\n        clickTimeout: undefined,\n        // Velocities\n        velocities: [],\n        allowMomentumBounce: undefined,\n        isTouchEvent: undefined,\n        startMoving: undefined,\n      },\n\n      // Clicks\n      allowClick: true,\n\n      // Touches\n      allowTouchMove: swiper.params.allowTouchMove,\n\n      touches: {\n        startX: 0,\n        startY: 0,\n        currentX: 0,\n        currentY: 0,\n        diff: 0,\n      },\n\n      // Images\n      imagesToLoad: [],\n      imagesLoaded: 0,\n\n    });\n\n    // Install Modules\n    swiper.useModules();\n\n    // Init\n    if (swiper.params.init) {\n      swiper.init();\n    }\n\n    // Return app instance\n    return swiper;\n  }\n\n  if ( SwiperClass$$1 ) Swiper.__proto__ = SwiperClass$$1;\n  Swiper.prototype = Object.create( SwiperClass$$1 && SwiperClass$$1.prototype );\n  Swiper.prototype.constructor = Swiper;\n\n  var staticAccessors = { extendedDefaults: {},defaults: {},Class: {},$: {} };\n  Swiper.prototype.slidesPerViewDynamic = function slidesPerViewDynamic () {\n    var swiper = this;\n    var params = swiper.params;\n    var slides = swiper.slides;\n    var slidesGrid = swiper.slidesGrid;\n    var swiperSize = swiper.size;\n    var activeIndex = swiper.activeIndex;\n    var spv = 1;\n    if (params.centeredSlides) {\n      var slideSize = slides[activeIndex].swiperSlideSize;\n      var breakLoop;\n      for (var i = activeIndex + 1; i < slides.length; i += 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize) { breakLoop = true; }\n        }\n      }\n      for (var i$1 = activeIndex - 1; i$1 >= 0; i$1 -= 1) {\n        if (slides[i$1] && !breakLoop) {\n          slideSize += slides[i$1].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize) { breakLoop = true; }\n        }\n      }\n    } else {\n      for (var i$2 = activeIndex + 1; i$2 < slides.length; i$2 += 1) {\n        if (slidesGrid[i$2] - slidesGrid[activeIndex] < swiperSize) {\n          spv += 1;\n        }\n      }\n    }\n    return spv;\n  };\n  Swiper.prototype.update = function update$$1 () {\n    var swiper = this;\n    if (!swiper || swiper.destroyed) { return; }\n    swiper.updateSize();\n    swiper.updateSlides();\n    swiper.updateProgress();\n    swiper.updateSlidesClasses();\n\n    var newTranslate;\n    function setTranslate() {\n      newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());\n      swiper.setTranslate(newTranslate);\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    var translated;\n    if (swiper.params.freeMode) {\n      setTranslate();\n      if (swiper.params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n    } else {\n      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {\n        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n      } else {\n        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n      }\n      if (!translated) {\n        setTranslate();\n      }\n    }\n    swiper.emit('update');\n  };\n  Swiper.prototype.init = function init () {\n    var swiper = this;\n    if (swiper.initialized) { return; }\n\n    swiper.emit('beforeInit');\n\n    // Set breakpoint\n    if (swiper.params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n\n    // Add Classes\n    swiper.addClasses();\n\n    // Create loop\n    if (swiper.params.loop) {\n      swiper.loopCreate();\n    }\n\n    // Update size\n    swiper.updateSize();\n\n    // Update slides\n    swiper.updateSlides();\n\n    // Set Grab Cursor\n    if (swiper.params.grabCursor) {\n      swiper.setGrabCursor();\n    }\n\n    if (swiper.params.preloadImages) {\n      swiper.preloadImages();\n    }\n\n    // Slide To Initial Slide\n    if (swiper.params.loop) {\n      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);\n    } else {\n      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);\n    }\n\n    // Attach events\n    swiper.attachEvents();\n\n    // Init Flag\n    swiper.initialized = true;\n\n    // Emit\n    swiper.emit('init');\n  };\n  Swiper.prototype.destroy = function destroy (deleteInstance, cleanStyles) {\n    if ( deleteInstance === void 0 ) deleteInstance = true;\n    if ( cleanStyles === void 0 ) cleanStyles = true;\n\n    var swiper = this;\n    var params = swiper.params;\n    var $el = swiper.$el;\n    var $wrapperEl = swiper.$wrapperEl;\n    var slides = swiper.slides;\n    swiper.emit('beforeDestroy');\n\n    // Init Flag\n    swiper.initialized = false;\n\n    // Detach events\n    swiper.detachEvents();\n\n    // Destroy loop\n    if (params.loop) {\n      swiper.loopDestroy();\n    }\n\n    // Cleanup styles\n    if (cleanStyles) {\n      swiper.removeClasses();\n      $el.removeAttr('style');\n      $wrapperEl.removeAttr('style');\n      if (slides && slides.length) {\n        slides\n          .removeClass([\n            params.slideVisibleClass,\n            params.slideActiveClass,\n            params.slideNextClass,\n            params.slidePrevClass ].join(' '))\n          .removeAttr('style')\n          .removeAttr('data-swiper-slide-index')\n          .removeAttr('data-swiper-column')\n          .removeAttr('data-swiper-row');\n      }\n    }\n\n    swiper.emit('destroy');\n\n    // Detach emitter events\n    Object.keys(swiper.eventsListeners).forEach(function (eventName) {\n      swiper.off(eventName);\n    });\n\n    if (deleteInstance !== false) {\n      swiper.$el[0].swiper = null;\n      swiper.$el.data('swiper', null);\n      Utils.deleteProps(swiper);\n    }\n    swiper.destroyed = true;\n  };\n  Swiper.extendDefaults = function extendDefaults (newDefaults) {\n    Utils.extend(extendedDefaults, newDefaults);\n  };\n  staticAccessors.extendedDefaults.get = function () {\n    return extendedDefaults;\n  };\n  staticAccessors.defaults.get = function () {\n    return defaults;\n  };\n  staticAccessors.Class.get = function () {\n    return SwiperClass$$1;\n  };\n  staticAccessors.$.get = function () {\n    return $$1;\n  };\n\n  Object.defineProperties( Swiper, staticAccessors );\n\n  return Swiper;\n}(SwiperClass));\n\nvar Device$2 = {\n  name: 'device',\n  proto: {\n    device: Device,\n  },\n  static: {\n    device: Device,\n  },\n};\n\nvar Support$2 = {\n  name: 'support',\n  proto: {\n    support: Support,\n  },\n  static: {\n    support: Support,\n  },\n};\n\nvar Browser$2 = {\n  name: 'browser',\n  proto: {\n    browser: Browser,\n  },\n  static: {\n    browser: Browser,\n  },\n};\n\nvar Resize = {\n  name: 'resize',\n  create: function create() {\n    var swiper = this;\n    Utils.extend(swiper, {\n      resize: {\n        resizeHandler: function resizeHandler() {\n          if (!swiper || swiper.destroyed || !swiper.initialized) { return; }\n          swiper.emit('beforeResize');\n          swiper.emit('resize');\n        },\n        orientationChangeHandler: function orientationChangeHandler() {\n          if (!swiper || swiper.destroyed || !swiper.initialized) { return; }\n          swiper.emit('orientationchange');\n        },\n      },\n    });\n  },\n  on: {\n    init: function init() {\n      var swiper = this;\n      // Emit resize\n      win.addEventListener('resize', swiper.resize.resizeHandler);\n\n      // Emit orientationchange\n      win.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);\n    },\n    destroy: function destroy() {\n      var swiper = this;\n      win.removeEventListener('resize', swiper.resize.resizeHandler);\n      win.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);\n    },\n  },\n};\n\nvar Observer = {\n  func: win.MutationObserver || win.WebkitMutationObserver,\n  attach: function attach(target, options) {\n    if ( options === void 0 ) options = {};\n\n    var swiper = this;\n\n    var ObserverFunc = Observer.func;\n    var observer = new ObserverFunc(function (mutations) {\n      mutations.forEach(function (mutation) {\n        swiper.emit('observerUpdate', mutation);\n      });\n    });\n\n    observer.observe(target, {\n      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,\n      childList: typeof options.childList === 'undefined' ? true : options.childList,\n      characterData: typeof options.characterData === 'undefined' ? true : options.characterData,\n    });\n\n    swiper.observer.observers.push(observer);\n  },\n  init: function init() {\n    var swiper = this;\n    if (!Support.observer || !swiper.params.observer) { return; }\n    if (swiper.params.observeParents) {\n      var containerParents = swiper.$el.parents();\n      for (var i = 0; i < containerParents.length; i += 1) {\n        swiper.observer.attach(containerParents[i]);\n      }\n    }\n    // Observe container\n    swiper.observer.attach(swiper.$el[0], { childList: false });\n\n    // Observe wrapper\n    swiper.observer.attach(swiper.$wrapperEl[0], { attributes: false });\n  },\n  destroy: function destroy() {\n    var swiper = this;\n    swiper.observer.observers.forEach(function (observer) {\n      observer.disconnect();\n    });\n    swiper.observer.observers = [];\n  },\n};\n\nvar Observer$1 = {\n  name: 'observer',\n  params: {\n    observer: false,\n    observeParents: false,\n  },\n  create: function create() {\n    var swiper = this;\n    Utils.extend(swiper, {\n      observer: {\n        init: Observer.init.bind(swiper),\n        attach: Observer.attach.bind(swiper),\n        destroy: Observer.destroy.bind(swiper),\n        observers: [],\n      },\n    });\n  },\n  on: {\n    init: function init() {\n      var swiper = this;\n      swiper.observer.init();\n    },\n    destroy: function destroy() {\n      var swiper = this;\n      swiper.observer.destroy();\n    },\n  },\n};\n\nvar Virtual = {\n  update: function update(force) {\n    var swiper = this;\n    var ref = swiper.params;\n    var slidesPerView = ref.slidesPerView;\n    var slidesPerGroup = ref.slidesPerGroup;\n    var centeredSlides = ref.centeredSlides;\n    var ref$1 = swiper.virtual;\n    var previousFrom = ref$1.from;\n    var previousTo = ref$1.to;\n    var slides = ref$1.slides;\n    var previousSlidesGrid = ref$1.slidesGrid;\n    var renderSlide = ref$1.renderSlide;\n    var previousOffset = ref$1.offset;\n    swiper.updateActiveIndex();\n    var activeIndex = swiper.activeIndex || 0;\n\n    var offsetProp;\n    if (swiper.rtl && swiper.isHorizontal()) { offsetProp = 'right'; }\n    else { offsetProp = swiper.isHorizontal() ? 'left' : 'top'; }\n\n    var slidesAfter;\n    var slidesBefore;\n    if (centeredSlides) {\n      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup;\n      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup;\n    } else {\n      slidesAfter = slidesPerView + (slidesPerGroup - 1);\n      slidesBefore = slidesPerGroup;\n    }\n    var from = Math.max((activeIndex || 0) - slidesBefore, 0);\n    var to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);\n    var offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n\n    Utils.extend(swiper.virtual, {\n      from: from,\n      to: to,\n      offset: offset,\n      slidesGrid: swiper.slidesGrid,\n    });\n\n    function onRendered() {\n      swiper.updateSlides();\n      swiper.updateProgress();\n      swiper.updateSlidesClasses();\n      if (swiper.lazy && swiper.params.lazy.enabled) {\n        swiper.lazy.load();\n      }\n    }\n\n    if (previousFrom === from && previousTo === to && !force) {\n      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\n        swiper.slides.css(offsetProp, (offset + \"px\"));\n      }\n      swiper.updateProgress();\n      return;\n    }\n    if (swiper.params.virtual.renderExternal) {\n      swiper.params.virtual.renderExternal.call(swiper, {\n        offset: offset,\n        from: from,\n        to: to,\n        slides: (function getSlides() {\n          var slidesToRender = [];\n          for (var i = from; i <= to; i += 1) {\n            slidesToRender.push(slides[i]);\n          }\n          return slidesToRender;\n        }()),\n      });\n      onRendered();\n      return;\n    }\n    var prependIndexes = [];\n    var appendIndexes = [];\n    if (force) {\n      swiper.$wrapperEl.find((\".\" + (swiper.params.slideClass))).remove();\n    } else {\n      for (var i = previousFrom; i <= previousTo; i += 1) {\n        if (i < from || i > to) {\n          swiper.$wrapperEl.find((\".\" + (swiper.params.slideClass) + \"[data-swiper-slide-index=\\\"\" + i + \"\\\"]\")).remove();\n        }\n      }\n    }\n    for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {\n      if (i$1 >= from && i$1 <= to) {\n        if (typeof previousTo === 'undefined' || force) {\n          appendIndexes.push(i$1);\n        } else {\n          if (i$1 > previousTo) { appendIndexes.push(i$1); }\n          if (i$1 < previousFrom) { prependIndexes.push(i$1); }\n        }\n      }\n    }\n    appendIndexes.forEach(function (index) {\n      swiper.$wrapperEl.append(renderSlide(slides[index], index));\n    });\n    prependIndexes.sort(function (a, b) { return a < b; }).forEach(function (index) {\n      swiper.$wrapperEl.prepend(renderSlide(slides[index], index));\n    });\n    swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, (offset + \"px\"));\n    onRendered();\n  },\n  renderSlide: function renderSlide(slide, index) {\n    var swiper = this;\n    var params = swiper.params.virtual;\n    if (params.cache && swiper.virtual.cache[index]) {\n      return swiper.virtual.cache[index];\n    }\n    var $slideEl = params.renderSlide\n      ? $$1(params.renderSlide.call(swiper, slide, index))\n      : $$1((\"<div class=\\\"\" + (swiper.params.slideClass) + \"\\\" data-swiper-slide-index=\\\"\" + index + \"\\\">\" + slide + \"</div>\"));\n    if (!$slideEl.attr('data-swiper-slide-index')) { $slideEl.attr('data-swiper-slide-index', index); }\n    if (params.cache) { swiper.virtual.cache[index] = $slideEl; }\n    return $slideEl;\n  },\n  appendSlide: function appendSlide(slide) {\n    var swiper = this;\n    swiper.virtual.slides.push(slide);\n    swiper.virtual.update(true);\n  },\n  prependSlide: function prependSlide(slide) {\n    var swiper = this;\n    swiper.virtual.slides.unshift(slide);\n    if (swiper.params.virtual.cache) {\n      var cache = swiper.virtual.cache;\n      var newCache = {};\n      Object.keys(cache).forEach(function (cachedIndex) {\n        newCache[cachedIndex + 1] = cache[cachedIndex];\n      });\n      swiper.virtual.cache = newCache;\n    }\n    swiper.virtual.update(true);\n    swiper.slideNext(0);\n  },\n};\n\nvar Virtual$1 = {\n  name: 'virtual',\n  params: {\n    virtual: {\n      enabled: false,\n      slides: [],\n      cache: true,\n      renderSlide: null,\n      renderExternal: null,\n    },\n  },\n  create: function create() {\n    var swiper = this;\n    Utils.extend(swiper, {\n      virtual: {\n        update: Virtual.update.bind(swiper),\n        appendSlide: Virtual.appendSlide.bind(swiper),\n        prependSlide: Virtual.prependSlide.bind(swiper),\n        renderSlide: Virtual.renderSlide.bind(swiper),\n        slides: swiper.params.virtual.slides,\n        cache: {},\n      },\n    });\n  },\n  on: {\n    beforeInit: function beforeInit() {\n      var swiper = this;\n      if (!swiper.params.virtual.enabled) { return; }\n      swiper.classNames.push(((swiper.params.containerModifierClass) + \"virtual\"));\n      var overwriteParams = {\n        watchSlidesProgress: true,\n      };\n      Utils.extend(swiper.params, overwriteParams);\n      Utils.extend(swiper.originalParams, overwriteParams);\n\n      swiper.virtual.update();\n    },\n    setTranslate: function setTranslate() {\n      var swiper = this;\n      if (!swiper.params.virtual.enabled) { return; }\n      swiper.virtual.update();\n    },\n  },\n};\n\nvar Keyboard = {\n  handle: function handle(event) {\n    var swiper = this;\n    var e = event;\n    if (e.originalEvent) { e = e.originalEvent; } // jquery fix\n    var kc = e.keyCode || e.charCode;\n    // Directions locks\n    if (!swiper.allowSlideNext && ((swiper.isHorizontal() && kc === 39) || (swiper.isVertical() && kc === 40))) {\n      return false;\n    }\n    if (!swiper.allowSlidePrev && ((swiper.isHorizontal() && kc === 37) || (swiper.isVertical() && kc === 38))) {\n      return false;\n    }\n    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n      return undefined;\n    }\n    if (doc.activeElement && doc.activeElement.nodeName && (doc.activeElement.nodeName.toLowerCase() === 'input' || doc.activeElement.nodeName.toLowerCase() === 'textarea')) {\n      return undefined;\n    }\n    if (kc === 37 || kc === 39 || kc === 38 || kc === 40) {\n      var inView = false;\n      // Check that swiper should be inside of visible area of window\n      if (swiper.$el.parents((\".\" + (swiper.params.slideClass))).length > 0 && swiper.$el.parents((\".\" + (swiper.params.slideActiveClass))).length === 0) {\n        return undefined;\n      }\n      var windowScroll = {\n        left: win.pageXOffset,\n        top: win.pageYOffset,\n      };\n      var windowWidth = win.innerWidth;\n      var windowHeight = win.innerHeight;\n      var swiperOffset = swiper.$el.offset();\n      if (swiper.rtl) { swiperOffset.left -= swiper.$el[0].scrollLeft; }\n      var swiperCoord = [\n        [swiperOffset.left, swiperOffset.top],\n        [swiperOffset.left + swiper.width, swiperOffset.top],\n        [swiperOffset.left, swiperOffset.top + swiper.height],\n        [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height] ];\n      for (var i = 0; i < swiperCoord.length; i += 1) {\n        var point = swiperCoord[i];\n        if (\n          point[0] >= windowScroll.left && point[0] <= windowScroll.left + windowWidth &&\n            point[1] >= windowScroll.top && point[1] <= windowScroll.top + windowHeight\n        ) {\n          inView = true;\n        }\n      }\n      if (!inView) { return undefined; }\n    }\n    if (swiper.isHorizontal()) {\n      if (kc === 37 || kc === 39) {\n        if (e.preventDefault) { e.preventDefault(); }\n        else { e.returnValue = false; }\n      }\n      if ((kc === 39 && !swiper.rtl) || (kc === 37 && swiper.rtl)) { swiper.slideNext(); }\n      if ((kc === 37 && !swiper.rtl) || (kc === 39 && swiper.rtl)) { swiper.slidePrev(); }\n    } else {\n      if (kc === 38 || kc === 40) {\n        if (e.preventDefault) { e.preventDefault(); }\n        else { e.returnValue = false; }\n      }\n      if (kc === 40) { swiper.slideNext(); }\n      if (kc === 38) { swiper.slidePrev(); }\n    }\n    swiper.emit('keyPress', kc);\n    return undefined;\n  },\n  enable: function enable() {\n    var swiper = this;\n    if (swiper.keyboard.enabled) { return; }\n    $$1(doc).on('keydown', swiper.keyboard.handle);\n    swiper.keyboard.enabled = true;\n  },\n  disable: function disable() {\n    var swiper = this;\n    if (!swiper.keyboard.enabled) { return; }\n    $$1(doc).off('keydown', swiper.keyboard.handle);\n    swiper.keyboard.enabled = false;\n  },\n};\n\nvar Keyboard$1 = {\n  name: 'keyboard',\n  params: {\n    keyboard: {\n      enabled: false,\n    },\n  },\n  create: function create() {\n    var swiper = this;\n    Utils.extend(swiper, {\n      keyboard: {\n        enabled: false,\n        enable: Keyboard.enable.bind(swiper),\n        disable: Keyboard.disable.bind(swiper),\n        handle: Keyboard.handle.bind(swiper),\n      },\n    });\n  },\n  on: {\n    init: function init() {\n      var swiper = this;\n      if (swiper.params.keyboard.enabled) {\n        swiper.keyboard.enable();\n      }\n    },\n    destroy: function destroy() {\n      var swiper = this;\n      if (swiper.keyboard.enabled) {\n        swiper.keyboard.disable();\n      }\n    },\n  },\n};\n\nfunction isEventSupported() {\n  var eventName = 'onwheel';\n  var isSupported = eventName in doc;\n\n  if (!isSupported) {\n    var element = doc.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported &&\n    doc.implementation &&\n    doc.implementation.hasFeature &&\n    // always returns true in newer browsers as per the standard.\n    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n    doc.implementation.hasFeature('', '') !== true\n  ) {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = doc.implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\nvar Mousewheel = {\n  lastScrollTime: Utils.now(),\n  event: (function getEvent() {\n    if (win.navigator.userAgent.indexOf('firefox') > -1) { return 'DOMMouseScroll'; }\n    return isEventSupported() ? 'wheel' : 'mousewheel';\n  }()),\n  normalize: function normalize(e) {\n    // Reasonable defaults\n    var PIXEL_STEP = 10;\n    var LINE_HEIGHT = 40;\n    var PAGE_HEIGHT = 800;\n\n    var sX = 0;\n    var sY = 0; // spinX, spinY\n    var pX = 0;\n    var pY = 0; // pixelX, pixelY\n\n    // Legacy\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    }\n\n    // side scrolling on FF with DOMMouseScroll\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) { // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else { // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    }\n\n    // Fall-back if spin cannot be determined\n    if (pX && !sX) {\n      sX = (pX < 1) ? -1 : 1;\n    }\n    if (pY && !sY) {\n      sY = (pY < 1) ? -1 : 1;\n    }\n\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY,\n    };\n  },\n  handle: function handle(event) {\n    var e = event;\n    var swiper = this;\n    var params = swiper.params.mousewheel;\n    if (e.originalEvent) { e = e.originalEvent; } // jquery fix\n    var delta = 0;\n    var rtlFactor = swiper.rtl ? -1 : 1;\n\n    var data = Mousewheel.normalize(e);\n\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) { delta = data.pixelX * rtlFactor; }\n        else { return true; }\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) { delta = data.pixelY; }\n      else { return true; }\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n\n    if (delta === 0) { return true; }\n\n    if (params.invert) { delta = -delta; }\n\n    if (!swiper.params.freeMode) {\n      if (Utils.now() - swiper.mousewheel.lastScrollTime > 60) {\n        if (delta < 0) {\n          if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n            swiper.slideNext();\n            swiper.emit('scroll', e);\n          } else if (params.releaseOnEdges) { return true; }\n        } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n          swiper.slidePrev();\n          swiper.emit('scroll', e);\n        } else if (params.releaseOnEdges) { return true; }\n      }\n      swiper.mousewheel.lastScrollTime = (new win.Date()).getTime();\n    } else {\n      // Freemode or scrollContainer:\n      var position = swiper.getTranslate() + (delta * params.sensitivity);\n      var wasBeginning = swiper.isBeginning;\n      var wasEnd = swiper.isEnd;\n\n      if (position >= swiper.minTranslate()) { position = swiper.minTranslate(); }\n      if (position <= swiper.maxTranslate()) { position = swiper.maxTranslate(); }\n\n      swiper.setTransition(0);\n      swiper.setTranslate(position);\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n\n      if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {\n        swiper.updateSlidesClasses();\n      }\n\n      if (swiper.params.freeModeSticky) {\n        clearTimeout(swiper.mousewheel.timeout);\n        swiper.mousewheel.timeout = Utils.nextTick(function () {\n          swiper.slideReset();\n        }, 300);\n      }\n      // Emit event\n      swiper.emit('scroll', e);\n\n      // Stop autoplay\n      if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) { swiper.stopAutoplay(); }\n\n      // Return page scroll on edge positions\n      if (position === 0 || position === swiper.maxTranslate()) { return true; }\n    }\n\n    if (e.preventDefault) { e.preventDefault(); }\n    else { e.returnValue = false; }\n    return false;\n  },\n  enable: function enable() {\n    var swiper = this;\n    if (!Mousewheel.event) { return false; }\n    if (swiper.mousewheel.enabled) { return false; }\n    var target = swiper.$el;\n    if (swiper.params.mousewheel.eventsTarged !== 'container') {\n      target = $$1(swiper.params.mousewheel.eventsTarged);\n    }\n    target.on(Mousewheel.event, swiper.mousewheel.handle);\n    swiper.mousewheel.enabled = true;\n    return true;\n  },\n  disable: function disable() {\n    var swiper = this;\n    if (!Mousewheel.event) { return false; }\n    if (!swiper.mousewheel.enabled) { return false; }\n    var target = swiper.$el;\n    if (swiper.params.mousewheel.eventsTarged !== 'container') {\n      target = $$1(swiper.params.mousewheel.eventsTarged);\n    }\n    target.off(Mousewheel.event, swiper.mousewheel.handle);\n    swiper.mousewheel.enabled = false;\n    return true;\n  },\n};\n\nvar Mousewheel$1 = {\n  name: 'mousewheel',\n  params: {\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarged: 'container',\n    },\n  },\n  create: function create() {\n    var swiper = this;\n    Utils.extend(swiper, {\n      mousewheel: {\n        enabled: false,\n        enable: Mousewheel.enable.bind(swiper),\n        disable: Mousewheel.disable.bind(swiper),\n        handle: Mousewheel.handle.bind(swiper),\n        lastScrollTime: Utils.now(),\n      },\n    });\n  },\n  on: {\n    init: function init() {\n      var swiper = this;\n      if (swiper.params.mousewheel.enabled) { swiper.mousewheel.enable(); }\n    },\n    destroy: function destroy() {\n      var swiper = this;\n      if (swiper.mousewheel.enabled) { swiper.mousewheel.disable(); }\n    },\n  },\n};\n\nvar Navigation = {\n  update: function update() {\n    // Update Navigation Buttons\n    var swiper = this;\n    var params = swiper.params.navigation;\n\n    if (swiper.params.loop) { return; }\n    var ref = swiper.navigation;\n    var $nextEl = ref.$nextEl;\n    var $prevEl = ref.$prevEl;\n\n    if ($prevEl && $prevEl.length > 0) {\n      if (swiper.isBeginning) {\n        $prevEl.addClass(params.disabledClass);\n      } else {\n        $prevEl.removeClass(params.disabledClass);\n      }\n    }\n    if ($nextEl && $nextEl.length > 0) {\n      if (swiper.isEnd) {\n        $nextEl.addClass(params.disabledClass);\n      } else {\n        $nextEl.removeClass(params.disabledClass);\n      }\n    }\n  },\n  init: function init() {\n    var swiper = this;\n    var params = swiper.params.navigation;\n    if (!(params.nextEl || params.prevEl)) { return; }\n\n    var $nextEl;\n    var $prevEl;\n    if (params.nextEl) {\n      $nextEl = $$1(params.nextEl);\n      if (\n        swiper.params.uniqueNavElements &&\n        typeof params.nextEl === 'string' &&\n        $nextEl.length > 1 &&\n        swiper.$el.find(params.nextEl).length === 1\n      ) {\n        $nextEl = swiper.$el.find(params.nextEl);\n      }\n    }\n    if (params.prevEl) {\n      $prevEl = $$1(params.prevEl);\n      if (\n        swiper.params.uniqueNavElements &&\n        typeof params.prevEl === 'string' &&\n        $prevEl.length > 1 &&\n        swiper.$el.find(params.prevEl).length === 1\n      ) {\n        $prevEl = swiper.$el.find(params.prevEl);\n      }\n    }\n\n    if ($nextEl && $nextEl.length > 0) {\n      $nextEl.on('click', function (e) {\n        e.preventDefault();\n        if (swiper.isEnd && !swiper.params.loop) { return; }\n        swiper.slideNext();\n      });\n    }\n    if ($prevEl && $prevEl.length > 0) {\n      $prevEl.on('click', function (e) {\n        e.preventDefault();\n        if (swiper.isBeginning && !swiper.params.loop) { return; }\n        swiper.slidePrev();\n      });\n    }\n\n    Utils.extend(swiper.navigation, {\n      $nextEl: $nextEl,\n      nextEl: $nextEl && $nextEl[0],\n      $prevEl: $prevEl,\n      prevEl: $prevEl && $prevEl[0],\n    });\n  },\n  destroy: function destroy() {\n    var swiper = this;\n    var ref = swiper.navigation;\n    var $nextEl = ref.$nextEl;\n    var $prevEl = ref.$prevEl;\n    if ($nextEl && $nextEl.length) {\n      $nextEl.off('click');\n      $nextEl.removeClass(swiper.params.navigation.disabledClass);\n    }\n    if ($prevEl && $prevEl.length) {\n      $prevEl.off('click');\n      $prevEl.removeClass(swiper.params.navigation.disabledClass);\n    }\n  },\n};\n\nvar Navigation$1 = {\n  name: 'navigation',\n  params: {\n    navigation: {\n      nextEl: null,\n      prevEl: null,\n\n      hideOnClick: false,\n      disabledClass: 'swiper-button-disabled',\n      hiddenClass: 'swiper-button-hidden',\n    },\n  },\n  create: function create() {\n    var swiper = this;\n    Utils.extend(swiper, {\n      navigation: {\n        init: Navigation.init.bind(swiper),\n        update: Navigation.update.bind(swiper),\n        destroy: Navigation.destroy.bind(swiper),\n      },\n    });\n  },\n  on: {\n    init: function init() {\n      var swiper = this;\n      swiper.navigation.init();\n      swiper.navigation.update();\n    },\n    toEdge: function toEdge() {\n      var swiper = this;\n      swiper.navigation.update();\n    },\n    fromEdge: function fromEdge() {\n      var swiper = this;\n      swiper.navigation.update();\n    },\n    destroy: function destroy() {\n      var swiper = this;\n      swiper.navigation.destroy();\n    },\n    click: function click(e) {\n      var swiper = this;\n      var ref = swiper.navigation;\n      var $nextEl = ref.$nextEl;\n      var $prevEl = ref.$prevEl;\n      if (\n        swiper.params.navigation.hideOnClick &&\n        !$$1(e.target).is($prevEl) &&\n        !$$1(e.target).is($nextEl)\n      ) {\n        if ($nextEl) { $nextEl.toggleClass(swiper.params.navigation.hiddenClass); }\n        if ($prevEl) { $prevEl.toggleClass(swiper.params.navigation.hiddenClass); }\n      }\n    },\n  },\n};\n\nvar Pagination = {\n  update: function update() {\n    // Render || Update Pagination bullets/items\n    var swiper = this;\n    var rtl = swiper.rtl;\n    var params = swiper.params.pagination;\n    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }\n    var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n    var $el = swiper.pagination.$el;\n    // Current/Total\n    var current;\n    var total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n    if (swiper.params.loop) {\n      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);\n      if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {\n        current -= (slidesLength - (swiper.loopedSlides * 2));\n      }\n      if (current > total - 1) { current -= total; }\n      if (current < 0 && swiper.params.paginationType !== 'bullets') { current = total + current; }\n    } else if (typeof swiper.snapIndex !== 'undefined') {\n      current = swiper.snapIndex;\n    } else {\n      current = swiper.activeIndex || 0;\n    }\n    // Types\n    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n      var bullets = swiper.pagination.bullets;\n      if (params.dynamicBullets) {\n        swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);\n        $el.css(swiper.isHorizontal() ? 'width' : 'height', ((swiper.pagination.bulletSize * 5) + \"px\"));\n      }\n      bullets.removeClass(((params.bulletActiveClass) + \" \" + (params.bulletActiveClass) + \"-next \" + (params.bulletActiveClass) + \"-next-next \" + (params.bulletActiveClass) + \"-prev \" + (params.bulletActiveClass) + \"-prev-prev\"));\n      if ($el.length > 1) {\n        bullets.each(function (index, bullet) {\n          var $bullet = $$1(bullet);\n          if ($bullet.index() === current) {\n            $bullet.addClass(params.bulletActiveClass);\n            if (params.dynamicBullets) {\n              $bullet\n                .prev()\n                .addClass(((params.bulletActiveClass) + \"-prev\"))\n                .prev()\n                .addClass(((params.bulletActiveClass) + \"-prev-prev\"));\n              $bullet\n                .next()\n                .addClass(((params.bulletActiveClass) + \"-next\"))\n                .next()\n                .addClass(((params.bulletActiveClass) + \"-next-next\"));\n            }\n          }\n        });\n      } else {\n        var $bullet = bullets.eq(current);\n        $bullet.addClass(params.bulletActiveClass);\n        if (params.dynamicBullets) {\n          $bullet\n            .prev()\n            .addClass(((params.bulletActiveClass) + \"-prev\"))\n            .prev()\n            .addClass(((params.bulletActiveClass) + \"-prev-prev\"));\n          $bullet\n            .next()\n            .addClass(((params.bulletActiveClass) + \"-next\"))\n            .next()\n            .addClass(((params.bulletActiveClass) + \"-next-next\"));\n        }\n      }\n      if (params.dynamicBullets) {\n        var dynamicBulletsLength = Math.min(bullets.length, 5);\n        var bulletsOffset = (((swiper.pagination.bulletSize * dynamicBulletsLength) - (swiper.pagination.bulletSize)) / 2) - (current * swiper.pagination.bulletSize);\n        var offsetProp = rtl ? 'right' : 'left';\n        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', (bulletsOffset + \"px\"));\n      }\n    }\n    if (params.type === 'fraction') {\n      $el.find((\".\" + (params.currentClass))).text(current + 1);\n      $el.find((\".\" + (params.totalClass))).text(total);\n    }\n    if (params.type === 'progressbar') {\n      var scale = (current + 1) / total;\n      var scaleX = scale;\n      var scaleY = 1;\n      if (!swiper.isHorizontal()) {\n        scaleY = scale;\n        scaleX = 1;\n      }\n      $el.find((\".\" + (params.progressbarFillClass))).transform((\"translate3d(0,0,0) scaleX(\" + scaleX + \") scaleY(\" + scaleY + \")\")).transition(swiper.params.speed);\n    }\n    if (params.type === 'custom' && params.renderCustom) {\n      $el.html(params.renderCustom(swiper, current + 1, total));\n      swiper.emit('paginationRender', swiper, $el[0]);\n    } else {\n      swiper.emit('paginationUpdate', swiper, $el[0]);\n    }\n  },\n  render: function render() {\n    // Render Container\n    var swiper = this;\n    var params = swiper.params.pagination;\n    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }\n    var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n\n    var $el = swiper.pagination.$el;\n    var paginationHTML = '';\n    if (params.type === 'bullets') {\n      var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n      for (var i = 0; i < numberOfBullets; i += 1) {\n        if (params.renderBullet) {\n          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n        } else {\n          paginationHTML += \"<\" + (params.bulletElement) + \" class=\\\"\" + (params.bulletClass) + \"\\\"></\" + (params.bulletElement) + \">\";\n        }\n      }\n      $el.html(paginationHTML);\n      swiper.pagination.bullets = $el.find((\".\" + (params.bulletClass)));\n    }\n    if (params.type === 'fraction') {\n      if (params.renderFraction) {\n        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n      } else {\n        paginationHTML =\n        \"<span class=\\\"\" + (params.currentClass) + \"\\\"></span>\" +\n        ' / ' +\n        \"<span class=\\\"\" + (params.totalClass) + \"\\\"></span>\";\n      }\n      $el.html(paginationHTML);\n    }\n    if (params.type === 'progressbar') {\n      if (params.renderProgressbar) {\n        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n      } else {\n        paginationHTML = \"<span class=\\\"\" + (params.progressbarFillClass) + \"\\\"></span>\";\n      }\n      $el.html(paginationHTML);\n    }\n    if (params.type !== 'custom') {\n      swiper.emit('paginationRender', swiper.pagination.$el[0]);\n    }\n  },\n  init: function init() {\n    var swiper = this;\n    var params = swiper.params.pagination;\n    if (!params.el) { return; }\n\n    var $el = $$1(params.el);\n    if ($el.length === 0) { return; }\n\n    if (\n      swiper.params.uniqueNavElements &&\n      typeof params.el === 'string' &&\n      $el.length > 1 &&\n      swiper.$el.find(params.el).length === 1\n    ) {\n      $el = swiper.$el.find(params.el);\n    }\n\n    if (params.type === 'bullets' && params.clickable) {\n      $el.addClass(params.clickableClass);\n    }\n\n    $el.addClass(params.modifierClass + params.type);\n\n    if (params.type === 'bullets' && params.dynamicBullets) {\n      $el.addClass((\"\" + (params.modifierClass) + (params.type) + \"-dynamic\"));\n    }\n\n    if (params.clickable) {\n      $el.on('click', (\".\" + (params.bulletClass)), function onClick(e) {\n        e.preventDefault();\n        var index = $$1(this).index() * swiper.params.slidesPerGroup;\n        if (swiper.params.loop) { index += swiper.loopedSlides; }\n        swiper.slideTo(index);\n      });\n    }\n\n    Utils.extend(swiper.pagination, {\n      $el: $el,\n      el: $el[0],\n    });\n  },\n  destroy: function destroy() {\n    var swiper = this;\n    var params = swiper.params.pagination;\n    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }\n    var $el = swiper.pagination.$el;\n\n    $el.removeClass(params.hiddenClass);\n    $el.removeClass(params.modifierClass + params.type);\n    if (swiper.pagination.bullets) { swiper.pagination.bullets.removeClass(params.bulletActiveClass); }\n    if (params.clickable) {\n      $el.off('click', (\".\" + (params.bulletClass)));\n    }\n  },\n};\n\nvar Pagination$1 = {\n  name: 'pagination',\n  params: {\n    pagination: {\n      el: null,\n      bulletElement: 'span',\n      clickable: false,\n      hideOnClick: false,\n      renderBullet: null,\n      renderProgressbar: null,\n      renderFraction: null,\n      renderCustom: null,\n      type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n      dynamicBullets: false,\n\n      bulletClass: 'swiper-pagination-bullet',\n      bulletActiveClass: 'swiper-pagination-bullet-active',\n      modifierClass: 'swiper-pagination-', // NEW\n      currentClass: 'swiper-pagination-current',\n      totalClass: 'swiper-pagination-total',\n      hiddenClass: 'swiper-pagination-hidden',\n      progressbarFillClass: 'swiper-pagination-progressbar-fill',\n      clickableClass: 'swiper-pagination-clickable', // NEW\n    },\n  },\n  create: function create() {\n    var swiper = this;\n    Utils.extend(swiper, {\n      pagination: {\n        init: Pagination.init.bind(swiper),\n        render: Pagination.render.bind(swiper),\n        update: Pagination.update.bind(swiper),\n        destroy: Pagination.destroy.bind(swiper),\n      },\n    });\n  },\n  on: {\n    init: function init() {\n      var swiper = this;\n      swiper.pagination.init();\n      swiper.pagination.render();\n      swiper.pagination.update();\n    },\n    activeIndexChange: function activeIndexChange() {\n      var swiper = this;\n      if (swiper.params.loop) {\n        swiper.pagination.update();\n      } else if (typeof swiper.snapIndex === 'undefined') {\n        swiper.pagination.update();\n      }\n    },\n    snapIndexChange: function snapIndexChange() {\n      var swiper = this;\n      if (!swiper.params.loop) {\n        swiper.pagination.update();\n      }\n    },\n    slidesLengthChange: function slidesLengthChange() {\n      var swiper = this;\n      if (swiper.params.loop) {\n        swiper.pagination.render();\n        swiper.pagination.update();\n      }\n    },\n    snapGridLengthChange: function snapGridLengthChange() {\n      var swiper = this;\n      if (!swiper.params.loop) {\n        swiper.pagination.render();\n        swiper.pagination.update();\n      }\n    },\n    destroy: function destroy() {\n      var swiper = this;\n      swiper.pagination.destroy();\n    },\n    click: function click(e) {\n      var swiper = this;\n      if (\n        swiper.params.pagination.el &&\n        swiper.params.pagination.hideOnClick &&\n        swiper.pagination.$el.length > 0 &&\n        !$$1(e.target).hasClass(swiper.params.pagination.bulletClass)\n      ) {\n        swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);\n      }\n    },\n  },\n};\n\nvar Scrollbar = {\n  setTranslate: function setTranslate() {\n    var swiper = this;\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }\n    var scrollbar = swiper.scrollbar;\n    var rtl = swiper.rtl;\n    var progress = swiper.progress;\n    var dragSize = scrollbar.dragSize;\n    var trackSize = scrollbar.trackSize;\n    var $dragEl = scrollbar.$dragEl;\n    var $el = scrollbar.$el;\n    var params = swiper.params.scrollbar;\n\n    var newSize = dragSize;\n    var newPos = (trackSize - dragSize) * progress;\n    if (rtl && swiper.isHorizontal()) {\n      newPos = -newPos;\n      if (newPos > 0) {\n        newSize = dragSize - newPos;\n        newPos = 0;\n      } else if (-newPos + dragSize > trackSize) {\n        newSize = trackSize + newPos;\n      }\n    } else if (newPos < 0) {\n      newSize = dragSize + newPos;\n      newPos = 0;\n    } else if (newPos + dragSize > trackSize) {\n      newSize = trackSize - newPos;\n    }\n    if (swiper.isHorizontal()) {\n      if (Support.transforms3d) {\n        $dragEl.transform((\"translate3d(\" + newPos + \"px, 0, 0)\"));\n      } else {\n        $dragEl.transform((\"translateX(\" + newPos + \"px)\"));\n      }\n      $dragEl[0].style.width = newSize + \"px\";\n    } else {\n      if (Support.transforms3d) {\n        $dragEl.transform((\"translate3d(0px, \" + newPos + \"px, 0)\"));\n      } else {\n        $dragEl.transform((\"translateY(\" + newPos + \"px)\"));\n      }\n      $dragEl[0].style.height = newSize + \"px\";\n    }\n    if (params.hide) {\n      clearTimeout(swiper.scrollbar.timeout);\n      $el[0].style.opacity = 1;\n      swiper.scrollbar.timeout = setTimeout(function () {\n        $el[0].style.opacity = 0;\n        $el.transition(400);\n      }, 1000);\n    }\n  },\n  setTransition: function setTransition(duration) {\n    var swiper = this;\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }\n    swiper.scrollbar.$dragEl.transition(duration);\n  },\n  updateSize: function updateSize() {\n    var swiper = this;\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }\n\n    var scrollbar = swiper.scrollbar;\n    var $dragEl = scrollbar.$dragEl;\n    var $el = scrollbar.$el;\n\n    $dragEl[0].style.width = '';\n    $dragEl[0].style.height = '';\n    var trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;\n\n    var divider = swiper.size / swiper.virtualSize;\n    var moveDivider = divider * (trackSize / swiper.size);\n    var dragSize;\n    if (swiper.params.scrollbar.dragSize === 'auto') {\n      dragSize = trackSize * divider;\n    } else {\n      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n    }\n\n    if (swiper.isHorizontal()) {\n      $dragEl[0].style.width = dragSize + \"px\";\n    } else {\n      $dragEl[0].style.height = dragSize + \"px\";\n    }\n\n    if (divider >= 1) {\n      $el[0].style.display = 'none';\n    } else {\n      $el[0].style.display = '';\n    }\n    if (swiper.params.scrollbarHide) {\n      $el[0].style.opacity = 0;\n    }\n    Utils.extend(scrollbar, {\n      trackSize: trackSize,\n      divider: divider,\n      moveDivider: moveDivider,\n      dragSize: dragSize,\n    });\n  },\n  setDragPosition: function setDragPosition(e) {\n    var swiper = this;\n    var scrollbar = swiper.scrollbar;\n    var $el = scrollbar.$el;\n    var dragSize = scrollbar.dragSize;\n    var trackSize = scrollbar.trackSize;\n\n    var pointerPosition;\n    if (swiper.isHorizontal()) {\n      pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageX : e.pageX || e.clientX);\n    } else {\n      pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageY : e.pageY || e.clientY);\n    }\n    var positionRatio;\n    positionRatio = ((pointerPosition) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragSize / 2)) / (trackSize - dragSize);\n    positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n    if (swiper.rtl) {\n      positionRatio = 1 - positionRatio;\n    }\n\n    var position = swiper.minTranslate() + ((swiper.maxTranslate() - swiper.minTranslate()) * positionRatio);\n\n    swiper.updateProgress(position);\n    swiper.setTranslate(position);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  },\n  onDragStart: function onDragStart(e) {\n    var swiper = this;\n    var params = swiper.params.scrollbar;\n    var scrollbar = swiper.scrollbar;\n    var $wrapperEl = swiper.$wrapperEl;\n    var $el = scrollbar.$el;\n    var $dragEl = scrollbar.$dragEl;\n    swiper.scrollbar.isTouched = true;\n    e.preventDefault();\n    e.stopPropagation();\n\n    $wrapperEl.transition(100);\n    $dragEl.transition(100);\n    scrollbar.setDragPosition(e);\n\n    clearTimeout(swiper.scrollbar.dragTimeout);\n\n    $el.transition(0);\n    if (params.hide) {\n      $el.css('opacity', 1);\n    }\n    swiper.emit('scrollbarDragStart', e);\n  },\n  onDragMove: function onDragMove(e) {\n    var swiper = this;\n    var scrollbar = swiper.scrollbar;\n    var $wrapperEl = swiper.$wrapperEl;\n    var $el = scrollbar.$el;\n    var $dragEl = scrollbar.$dragEl;\n\n    if (!swiper.scrollbar.isTouched) { return; }\n    if (e.preventDefault) { e.preventDefault(); }\n    else { e.returnValue = false; }\n    scrollbar.setDragPosition(e);\n    $wrapperEl.transition(0);\n    $el.transition(0);\n    $dragEl.transition(0);\n    swiper.emit('scrollbarDragMove', e);\n  },\n  onDragEnd: function onDragEnd(e) {\n    var swiper = this;\n\n    var params = swiper.params.scrollbar;\n    var scrollbar = swiper.scrollbar;\n    var $el = scrollbar.$el;\n\n    if (!swiper.scrollbar.isTouched) { return; }\n    swiper.scrollbar.isTouched = false;\n    if (params.hide) {\n      clearTimeout(swiper.scrollbar.dragTimeout);\n      swiper.scrollbar.dragTimeout = Utils.nextTick(function () {\n        $el.css('opacity', 0);\n        $el.transition(400);\n      }, 1000);\n    }\n    swiper.emit('scrollbarDragEnd', e);\n    if (params.snapOnRelease) {\n      swiper.slideReset();\n    }\n  },\n  enableDraggable: function enableDraggable() {\n    var swiper = this;\n    if (!swiper.params.scrollbar.el) { return; }\n    var scrollbar = swiper.scrollbar;\n    var $el = scrollbar.$el;\n    var target = Support.touch ? $el[0] : document;\n    $el.on(swiper.scrollbar.dragEvents.start, swiper.scrollbar.onDragStart);\n    $$1(target).on(swiper.scrollbar.dragEvents.move, swiper.scrollbar.onDragMove);\n    $$1(target).on(swiper.scrollbar.dragEvents.end, swiper.scrollbar.onDragEnd);\n  },\n  disableDraggable: function disableDraggable() {\n    var swiper = this;\n    if (!swiper.params.scrollbar.el) { return; }\n    var scrollbar = swiper.scrollbar;\n    var $el = scrollbar.$el;\n    var target = Support.touch ? $el[0] : document;\n    $el.off(swiper.scrollbar.dragEvents.start);\n    $$1(target).off(swiper.scrollbar.dragEvents.move);\n    $$1(target).off(swiper.scrollbar.dragEvents.end);\n  },\n  init: function init() {\n    var swiper = this;\n    if (!swiper.params.scrollbar.el) { return; }\n    var scrollbar = swiper.scrollbar;\n    var $swiperEl = swiper.$el;\n    var touchEvents = swiper.touchEvents;\n    var params = swiper.params.scrollbar;\n\n    var $el = $$1(params.el);\n    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {\n      $el = $swiperEl.find(params.el);\n    }\n\n    var $dragEl = $el.find('.swiper-scrollbar-drag');\n    if ($dragEl.length === 0) {\n      $dragEl = $$1('<div class=\"swiper-scrollbar-drag\"></div>');\n      $el.append($dragEl);\n    }\n\n    swiper.scrollbar.dragEvents = (function dragEvents() {\n      if ((swiper.params.simulateTouch === false && !Support.touch)) {\n        return {\n          start: 'mousedown',\n          move: 'mousemove',\n          end: 'mouseup',\n        };\n      }\n      return touchEvents;\n    }());\n\n    Utils.extend(scrollbar, {\n      $el: $el,\n      el: $el[0],\n      $dragEl: $dragEl,\n      dragEl: $dragEl[0],\n    });\n\n    if (params.draggable) {\n      scrollbar.enableDraggable();\n    }\n  },\n  destroy: function destroy() {\n    var swiper = this;\n    swiper.scrollbar.disableDraggable();\n  },\n};\n\nvar Scrollbar$1 = {\n  name: 'scrollbar',\n  params: {\n    scrollbar: {\n      el: null,\n      dragSize: 'auto',\n      hide: false,\n      draggable: false,\n      snapOnRelease: true,\n    },\n  },\n  create: function create() {\n    var swiper = this;\n    Utils.extend(swiper, {\n      scrollbar: {\n        init: Scrollbar.init.bind(swiper),\n        destroy: Scrollbar.destroy.bind(swiper),\n        updateSize: Scrollbar.updateSize.bind(swiper),\n        setTranslate: Scrollbar.setTranslate.bind(swiper),\n        setTransition: Scrollbar.setTransition.bind(swiper),\n        enableDraggable: Scrollbar.enableDraggable.bind(swiper),\n        disableDraggable: Scrollbar.disableDraggable.bind(swiper),\n        setDragPosition: Scrollbar.setDragPosition.bind(swiper),\n        onDragStart: Scrollbar.onDragStart.bind(swiper),\n        onDragMove: Scrollbar.onDragMove.bind(swiper),\n        onDragEnd: Scrollbar.onDragEnd.bind(swiper),\n        isTouched: false,\n        timeout: null,\n        dragTimeout: null,\n      },\n    });\n  },\n  on: {\n    init: function init() {\n      var swiper = this;\n      swiper.scrollbar.init();\n      swiper.scrollbar.updateSize();\n      swiper.scrollbar.setTranslate();\n    },\n    update: function update() {\n      var swiper = this;\n      swiper.scrollbar.updateSize();\n    },\n    resize: function resize() {\n      var swiper = this;\n      swiper.scrollbar.updateSize();\n    },\n    observerUpdate: function observerUpdate() {\n      var swiper = this;\n      swiper.scrollbar.updateSize();\n    },\n    setTranslate: function setTranslate() {\n      var swiper = this;\n      swiper.scrollbar.setTranslate();\n    },\n    setTransition: function setTransition(duration) {\n      var swiper = this;\n      swiper.scrollbar.setTransition(duration);\n    },\n    destroy: function destroy() {\n      var swiper = this;\n      swiper.scrollbar.destroy();\n    },\n  },\n};\n\nvar Parallax = {\n  setTransform: function setTransform(el, progress) {\n    var swiper = this;\n    var rtl = swiper.rtl;\n\n    var $el = $$1(el);\n    var rtlFactor = rtl ? -1 : 1;\n\n    var p = $el.attr('data-swiper-parallax') || '0';\n    var x = $el.attr('data-swiper-parallax-x');\n    var y = $el.attr('data-swiper-parallax-y');\n    var scale = $el.attr('data-swiper-parallax-scale');\n    var opacity = $el.attr('data-swiper-parallax-opacity');\n\n    if (x || y) {\n      x = x || '0';\n      y = y || '0';\n    } else if (swiper.isHorizontal()) {\n      x = p;\n      y = '0';\n    } else {\n      y = p;\n      x = '0';\n    }\n\n    if ((x).indexOf('%') >= 0) {\n      x = (parseInt(x, 10) * progress * rtlFactor) + \"%\";\n    } else {\n      x = (x * progress * rtlFactor) + \"px\";\n    }\n    if ((y).indexOf('%') >= 0) {\n      y = (parseInt(y, 10) * progress) + \"%\";\n    } else {\n      y = (y * progress) + \"px\";\n    }\n\n    if (typeof opacity !== 'undefined' && opacity !== null) {\n      var currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));\n      $el[0].style.opacity = currentOpacity;\n    }\n    if (typeof scale === 'undefined' || scale === null) {\n      $el.transform((\"translate3d(\" + x + \", \" + y + \", 0px)\"));\n    } else {\n      var currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));\n      $el.transform((\"translate3d(\" + x + \", \" + y + \", 0px) scale(\" + currentScale + \")\"));\n    }\n  },\n  setTranslate: function setTranslate() {\n    var swiper = this;\n    var $el = swiper.$el;\n    var slides = swiper.slides;\n    var progress = swiper.progress;\n    var snapGrid = swiper.snapGrid;\n    $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')\n      .each(function (index, el) {\n        swiper.parallax.setTransform(el, progress);\n      });\n    slides.each(function (slideIndex, slideEl) {\n      var slideProgress = slideEl.progress;\n      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {\n        slideProgress += Math.ceil(slideIndex / 2) - (progress * (snapGrid.length - 1));\n      }\n      slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n      $$1(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')\n        .each(function (index, el) {\n          swiper.parallax.setTransform(el, slideProgress);\n        });\n    });\n  },\n  setTransition: function setTransition(duration) {\n    if ( duration === void 0 ) duration = this.params.speed;\n\n    var swiper = this;\n    var $el = swiper.$el;\n    $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')\n      .each(function (index, parallaxEl) {\n        var $parallaxEl = $$1(parallaxEl);\n        var parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;\n        if (duration === 0) { parallaxDuration = 0; }\n        $parallaxEl.transition(parallaxDuration);\n      });\n  },\n};\n\nvar Parallax$1 = {\n  name: 'parallax',\n  params: {\n    parallax: {\n      enabled: false,\n    },\n  },\n  create: function create() {\n    var swiper = this;\n    Utils.extend(swiper, {\n      parallax: {\n        setTransform: Parallax.setTransform.bind(swiper),\n        setTranslate: Parallax.setTranslate.bind(swiper),\n        setTransition: Parallax.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit: function beforeInit() {\n      var swiper = this;\n      swiper.params.watchSlidesProgress = true;\n    },\n    init: function init() {\n      var swiper = this;\n      if (!swiper.params.parallax) { return; }\n      swiper.parallax.setTranslate();\n    },\n    setTranslate: function setTranslate() {\n      var swiper = this;\n      if (!swiper.params.parallax) { return; }\n      swiper.parallax.setTranslate();\n    },\n    setTransition: function setTransition(duration) {\n      var swiper = this;\n      if (!swiper.params.parallax) { return; }\n      swiper.parallax.setTransition(duration);\n    },\n  },\n};\n\nvar Zoom = {\n  // Calc Scale From Multi-touches\n  getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {\n    if (e.targetTouches.length < 2) { return 1; }\n    var x1 = e.targetTouches[0].pageX;\n    var y1 = e.targetTouches[0].pageY;\n    var x2 = e.targetTouches[1].pageX;\n    var y2 = e.targetTouches[1].pageY;\n    var distance = Math.sqrt((Math.pow( (x2 - x1), 2 )) + (Math.pow( (y2 - y1), 2 )));\n    return distance;\n  },\n  // Events\n  onGestureStart: function onGestureStart(e) {\n    var swiper = this;\n    var params = swiper.params.zoom;\n    var zoom = swiper.zoom;\n    var gesture = zoom.gesture;\n    zoom.fakeGestureTouched = false;\n    zoom.fakeGestureMoved = false;\n    if (!Support.gestures) {\n      if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {\n        return;\n      }\n      zoom.fakeGestureTouched = true;\n      gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);\n    }\n    if (!gesture.$slideEl || !gesture.$slideEl.length) {\n      gesture.$slideEl = $$1(this);\n      if (gesture.$slideEl.length === 0) { gesture.$slideEl = swiper.slides.eq(swiper.activeIndex); }\n      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');\n      gesture.$imageWrapEl = gesture.$imageEl.parent((\".\" + (params.containerClass)));\n      gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n      if (gesture.$imageWrapEl.length === 0) {\n        gesture.$imageEl = undefined;\n        return;\n      }\n    }\n    gesture.$imageEl.transition(0);\n    swiper.zoom.isScaling = true;\n  },\n  onGestureChange: function onGestureChange(e) {\n    var swiper = this;\n    var params = swiper.params.zoom;\n    var zoom = swiper.zoom;\n    var gesture = zoom.gesture;\n    if (!Support.gestures) {\n      if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {\n        return;\n      }\n      zoom.fakeGestureMoved = true;\n      gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);\n    }\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }\n    if (Support.gestures) {\n      swiper.zoom.scale = e.scale * zoom.currentScale;\n    } else {\n      zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;\n    }\n    if (zoom.scale > gesture.maxRatio) {\n      zoom.scale = (gesture.maxRatio - 1) + (Math.pow( ((zoom.scale - gesture.maxRatio) + 1), 0.5 ));\n    }\n    if (zoom.scale < params.minRatio) {\n      zoom.scale = (params.minRatio + 1) - (Math.pow( ((params.minRatio - zoom.scale) + 1), 0.5 ));\n    }\n    gesture.$imageEl.transform((\"translate3d(0,0,0) scale(\" + (zoom.scale) + \")\"));\n  },\n  onGestureEnd: function onGestureEnd(e) {\n    var swiper = this;\n    var params = swiper.params.zoom;\n    var zoom = swiper.zoom;\n    var gesture = zoom.gesture;\n    if (!Support.gestures) {\n      if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {\n        return;\n      }\n      if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android)) {\n        return;\n      }\n      zoom.fakeGestureTouched = false;\n      zoom.fakeGestureMoved = false;\n    }\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }\n    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n    gesture.$imageEl.transition(swiper.params.speed).transform((\"translate3d(0,0,0) scale(\" + (zoom.scale) + \")\"));\n    zoom.currentScale = zoom.scale;\n    zoom.isScaling = false;\n    if (zoom.scale === 1) { gesture.$slideEl = undefined; }\n  },\n  onTouchStart: function onTouchStart(e) {\n    var swiper = this;\n    var zoom = swiper.zoom;\n    var gesture = zoom.gesture;\n    var image = zoom.image;\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }\n    if (image.isTouched) { return; }\n    if (Device.android) { e.preventDefault(); }\n    image.isTouched = true;\n    image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;\n    image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;\n  },\n  onTouchMove: function onTouchMove(e) {\n    var swiper = this;\n    var zoom = swiper.zoom;\n    var gesture = zoom.gesture;\n    var image = zoom.image;\n    var velocity = zoom.velocity;\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }\n    swiper.allowClick = false;\n    if (!image.isTouched || !gesture.$slideEl) { return; }\n\n    if (!image.isMoved) {\n      image.width = gesture.$imageEl[0].offsetWidth;\n      image.height = gesture.$imageEl[0].offsetHeight;\n      image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;\n      image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;\n      gesture.slideWidth = gesture.$slideEl[0].offsetWidth;\n      gesture.slideHeight = gesture.$slideEl[0].offsetHeight;\n      gesture.$imageWrapEl.transition(0);\n      if (swiper.rtl) { image.startX = -image.startX; }\n      if (swiper.rtl) { image.startY = -image.startY; }\n    }\n    // Define if we need image drag\n    var scaledWidth = image.width * zoom.scale;\n    var scaledHeight = image.height * zoom.scale;\n\n    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) { return; }\n\n    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);\n    image.maxY = -image.minY;\n\n    image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;\n    image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;\n\n    if (!image.isMoved && !zoom.isScaling) {\n      if (\n        swiper.isHorizontal() &&\n        (\n          (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x) ||\n          (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)\n        )\n      ) {\n        image.isTouched = false;\n        return;\n      } else if (\n        !swiper.isHorizontal() &&\n        (\n          (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y) ||\n          (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)\n        )\n      ) {\n        image.isTouched = false;\n        return;\n      }\n    }\n    e.preventDefault();\n    e.stopPropagation();\n\n    image.isMoved = true;\n    image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;\n    image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;\n\n    if (image.currentX < image.minX) {\n      image.currentX = (image.minX + 1) - (Math.pow( ((image.minX - image.currentX) + 1), 0.8 ));\n    }\n    if (image.currentX > image.maxX) {\n      image.currentX = (image.maxX - 1) + (Math.pow( ((image.currentX - image.maxX) + 1), 0.8 ));\n    }\n\n    if (image.currentY < image.minY) {\n      image.currentY = (image.minY + 1) - (Math.pow( ((image.minY - image.currentY) + 1), 0.8 ));\n    }\n    if (image.currentY > image.maxY) {\n      image.currentY = (image.maxY - 1) + (Math.pow( ((image.currentY - image.maxY) + 1), 0.8 ));\n    }\n\n    // Velocity\n    if (!velocity.prevPositionX) { velocity.prevPositionX = image.touchesCurrent.x; }\n    if (!velocity.prevPositionY) { velocity.prevPositionY = image.touchesCurrent.y; }\n    if (!velocity.prevTime) { velocity.prevTime = Date.now(); }\n    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) { velocity.x = 0; }\n    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) { velocity.y = 0; }\n    velocity.prevPositionX = image.touchesCurrent.x;\n    velocity.prevPositionY = image.touchesCurrent.y;\n    velocity.prevTime = Date.now();\n\n    gesture.$imageWrapEl.transform((\"translate3d(\" + (image.currentX) + \"px, \" + (image.currentY) + \"px,0)\"));\n  },\n  onTouchEnd: function onTouchEnd() {\n    var swiper = this;\n    var zoom = swiper.zoom;\n    var gesture = zoom.gesture;\n    var image = zoom.image;\n    var velocity = zoom.velocity;\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }\n    if (!image.isTouched || !image.isMoved) {\n      image.isTouched = false;\n      image.isMoved = false;\n      return;\n    }\n    image.isTouched = false;\n    image.isMoved = false;\n    var momentumDurationX = 300;\n    var momentumDurationY = 300;\n    var momentumDistanceX = velocity.x * momentumDurationX;\n    var newPositionX = image.currentX + momentumDistanceX;\n    var momentumDistanceY = velocity.y * momentumDurationY;\n    var newPositionY = image.currentY + momentumDistanceY;\n\n    // Fix duration\n    if (velocity.x !== 0) { momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x); }\n    if (velocity.y !== 0) { momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y); }\n    var momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n\n    image.currentX = newPositionX;\n    image.currentY = newPositionY;\n\n    // Define if we need image drag\n    var scaledWidth = image.width * zoom.scale;\n    var scaledHeight = image.height * zoom.scale;\n    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);\n    image.maxY = -image.minY;\n    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n\n    gesture.$imageWrapEl.transition(momentumDuration).transform((\"translate3d(\" + (image.currentX) + \"px, \" + (image.currentY) + \"px,0)\"));\n  },\n  onTransitionEnd: function onTransitionEnd() {\n    var swiper = this;\n    var zoom = swiper.zoom;\n    var gesture = zoom.gesture;\n    if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {\n      gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');\n      gesture.$imageWrapEl.transform('translate3d(0,0,0)');\n      gesture.$slideEl = undefined;\n      gesture.$imageEl = undefined;\n      gesture.$imageWrapEl = undefined;\n\n      zoom.scale = 1;\n      zoom.currentScale = 1;\n    }\n  },\n  // Toggle Zoom\n  toggle: function toggle(e) {\n    var swiper = this;\n    var zoom = swiper.zoom;\n\n    if (zoom.scale && zoom.scale !== 1) {\n      // Zoom Out\n      zoom.out();\n    } else {\n      // Zoom In\n      zoom.in(e);\n    }\n  },\n  in: function in$1(e) {\n    var swiper = this;\n\n    var zoom = swiper.zoom;\n    var params = swiper.params.zoom;\n    var gesture = zoom.gesture;\n    var image = zoom.image;\n\n    if (!gesture.$slideEl) {\n      gesture.$slideEl = swiper.clickedSlide ? $$1(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);\n      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');\n      gesture.$imageWrapEl = gesture.$imageEl.parent((\".\" + (params.containerClass)));\n    }\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }\n\n    gesture.$slideEl.addClass((\"\" + (params.zoomedSlideClass)));\n\n    var touchX;\n    var touchY;\n    var offsetX;\n    var offsetY;\n    var diffX;\n    var diffY;\n    var translateX;\n    var translateY;\n    var imageWidth;\n    var imageHeight;\n    var scaledWidth;\n    var scaledHeight;\n    var translateMinX;\n    var translateMinY;\n    var translateMaxX;\n    var translateMaxY;\n    var slideWidth;\n    var slideHeight;\n\n    if (typeof image.touchesStart.x === 'undefined' && e) {\n      touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;\n      touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;\n    } else {\n      touchX = image.touchesStart.x;\n      touchY = image.touchesStart.y;\n    }\n\n    zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n    zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n    if (e) {\n      slideWidth = gesture.$slideEl[0].offsetWidth;\n      slideHeight = gesture.$slideEl[0].offsetHeight;\n      offsetX = gesture.$slideEl.offset().left;\n      offsetY = gesture.$slideEl.offset().top;\n      diffX = (offsetX + (slideWidth / 2)) - touchX;\n      diffY = (offsetY + (slideHeight / 2)) - touchY;\n\n      imageWidth = gesture.$imageEl[0].offsetWidth;\n      imageHeight = gesture.$imageEl[0].offsetHeight;\n      scaledWidth = imageWidth * zoom.scale;\n      scaledHeight = imageHeight * zoom.scale;\n\n      translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);\n      translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);\n      translateMaxX = -translateMinX;\n      translateMaxY = -translateMinY;\n\n      translateX = diffX * zoom.scale;\n      translateY = diffY * zoom.scale;\n\n      if (translateX < translateMinX) {\n        translateX = translateMinX;\n      }\n      if (translateX > translateMaxX) {\n        translateX = translateMaxX;\n      }\n\n      if (translateY < translateMinY) {\n        translateY = translateMinY;\n      }\n      if (translateY > translateMaxY) {\n        translateY = translateMaxY;\n      }\n    } else {\n      translateX = 0;\n      translateY = 0;\n    }\n    gesture.$imageWrapEl.transition(300).transform((\"translate3d(\" + translateX + \"px, \" + translateY + \"px,0)\"));\n    gesture.$imageEl.transition(300).transform((\"translate3d(0,0,0) scale(\" + (zoom.scale) + \")\"));\n  },\n  out: function out() {\n    var swiper = this;\n\n    var zoom = swiper.zoom;\n    var params = swiper.params.zoom;\n    var gesture = zoom.gesture;\n\n    if (!gesture.$slideEl) {\n      gesture.$slideEl = swiper.clickedSlide ? $$1(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);\n      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');\n      gesture.$imageWrapEl = gesture.$imageEl.parent((\".\" + (params.containerClass)));\n    }\n    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }\n\n    zoom.scale = 1;\n    zoom.currentScale = 1;\n    gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');\n    gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');\n    gesture.$slideEl.removeClass((\"\" + (params.zoomedSlideClass)));\n    gesture.$slideEl = undefined;\n  },\n  // Attach/Detach Events\n  enable: function enable() {\n    var swiper = this;\n    var zoom = swiper.zoom;\n    if (zoom.enabled) { return; }\n    zoom.enabled = true;\n\n    var slides = swiper.slides;\n\n    var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;\n\n    // Scale image\n    if (Support.gestures) {\n      slides.on('gesturestart', zoom.onGestureStart, passiveListener);\n      slides.on('gesturechange', zoom.onGestureChange, passiveListener);\n      slides.on('gestureend', zoom.onGestureEnd, passiveListener);\n    } else if (swiper.touchEvents.start === 'touchstart') {\n      slides.on(swiper.touchEvents.start, zoom.onGestureStart, passiveListener);\n      slides.on(swiper.touchEvents.move, zoom.onGestureChange, passiveListener);\n      slides.on(swiper.touchEvents.end, zoom.onGestureEnd, passiveListener);\n    }\n\n    // Move image\n    swiper.slides.each(function (index, slideEl) {\n      var $slideEl = $$1(slideEl);\n      if ($slideEl.find((\".\" + (swiper.params.zoom.containerClass))).length > 0) {\n        $slideEl.on(swiper.touchEvents.move, zoom.onTouchMove);\n      }\n    });\n  },\n  disable: function disable() {\n    var swiper = this;\n    var zoom = swiper.zoom;\n    if (!zoom.enabled) { return; }\n\n    swiper.zoom.enabled = false;\n\n    var slides = swiper.slides;\n\n    var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;\n\n    // Scale image\n    if (Support.gestures) {\n      slides.off('gesturestart', zoom.onGestureStart, passiveListener);\n      slides.off('gesturechange', zoom.onGestureChange, passiveListener);\n      slides.off('gestureend', zoom.onGestureEnd, passiveListener);\n    } else if (swiper.touchEvents.start === 'touchstart') {\n      slides.off(swiper.touchEvents.start, zoom.onGestureStart, passiveListener);\n      slides.off(swiper.touchEvents.move, zoom.onGestureChange, passiveListener);\n      slides.off(swiper.touchEvents.end, zoom.onGestureEnd, passiveListener);\n    }\n\n    // Move image\n    swiper.slides.each(function (index, slideEl) {\n      var $slideEl = $$1(slideEl);\n      if ($slideEl.find((\".\" + (swiper.params.zoom.containerClass))).length > 0) {\n        $slideEl.off(swiper.touchEvents.move, zoom.onTouchMove);\n      }\n    });\n  },\n};\n\nvar Zoom$1 = {\n  name: 'zoom',\n  params: {\n    zoom: {\n      enabled: false,\n      maxRatio: 3,\n      minRatio: 1,\n      toggle: true,\n      containerClass: 'swiper-zoom-container',\n      zoomedSlideClass: 'swiper-slide-zoomed',\n    },\n  },\n  create: function create() {\n    var swiper = this;\n    var zoom = {\n      enabled: false,\n      scale: 1,\n      currentScale: 1,\n      isScaling: false,\n      gesture: {\n        $slideEl: undefined,\n        slideWidth: undefined,\n        slideHeight: undefined,\n        $imageEl: undefined,\n        $imageWrapEl: undefined,\n        maxRatio: 3,\n      },\n      image: {\n        isTouched: undefined,\n        isMoved: undefined,\n        currentX: undefined,\n        currentY: undefined,\n        minX: undefined,\n        minY: undefined,\n        maxX: undefined,\n        maxY: undefined,\n        width: undefined,\n        height: undefined,\n        startX: undefined,\n        startY: undefined,\n        touchesStart: {},\n        touchesCurrent: {},\n      },\n      velocity: {\n        x: undefined,\n        y: undefined,\n        prevPositionX: undefined,\n        prevPositionY: undefined,\n        prevTime: undefined,\n      },\n    };\n    ('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach(function (methodName) {\n      zoom[methodName] = Zoom[methodName].bind(swiper);\n    });\n    Utils.extend(swiper, {\n      zoom: zoom,\n    });\n  },\n  on: {\n    init: function init() {\n      var swiper = this;\n      if (swiper.params.zoom.enabled) {\n        swiper.zoom.enable();\n      }\n    },\n    destroy: function destroy() {\n      var swiper = this;\n      swiper.zoom.disable();\n    },\n    touchStart: function touchStart(e) {\n      var swiper = this;\n      if (!swiper.zoom.enabled) { return; }\n      swiper.zoom.onTouchStart(e);\n    },\n    touchEnd: function touchEnd(e) {\n      var swiper = this;\n      if (!swiper.zoom.enabled) { return; }\n      swiper.zoom.onTouchEnd(e);\n    },\n    doubleTap: function doubleTap(e) {\n      var swiper = this;\n      if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\n        swiper.zoom.toggle(e);\n      }\n    },\n    transitionEnd: function transitionEnd() {\n      var swiper = this;\n      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n        swiper.zoom.onTransitionEnd();\n      }\n    },\n  },\n};\n\nvar Lazy = {\n  loadInSlide: function loadInSlide(index, loadInDuplicate) {\n    if ( loadInDuplicate === void 0 ) loadInDuplicate = true;\n\n    var swiper = this;\n    var params = swiper.params.lazy;\n    if (typeof index === 'undefined') { return; }\n    if (swiper.slides.length === 0) { return; }\n    var isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n    var $slideEl = isVirtual\n      ? swiper.$wrapperEl.children((\".\" + (swiper.params.slideClass) + \"[data-swiper-slide-index=\\\"\" + index + \"\\\"]\"))\n      : swiper.slides.eq(index);\n\n    var $images = $slideEl.find((\".\" + (params.elementClass) + \":not(.\" + (params.loadedClass) + \"):not(.\" + (params.loadingClass) + \")\"));\n    if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {\n      $images = $images.add($slideEl[0]);\n    }\n    if ($images.length === 0) { return; }\n\n    $images.each(function (imageIndex, imageEl) {\n      var $imageEl = $$1(imageEl);\n      $imageEl.addClass(params.loadingClass);\n\n      var background = $imageEl.attr('data-background');\n      var src = $imageEl.attr('data-src');\n      var srcset = $imageEl.attr('data-srcset');\n      var sizes = $imageEl.attr('data-sizes');\n\n      swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, function () {\n        if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params) || swiper.destroyed) { return; }\n        if (background) {\n          $imageEl.css('background-image', (\"url(\\\"\" + background + \"\\\")\"));\n          $imageEl.removeAttr('data-background');\n        } else {\n          if (srcset) {\n            $imageEl.attr('srcset', srcset);\n            $imageEl.removeAttr('data-srcset');\n          }\n          if (sizes) {\n            $imageEl.attr('sizes', sizes);\n            $imageEl.removeAttr('data-sizes');\n          }\n          if (src) {\n            $imageEl.attr('src', src);\n            $imageEl.removeAttr('data-src');\n          }\n        }\n\n        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);\n        $slideEl.find((\".\" + (params.preloaderClass))).remove();\n        if (swiper.params.loop && loadInDuplicate) {\n          var slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');\n          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {\n            var originalSlide = swiper.$wrapperEl.children((\"[data-swiper-slide-index=\\\"\" + slideOriginalIndex + \"\\\"]:not(.\" + (swiper.params.slideDuplicateClass) + \")\"));\n            swiper.lazy.loadInSlide(originalSlide.index(), false);\n          } else {\n            var duplicatedSlide = swiper.$wrapperEl.children((\".\" + (swiper.params.slideDuplicateClass) + \"[data-swiper-slide-index=\\\"\" + slideOriginalIndex + \"\\\"]\"));\n            swiper.lazy.loadInSlide(duplicatedSlide.index(), false);\n          }\n        }\n        swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);\n      });\n\n      swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);\n    });\n  },\n  load: function load() {\n    var swiper = this;\n    var $wrapperEl = swiper.$wrapperEl;\n    var swiperParams = swiper.params;\n    var slides = swiper.slides;\n    var activeIndex = swiper.activeIndex;\n    var isVirtual = swiper.virtual && swiperParams.virtual.enabled;\n    var params = swiperParams.lazy;\n\n    var slidesPerView = swiperParams.slidesPerView;\n    if (slidesPerView === 'auto') {\n      slidesPerView = 0;\n    }\n\n    function slideExist(index) {\n      if (isVirtual) {\n        if ($wrapperEl.children((\".\" + (swiperParams.slideClass) + \"[data-swiper-slide-index=\\\"\" + index + \"\\\"]\")).length) {\n          return true;\n        }\n      } else if (slides[index]) { return true; }\n      return false;\n    }\n    function slideIndex(slideEl) {\n      if (isVirtual) {\n        return $$1(slideEl).attr('data-swiper-slide-index');\n      }\n      return $$1(slideEl).index();\n    }\n\n    if (!swiper.lazy.initialImageLoaded) { swiper.lazy.initialImageLoaded = true; }\n    if (swiper.params.watchSlidesVisibility) {\n      $wrapperEl.children((\".\" + (swiperParams.slideVisibleClass))).each(function (elIndex, slideEl) {\n        var index = isVirtual ? $$1(slideEl).attr('data-swiper-slide-index') : $$1(slideEl).index();\n        swiper.lazy.loadInSlide(index);\n      });\n    } else if (slidesPerView > 1) {\n      for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) {\n        if (slideExist(i)) { swiper.lazy.loadInSlide(i); }\n      }\n    } else {\n      swiper.lazy.loadInSlide(activeIndex);\n    }\n    if (params.loadPrevNext) {\n      if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {\n        var amount = params.loadPrevNextAmount;\n        var spv = slidesPerView;\n        var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);\n        var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);\n        // Next Slides\n        for (var i$1 = activeIndex + slidesPerView; i$1 < maxIndex; i$1 += 1) {\n          if (slideExist(i$1)) { swiper.lazy.loadInSlide(i$1); }\n        }\n        // Prev Slides\n        for (var i$2 = minIndex; i$2 < activeIndex; i$2 += 1) {\n          if (slideExist(i$2)) { swiper.lazy.loadInSlide(i$2); }\n        }\n      } else {\n        var nextSlide = $wrapperEl.children((\".\" + (swiperParams.slideNextClass)));\n        if (nextSlide.length > 0) { swiper.lazy.loadInSlide(slideIndex(nextSlide)); }\n\n        var prevSlide = $wrapperEl.children((\".\" + (swiperParams.slidePrevClass)));\n        if (prevSlide.length > 0) { swiper.lazy.loadInSlide(slideIndex(prevSlide)); }\n      }\n    }\n  },\n};\n\nvar Lazy$1 = {\n  name: 'lazy',\n  params: {\n    lazy: {\n      enabled: false,\n      loadPrevNext: false,\n      loadPrevNextAmount: 1,\n      loadOnTransitionStart: false,\n\n      elementClass: 'swiper-lazy',\n      loadingClass: 'swiper-lazy-loading',\n      loadedClass: 'swiper-lazy-loaded',\n      preloaderClass: 'swiper-lazy-preloader',\n    },\n  },\n  create: function create() {\n    var swiper = this;\n    Utils.extend(swiper, {\n      lazy: {\n        initialImageLoaded: false,\n        load: Lazy.load.bind(swiper),\n        loadInSlide: Lazy.loadInSlide.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit: function beforeInit() {\n      var swiper = this;\n      if (swiper.params.lazy.enabled && swiper.params.preloadImages) {\n        swiper.params.preloadImages = false;\n      }\n    },\n    init: function init() {\n      var swiper = this;\n      if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {\n        swiper.lazy.load();\n      }\n    },\n    scroll: function scroll() {\n      var swiper = this;\n      if (swiper.params.freeMode && !swiper.params.freeModeSticky) {\n        swiper.lazy.load();\n      }\n    },\n    resize: function resize() {\n      var swiper = this;\n      if (swiper.params.lazy.enabled) {\n        swiper.lazy.load();\n      }\n    },\n    scrollbarDragMove: function scrollbarDragMove() {\n      var swiper = this;\n      if (swiper.params.lazy.enabled) {\n        swiper.lazy.load();\n      }\n    },\n    transitionStart: function transitionStart() {\n      var swiper = this;\n      if (swiper.params.lazy.enabled) {\n        if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {\n          swiper.lazy.load();\n        }\n      }\n    },\n    transitionEnd: function transitionEnd() {\n      var swiper = this;\n      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {\n        swiper.lazy.load();\n      }\n    },\n  },\n};\n\n/* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\nvar Controller = {\n  LinearSpline: function LinearSpline(x, y) {\n    var binarySearch = (function search() {\n      var maxIndex;\n      var minIndex;\n      var guess;\n      return function (array, val) {\n        minIndex = -1;\n        maxIndex = array.length;\n        while (maxIndex - minIndex > 1) {\n          guess = maxIndex + minIndex >> 1;\n          if (array[guess] <= val) {\n            minIndex = guess;\n          } else {\n            maxIndex = guess;\n          }\n        }\n        return maxIndex;\n      };\n    }());\n    this.x = x;\n    this.y = y;\n    this.lastIndex = x.length - 1;\n    // Given an x value (x2), return the expected y2 value:\n    // (x1,y1) is the known point before given value,\n    // (x3,y3) is the known point after given value.\n    var i1;\n    var i3;\n\n    this.interpolate = function interpolate(x2) {\n      if (!x2) { return 0; }\n\n      // Get the indexes of x1 and x3 (the array indexes before and after given x2):\n      i3 = binarySearch(this.x, x2);\n      i1 = i3 - 1;\n\n      // We have our indexes i1 & i3, so we can calculate already:\n      // y2 := ((x2x1)  (y3y1))  (x3x1) + y1\n      return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];\n    };\n    return this;\n  },\n  // xxx: for now i will just save one spline function to to\n  getInterpolateFunction: function getInterpolateFunction(c) {\n    var swiper = this;\n    if (!swiper.controller.spline) {\n      swiper.controller.spline = swiper.params.loop ?\n        new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid) :\n        new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);\n    }\n  },\n  setTranslate: function setTranslate(setTranslate$1, byController) {\n    var swiper = this;\n    var controlled = swiper.controller.control;\n    var multiplier;\n    var controlledTranslate;\n    function setControlledTranslate(c) {\n      // this will create an Interpolate function based on the snapGrids\n      // x is the Grid of the scrolled scroller and y will be the controlled scroller\n      // it makes sense to create this only once and recall it for the interpolation\n      // the function does a lot of value caching for performance\n      var translate = c.rtl && c.params.direction === 'horizontal' ? -swiper.translate : swiper.translate;\n      if (swiper.params.controller.by === 'slide') {\n        swiper.controller.getInterpolateFunction(c);\n        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n        // but it did not work out\n        controlledTranslate = -swiper.controller.spline.interpolate(-translate);\n      }\n\n      if (!controlledTranslate || swiper.params.controller.by === 'container') {\n        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n        controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();\n      }\n\n      if (swiper.params.controller.inverse) {\n        controlledTranslate = c.maxTranslate() - controlledTranslate;\n      }\n      c.updateProgress(controlledTranslate);\n      c.setTranslate(controlledTranslate, swiper);\n      c.updateActiveIndex();\n      c.updateSlidesClasses();\n    }\n    if (Array.isArray(controlled)) {\n      for (var i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper$1) {\n          setControlledTranslate(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper$1 && byController !== controlled) {\n      setControlledTranslate(controlled);\n    }\n  },\n  setTransition: function setTransition(duration, byController) {\n    var swiper = this;\n    var controlled = swiper.controller.control;\n    var i;\n    function setControlledTransition(c) {\n      c.setTransition(duration, swiper);\n      if (duration !== 0) {\n        c.transitionStart();\n        c.$wrapperEl.transitionEnd(function () {\n          if (!controlled) { return; }\n          if (c.params.loop && swiper.params.controller.by === 'slide') {\n            c.loopFix();\n          }\n          c.transitionEnd();\n        });\n      }\n    }\n    if (Array.isArray(controlled)) {\n      for (i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper$1) {\n          setControlledTransition(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper$1 && byController !== controlled) {\n      setControlledTransition(controlled);\n    }\n  },\n};\nvar Controller$1 = {\n  name: 'controller',\n  params: {\n    controller: {\n      control: undefined,\n      inverse: false,\n      by: 'slide', // or 'container'\n    },\n  },\n  create: function create() {\n    var swiper = this;\n    Utils.extend(swiper, {\n      controller: {\n        control: swiper.params.controller.control,\n        getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),\n        setTranslate: Controller.setTranslate.bind(swiper),\n        setTransition: Controller.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    update: function update() {\n      var swiper = this;\n      if (!swiper.controller.control) { return; }\n      if (swiper.controller.spline) {\n        swiper.controller.spline = undefined;\n        delete swiper.controller.spline;\n      }\n    },\n    resize: function resize() {\n      var swiper = this;\n      if (!swiper.controller.control) { return; }\n      if (swiper.controller.spline) {\n        swiper.controller.spline = undefined;\n        delete swiper.controller.spline;\n      }\n    },\n    observerUpdate: function observerUpdate() {\n      var swiper = this;\n      if (!swiper.controller.control) { return; }\n      if (swiper.controller.spline) {\n        swiper.controller.spline = undefined;\n        delete swiper.controller.spline;\n      }\n    },\n    setTranslate: function setTranslate(translate, byController) {\n      var swiper = this;\n      if (!swiper.controller.control) { return; }\n      swiper.controller.setTranslate(translate, byController);\n    },\n    setTransition: function setTransition(duration, byController) {\n      var swiper = this;\n      if (!swiper.controller.control) { return; }\n      swiper.controller.setTransition(duration, byController);\n    },\n  },\n};\n\nvar a11y = {\n  makeElFocusable: function makeElFocusable($el) {\n    $el.attr('tabIndex', '0');\n    return $el;\n  },\n  addElRole: function addElRole($el, role) {\n    $el.attr('role', role);\n    return $el;\n  },\n  addElLabel: function addElLabel($el, label) {\n    $el.attr('aria-label', label);\n    return $el;\n  },\n  disableEl: function disableEl($el) {\n    $el.attr('aria-disabled', true);\n    return $el;\n  },\n  enableEl: function enableEl($el) {\n    $el.attr('aria-disabled', false);\n    return $el;\n  },\n  onEnterKey: function onEnterKey(e) {\n    var swiper = this;\n    var params = swiper.params.a11y;\n    if (e.keyCode !== 13) { return; }\n    var $targetEl = $$1(e.target);\n    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {\n      if (!(swiper.isEnd && !swiper.params.loop)) {\n        swiper.slideNext();\n      }\n      if (swiper.isEnd) {\n        swiper.a11y.notify(params.lastSlideMessage);\n      } else {\n        swiper.a11y.notify(params.nextSlideMessage);\n      }\n    }\n    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {\n      if (!(swiper.isBeginning && !swiper.params.loop)) {\n        swiper.slidePrev();\n      }\n      if (swiper.isBeginning) {\n        swiper.a11y.notify(params.firstSlideMessage);\n      } else {\n        swiper.a11y.notify(params.prevSlideMessage);\n      }\n    }\n    if (swiper.pagination && $targetEl.is((\".\" + (swiper.params.pagination.bulletClass)))) {\n      $targetEl[0].click();\n    }\n  },\n  notify: function notify(message) {\n    var swiper = this;\n    var notification = swiper.a11y.liveRegion;\n    if (notification.length === 0) { return; }\n    notification.html('');\n    notification.html(message);\n  },\n  updateNavigation: function updateNavigation() {\n    var swiper = this;\n\n    if (swiper.params.loop) { return; }\n    var ref = swiper.navigation;\n    var $nextEl = ref.$nextEl;\n    var $prevEl = ref.$prevEl;\n\n    if ($prevEl && $prevEl.length > 0) {\n      if (swiper.isBeginning) {\n        swiper.a11y.disableEl($prevEl);\n      } else {\n        swiper.a11y.enableEl($prevEl);\n      }\n    }\n    if ($nextEl && $nextEl.length > 0) {\n      if (swiper.isEnd) {\n        swiper.a11y.disableEl($nextEl);\n      } else {\n        swiper.a11y.enableEl($nextEl);\n      }\n    }\n  },\n  updatePagination: function updatePagination() {\n    var swiper = this;\n    var params = swiper.params.a11y;\n    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {\n      swiper.pagination.bullets.each(function (bulletIndex, bulletEl) {\n        var $bulletEl = $$1(bulletEl);\n        swiper.a11y.makeElFocusable($bulletEl);\n        swiper.a11y.addElRole($bulletEl, 'button');\n        swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1));\n      });\n    }\n  },\n  init: function init() {\n    var swiper = this;\n\n    swiper.$el.append(swiper.a11y.liveRegion);\n\n    // Navigation\n    var params = swiper.params.a11y;\n    var $nextEl;\n    var $prevEl;\n    if (swiper.navigation && swiper.navigation.$nextEl) {\n      $nextEl = swiper.navigation.$nextEl;\n    }\n    if (swiper.navigation && swiper.navigation.$prevEl) {\n      $prevEl = swiper.navigation.$prevEl;\n    }\n    if ($nextEl) {\n      swiper.a11y.makeElFocusable($nextEl);\n      swiper.a11y.addElRole($nextEl, 'button');\n      swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);\n      $nextEl.on('keydown', swiper.a11y.onEnterKey);\n    }\n    if ($prevEl) {\n      swiper.a11y.makeElFocusable($prevEl);\n      swiper.a11y.addElRole($prevEl, 'button');\n      swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);\n      $prevEl.on('keydown', swiper.a11y.onEnterKey);\n    }\n\n    // Pagination\n    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {\n      swiper.pagination.$el.on('keydown', (\".\" + (swiper.params.pagination.bulletClass)), swiper.a11y.onEnterKey);\n    }\n  },\n  destroy: function destroy() {\n    var swiper = this;\n    if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) { swiper.a11y.liveRegion.remove(); }\n\n    var $nextEl;\n    var $prevEl;\n    if (swiper.navigation && swiper.navigation.$nextEl) {\n      $nextEl = swiper.navigation.$nextEl;\n    }\n    if (swiper.navigation && swiper.navigation.$prevEl) {\n      $prevEl = swiper.navigation.$prevEl;\n    }\n    if ($nextEl) {\n      $nextEl.off('keydown', swiper.a11y.onEnterKey);\n    }\n    if ($prevEl) {\n      $prevEl.off('keydown', swiper.a11y.onEnterKey);\n    }\n\n    // Pagination\n    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {\n      swiper.pagination.$el.off('keydown', (\".\" + (swiper.params.pagination.bulletClass)), swiper.a11y.onEnterKey);\n    }\n  },\n};\nvar A11y = {\n  name: 'a11y',\n  params: {\n    a11y: {\n      enabled: false,\n      notificationClass: 'swiper-notification',\n      prevSlideMessage: 'Previous slide',\n      nextSlideMessage: 'Next slide',\n      firstSlideMessage: 'This is the first slide',\n      lastSlideMessage: 'This is the last slide',\n      paginationBulletMessage: 'Go to slide {{index}}',\n    },\n  },\n  create: function create() {\n    var swiper = this;\n    Utils.extend(swiper, {\n      a11y: {\n        liveRegion: $$1((\"<span class=\\\"\" + (swiper.params.a11y.notificationClass) + \"\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\"></span>\")),\n      },\n    });\n    Object.keys(a11y).forEach(function (methodName) {\n      swiper.a11y[methodName] = a11y[methodName].bind(swiper);\n    });\n  },\n  on: {\n    init: function init() {\n      var swiper = this;\n      if (!swiper.params.a11y.enabled) { return; }\n      swiper.a11y.init();\n      swiper.a11y.updateNavigation();\n    },\n    toEdge: function toEdge() {\n      var swiper = this;\n      if (!swiper.params.a11y.enabled) { return; }\n      swiper.a11y.updateNavigation();\n    },\n    fromEdge: function fromEdge() {\n      var swiper = this;\n      if (!swiper.params.a11y.enabled) { return; }\n      swiper.a11y.updateNavigation();\n    },\n    paginationUpdate: function paginationUpdate() {\n      var swiper = this;\n      if (!swiper.params.a11y.enabled) { return; }\n      swiper.a11y.updatePagination();\n    },\n    destroy: function destroy() {\n      var swiper = this;\n      if (!swiper.params.a11y.enabled) { return; }\n      swiper.a11y.destroy();\n    },\n  },\n};\n\nvar History = {\n  init: function init() {\n    var swiper = this;\n    if (!swiper.params.history) { return; }\n    if (!win.history || !win.history.pushState) {\n      swiper.params.history.enabled = false;\n      swiper.params.hashNavigation.enabled = true;\n      return;\n    }\n    var history = swiper.history;\n    history.initialized = true;\n    history.paths = History.getPathValues();\n    if (!history.paths.key && !history.paths.value) { return; }\n    history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);\n    if (!swiper.params.history.replaceState) {\n      win.addEventListener('popstate', swiper.history.setHistoryPopState);\n    }\n  },\n  destroy: function destroy() {\n    var swiper = this;\n    if (!swiper.params.history.replaceState) {\n      win.removeEventListener('popstate', swiper.history.setHistoryPopState);\n    }\n  },\n  setHistoryPopState: function setHistoryPopState() {\n    var swiper = this;\n    swiper.history.paths = History.getPathValues();\n    swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);\n  },\n  getPathValues: function getPathValues() {\n    var pathArray = win.location.pathname.slice(1).split('/').filter(function (part) { return part !== ''; });\n    var total = pathArray.length;\n    var key = pathArray[total - 2];\n    var value = pathArray[total - 1];\n    return { key: key, value: value };\n  },\n  setHistory: function setHistory(key, index) {\n    var swiper = this;\n    if (!swiper.history.initialized || !swiper.params.history.enabled) { return; }\n    var slide = swiper.slides.eq(index);\n    var value = History.slugify(slide.attr('data-history'));\n    if (!win.location.pathname.includes(key)) {\n      value = key + \"/\" + value;\n    }\n    var currentState = win.history.state;\n    if (currentState && currentState.value === value) {\n      return;\n    }\n    if (swiper.params.history.replaceState) {\n      win.history.replaceState({ value: value }, null, value);\n    } else {\n      win.history.pushState({ value: value }, null, value);\n    }\n  },\n  slugify: function slugify(text) {\n    return text.toString().toLowerCase()\n      .replace(/\\s+/g, '-')\n      .replace(/[^\\w-]+/g, '')\n      .replace(/--+/g, '-')\n      .replace(/^-+/, '')\n      .replace(/-+$/, '');\n  },\n  scrollToSlide: function scrollToSlide(speed, value, runCallbacks) {\n    var swiper = this;\n    if (value) {\n      for (var i = 0, length = swiper.slides.length; i < length; i += 1) {\n        var slide = swiper.slides.eq(i);\n        var slideHistory = History.slugify(slide.attr('data-history'));\n        if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {\n          var index = slide.index();\n          swiper.slideTo(index, speed, runCallbacks);\n        }\n      }\n    } else {\n      swiper.slideTo(0, speed, runCallbacks);\n    }\n  },\n};\n\nvar History$1 = {\n  name: 'history',\n  params: {\n    history: {\n      enabled: false,\n      replaceState: false,\n      key: 'slides',\n    },\n  },\n  create: function create() {\n    var swiper = this;\n    Utils.extend(swiper, {\n      history: {\n        init: History.init.bind(swiper),\n        setHistory: History.setHistory.bind(swiper),\n        setHistoryPopState: History.setHistoryPopState.bind(swiper),\n        scrollToSlide: History.scrollToSlide.bind(swiper),\n        destroy: History.destroy.bind(swiper),\n      },\n    });\n  },\n  on: {\n    init: function init() {\n      var swiper = this;\n      if (swiper.params.history.enabled) {\n        swiper.history.init();\n      }\n    },\n    destroy: function destroy() {\n      var swiper = this;\n      if (swiper.params.history.enabled) {\n        swiper.history.destroy();\n      }\n    },\n    transitionEnd: function transitionEnd() {\n      var swiper = this;\n      if (swiper.history.initialized) {\n        swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);\n      }\n    },\n  },\n};\n\nvar HashNavigation = {\n  onHashCange: function onHashCange() {\n    var swiper = this;\n    var newHash = doc.location.hash.replace('#', '');\n    var activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');\n    if (newHash !== activeSlideHash) {\n      swiper.slideTo(swiper.$wrapperEl.children((\".\" + (swiper.params.slideClass) + \"[data-hash=\\\"\" + newHash + \"\\\"]\")).index());\n    }\n  },\n  setHash: function setHash() {\n    var swiper = this;\n    if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) { return; }\n    if (swiper.params.hashNavigation.replaceState && win.history && win.history.replaceState) {\n      win.history.replaceState(null, null, ((\"#\" + (swiper.slides.eq(swiper.activeIndex).attr('data-hash'))) || ''));\n    } else {\n      var slide = swiper.slides.eq(swiper.activeIndex);\n      var hash = slide.attr('data-hash') || slide.attr('data-history');\n      doc.location.hash = hash || '';\n    }\n  },\n  init: function init() {\n    var swiper = this;\n    if (!swiper.params.hashNavigation.enabled || (swiper.params.history && swiper.params.history.enabled)) { return; }\n    swiper.hashNavigation.initialized = true;\n    var hash = doc.location.hash.replace('#', '');\n    if (hash) {\n      var speed = 0;\n      for (var i = 0, length = swiper.slides.length; i < length; i += 1) {\n        var slide = swiper.slides.eq(i);\n        var slideHash = slide.attr('data-hash') || slide.attr('data-history');\n        if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {\n          var index = slide.index();\n          swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);\n        }\n      }\n    }\n    if (swiper.params.hashNavigation.watchState) {\n      $$1(win).on('hashchange', swiper.hashNavigation.onHashCange);\n    }\n  },\n  destroy: function destroy() {\n    var swiper = this;\n    if (swiper.params.hashNavigation.watchState) {\n      $$1(win).off('hashchange', swiper.hashNavigation.onHashCange);\n    }\n  },\n};\nvar HashNavigation$1 = {\n  name: 'hash-navigation',\n  params: {\n    hashNavigation: {\n      enabled: false,\n      replaceState: false,\n      watchState: false,\n    },\n  },\n  create: function create() {\n    var swiper = this;\n    Utils.extend(swiper, {\n      hashNavigation: {\n        initialized: false,\n        init: HashNavigation.init.bind(swiper),\n        destroy: HashNavigation.destroy.bind(swiper),\n        setHash: HashNavigation.setHash.bind(swiper),\n        onHashCange: HashNavigation.onHashCange.bind(swiper),\n      },\n    });\n  },\n  on: {\n    init: function init() {\n      var swiper = this;\n      if (swiper.params.hashNavigation.enabled) {\n        swiper.hashNavigation.init();\n      }\n    },\n    destroy: function destroy() {\n      var swiper = this;\n      if (swiper.params.hashNavigation.enabled) {\n        swiper.hashNavigation.destroy();\n      }\n    },\n    transitionEnd: function transitionEnd() {\n      var swiper = this;\n      if (swiper.hashNavigation.initialized) {\n        swiper.hashNavigation.setHash();\n      }\n    },\n  },\n};\n\nvar Autoplay = {\n  run: function run() {\n    var swiper = this;\n    var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);\n    var delay = swiper.params.autoplay.delay;\n    if ($activeSlideEl.attr('data-swiper-autoplay')) {\n      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;\n    }\n    swiper.autoplay.timeout = Utils.nextTick(function () {\n      if (swiper.params.loop) {\n        swiper.loopFix();\n        swiper.slideNext(swiper.params.speed, true, true);\n        swiper.emit('autoplay');\n      } else if (!swiper.isEnd) {\n        swiper.slideNext(swiper.params.speed, true, true);\n        swiper.emit('autoplay');\n      } else if (!swiper.params.autoplay.stopOnLastSlide) {\n        swiper.slideTo(0, swiper.params.speed, true, true);\n        swiper.emit('autoplay');\n      } else {\n        swiper.autoplay.stop();\n      }\n    }, delay);\n  },\n  start: function start() {\n    var swiper = this;\n    if (typeof swiper.autoplay.timeout !== 'undefined') { return false; }\n    if (swiper.autoplay.running) { return false; }\n    swiper.autoplay.running = true;\n    swiper.emit('autoplayStart');\n    swiper.autoplay.run();\n    return true;\n  },\n  stop: function stop() {\n    var swiper = this;\n    if (!swiper.autoplay.running) { return false; }\n    if (typeof swiper.autoplay.timeout === 'undefined') { return false; }\n\n    if (swiper.autoplay.timeout) {\n      clearTimeout(swiper.autoplay.timeout);\n      swiper.autoplay.timeout = undefined;\n    }\n    swiper.autoplay.running = false;\n    swiper.emit('autoplayStop');\n    return true;\n  },\n  pause: function pause(speed) {\n    var swiper = this;\n    if (!swiper.autoplay.running) { return; }\n    if (swiper.autoplay.paused) { return; }\n    if (swiper.autoplay.timeout) { clearTimeout(swiper.autoplay.timeout); }\n    swiper.autoplay.paused = true;\n    if (speed === 0) {\n      swiper.autoplay.paused = false;\n      swiper.autoplay.run();\n    } else {\n      swiper.$wrapperEl.transitionEnd(function () {\n        if (!swiper || swiper.destroyed) { return; }\n        swiper.autoplay.paused = false;\n        if (!swiper.autoplay.running) {\n          swiper.autoplay.stop();\n        } else {\n          swiper.autoplay.run();\n        }\n      });\n    }\n  },\n};\n\nvar Autoplay$1 = {\n  name: 'autoplay',\n  params: {\n    autoplay: {\n      enabled: false,\n      delay: 3000,\n      disableOnInteraction: true,\n      stopOnLastSlide: false,\n    },\n  },\n  create: function create() {\n    var swiper = this;\n    Utils.extend(swiper, {\n      autoplay: {\n        running: false,\n        paused: false,\n        run: Autoplay.run.bind(swiper),\n        start: Autoplay.start.bind(swiper),\n        stop: Autoplay.stop.bind(swiper),\n        pause: Autoplay.pause.bind(swiper),\n      },\n    });\n  },\n  on: {\n    init: function init() {\n      var swiper = this;\n      if (swiper.params.autoplay.enabled) {\n        swiper.autoplay.start();\n      }\n    },\n    beforeTransitionStart: function beforeTransitionStart(speed, internal) {\n      var swiper = this;\n      if (swiper.autoplay.running) {\n        if (internal || !swiper.params.autoplay.disableOnInteraction) {\n          swiper.autoplay.pause(speed);\n        } else {\n          swiper.autoplay.stop();\n        }\n      }\n    },\n    sliderFirstMove: function sliderFirstMove() {\n      var swiper = this;\n      if (swiper.autoplay.running) {\n        if (swiper.params.autoplay.disableOnInteraction) {\n          swiper.autoplay.stop();\n        } else {\n          swiper.autoplay.pause();\n        }\n      }\n    },\n    destroy: function destroy() {\n      var swiper = this;\n      if (swiper.autoplay.running) {\n        swiper.autoplay.stop();\n      }\n    },\n  },\n};\n\nvar Fade = {\n  setTranslate: function setTranslate() {\n    var swiper = this;\n    var slides = swiper.slides;\n    for (var i = 0; i < slides.length; i += 1) {\n      var $slideEl = swiper.slides.eq(i);\n      var offset = $slideEl[0].swiperSlideOffset;\n      var tx = -offset;\n      if (!swiper.params.virtualTranslate) { tx -= swiper.translate; }\n      var ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n      }\n      var slideOpacity = swiper.params.fadeEffect.crossFade ?\n        Math.max(1 - Math.abs($slideEl[0].progress), 0) :\n        1 + Math.min(Math.max($slideEl[0].progress, -1), 0);\n      $slideEl\n        .css({\n          opacity: slideOpacity,\n        })\n        .transform((\"translate3d(\" + tx + \"px, \" + ty + \"px, 0px)\"));\n    }\n  },\n  setTransition: function setTransition(duration) {\n    var swiper = this;\n    var slides = swiper.slides;\n    var $wrapperEl = swiper.$wrapperEl;\n    slides.transition(duration);\n    if (swiper.params.virtualTranslate && duration !== 0) {\n      var eventTriggered = false;\n      slides.transitionEnd(function () {\n        if (eventTriggered) { return; }\n        if (!swiper || swiper.destroyed) { return; }\n        eventTriggered = true;\n        swiper.animating = false;\n        var triggerEvents = ['webkitTransitionEnd', 'transitionend'];\n        for (var i = 0; i < triggerEvents.length; i += 1) {\n          $wrapperEl.trigger(triggerEvents[i]);\n        }\n      });\n    }\n  },\n};\n\nvar EffectFade = {\n  name: 'effect-fade',\n  params: {\n    fadeEffect: {\n      crossFade: false,\n    },\n  },\n  create: function create() {\n    var swiper = this;\n    Utils.extend(swiper, {\n      fadeEffect: {\n        setTranslate: Fade.setTranslate.bind(swiper),\n        setTransition: Fade.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit: function beforeInit() {\n      var swiper = this;\n      if (swiper.params.effect !== 'fade') { return; }\n      swiper.classNames.push(((swiper.params.containerModifierClass) + \"fade\"));\n      var overwriteParams = {\n        slidesPerView: 1,\n        slidesPerColumn: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        spaceBetween: 0,\n        virtualTranslate: true,\n      };\n      Utils.extend(swiper.params, overwriteParams);\n      Utils.extend(swiper.originalParams, overwriteParams);\n    },\n    setTranslate: function setTranslate() {\n      var swiper = this;\n      if (swiper.params.effect !== 'fade') { return; }\n      swiper.fadeEffect.setTranslate();\n    },\n    setTransition: function setTransition(duration) {\n      var swiper = this;\n      if (swiper.params.effect !== 'fade') { return; }\n      swiper.fadeEffect.setTransition(duration);\n    },\n  },\n};\n\nvar Cube = {\n  setTranslate: function setTranslate() {\n    var swiper = this;\n    var $el = swiper.$el;\n    var $wrapperEl = swiper.$wrapperEl;\n    var slides = swiper.slides;\n    var swiperWidth = swiper.width;\n    var swiperHeight = swiper.height;\n    var rtl = swiper.rtl;\n    var swiperSize = swiper.size;\n    var params = swiper.params.cubeEffect;\n    var isHorizontal = swiper.isHorizontal();\n    var isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n    var wrapperRotate = 0;\n    var $cubeShadowEl;\n    if (params.shadow) {\n      if (isHorizontal) {\n        $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');\n        if ($cubeShadowEl.length === 0) {\n          $cubeShadowEl = $$1('<div class=\"swiper-cube-shadow\"></div>');\n          $wrapperEl.append($cubeShadowEl);\n        }\n        $cubeShadowEl.css({ height: (swiperWidth + \"px\") });\n      } else {\n        $cubeShadowEl = $el.find('.swiper-cube-shadow');\n        if ($cubeShadowEl.length === 0) {\n          $cubeShadowEl = $$1('<div class=\"swiper-cube-shadow\"></div>');\n          $el.append($cubeShadowEl);\n        }\n      }\n    }\n    for (var i = 0; i < slides.length; i += 1) {\n      var $slideEl = slides.eq(i);\n      var slideIndex = i;\n      if (isVirtual) {\n        slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);\n      }\n      var slideAngle = slideIndex * 90;\n      var round = Math.floor(slideAngle / 360);\n      if (rtl) {\n        slideAngle = -slideAngle;\n        round = Math.floor(-slideAngle / 360);\n      }\n      var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);\n      var tx = 0;\n      var ty = 0;\n      var tz = 0;\n      if (slideIndex % 4 === 0) {\n        tx = -round * 4 * swiperSize;\n        tz = 0;\n      } else if ((slideIndex - 1) % 4 === 0) {\n        tx = 0;\n        tz = -round * 4 * swiperSize;\n      } else if ((slideIndex - 2) % 4 === 0) {\n        tx = swiperSize + (round * 4 * swiperSize);\n        tz = swiperSize;\n      } else if ((slideIndex - 3) % 4 === 0) {\n        tx = -swiperSize;\n        tz = (3 * swiperSize) + (swiperSize * 4 * round);\n      }\n      if (rtl) {\n        tx = -tx;\n      }\n\n      if (!isHorizontal) {\n        ty = tx;\n        tx = 0;\n      }\n\n      var transform = \"rotateX(\" + (isHorizontal ? 0 : -slideAngle) + \"deg) rotateY(\" + (isHorizontal ? slideAngle : 0) + \"deg) translate3d(\" + tx + \"px, \" + ty + \"px, \" + tz + \"px)\";\n      if (progress <= 1 && progress > -1) {\n        wrapperRotate = (slideIndex * 90) + (progress * 90);\n        if (rtl) { wrapperRotate = (-slideIndex * 90) - (progress * 90); }\n      }\n      $slideEl.transform(transform);\n      if (params.slideShadows) {\n        // Set shadows\n        var shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');\n        var shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');\n        if (shadowBefore.length === 0) {\n          shadowBefore = $$1((\"<div class=\\\"swiper-slide-shadow-\" + (isHorizontal ? 'left' : 'top') + \"\\\"></div>\"));\n          $slideEl.append(shadowBefore);\n        }\n        if (shadowAfter.length === 0) {\n          shadowAfter = $$1((\"<div class=\\\"swiper-slide-shadow-\" + (isHorizontal ? 'right' : 'bottom') + \"\\\"></div>\"));\n          $slideEl.append(shadowAfter);\n        }\n        if (shadowBefore.length) { shadowBefore[0].style.opacity = Math.max(-progress, 0); }\n        if (shadowAfter.length) { shadowAfter[0].style.opacity = Math.max(progress, 0); }\n      }\n    }\n    $wrapperEl.css({\n      '-webkit-transform-origin': (\"50% 50% -\" + (swiperSize / 2) + \"px\"),\n      '-moz-transform-origin': (\"50% 50% -\" + (swiperSize / 2) + \"px\"),\n      '-ms-transform-origin': (\"50% 50% -\" + (swiperSize / 2) + \"px\"),\n      'transform-origin': (\"50% 50% -\" + (swiperSize / 2) + \"px\"),\n    });\n\n    if (params.shadow) {\n      if (isHorizontal) {\n        $cubeShadowEl.transform((\"translate3d(0px, \" + ((swiperWidth / 2) + params.shadowOffset) + \"px, \" + (-swiperWidth / 2) + \"px) rotateX(90deg) rotateZ(0deg) scale(\" + (params.shadowScale) + \")\"));\n      } else {\n        var shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);\n        var multiplier = 1.5 - (\n          (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2) +\n          (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2)\n        );\n        var scale1 = params.shadowScale;\n        var scale2 = params.shadowScale / multiplier;\n        var offset = params.shadowOffset;\n        $cubeShadowEl.transform((\"scale3d(\" + scale1 + \", 1, \" + scale2 + \") translate3d(0px, \" + ((swiperHeight / 2) + offset) + \"px, \" + (-swiperHeight / 2 / scale2) + \"px) rotateX(-90deg)\"));\n      }\n    }\n    var zFactor = (Browser.isSafari || Browser.isUiWebView) ? (-swiperSize / 2) : 0;\n    $wrapperEl\n      .transform((\"translate3d(0px,0,\" + zFactor + \"px) rotateX(\" + (swiper.isHorizontal() ? 0 : wrapperRotate) + \"deg) rotateY(\" + (swiper.isHorizontal() ? -wrapperRotate : 0) + \"deg)\"));\n  },\n  setTransition: function setTransition(duration) {\n    var swiper = this;\n    var $el = swiper.$el;\n    var slides = swiper.slides;\n    slides\n      .transition(duration)\n      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')\n      .transition(duration);\n    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n      $el.find('.swiper-cube-shadow').transition(duration);\n    }\n  },\n};\n\nvar EffectCube = {\n  name: 'effect-cube',\n  params: {\n    cubeEffect: {\n      slideShadows: true,\n      shadow: true,\n      shadowOffset: 20,\n      shadowScale: 0.94,\n    },\n  },\n  create: function create() {\n    var swiper = this;\n    Utils.extend(swiper, {\n      cubeEffect: {\n        setTranslate: Cube.setTranslate.bind(swiper),\n        setTransition: Cube.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit: function beforeInit() {\n      var swiper = this;\n      if (swiper.params.effect !== 'cube') { return; }\n      swiper.classNames.push(((swiper.params.containerModifierClass) + \"cube\"));\n      swiper.classNames.push(((swiper.params.containerModifierClass) + \"3d\"));\n      var overwriteParams = {\n        slidesPerView: 1,\n        slidesPerColumn: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        resistanceRatio: 0,\n        spaceBetween: 0,\n        centeredSlides: false,\n        virtualTranslate: true,\n      };\n      Utils.extend(swiper.params, overwriteParams);\n      Utils.extend(swiper.originalParams, overwriteParams);\n    },\n    setTranslate: function setTranslate() {\n      var swiper = this;\n      if (swiper.params.effect !== 'cube') { return; }\n      swiper.cubeEffect.setTranslate();\n    },\n    setTransition: function setTransition(duration) {\n      var swiper = this;\n      if (swiper.params.effect !== 'cube') { return; }\n      swiper.cubeEffect.setTransition(duration);\n    },\n  },\n};\n\nvar Flip = {\n  setTranslate: function setTranslate() {\n    var swiper = this;\n    var slides = swiper.slides;\n    for (var i = 0; i < slides.length; i += 1) {\n      var $slideEl = slides.eq(i);\n      var progress = $slideEl[0].progress;\n      if (swiper.params.flipEffect.limitRotation) {\n        progress = Math.max(Math.min($slideEl[0].progress, 1), -1);\n      }\n      var offset = $slideEl[0].swiperSlideOffset;\n      var rotate = -180 * progress;\n      var rotateY = rotate;\n      var rotateX = 0;\n      var tx = -offset;\n      var ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n        rotateX = -rotateY;\n        rotateY = 0;\n      } else if (swiper.rtl) {\n        rotateY = -rotateY;\n      }\n\n      $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n\n      if (swiper.params.flipEffect.slideShadows) {\n        // Set shadows\n        var shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');\n        var shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');\n        if (shadowBefore.length === 0) {\n          shadowBefore = $$1((\"<div class=\\\"swiper-slide-shadow-\" + (swiper.isHorizontal() ? 'left' : 'top') + \"\\\"></div>\"));\n          $slideEl.append(shadowBefore);\n        }\n        if (shadowAfter.length === 0) {\n          shadowAfter = $$1((\"<div class=\\\"swiper-slide-shadow-\" + (swiper.isHorizontal() ? 'right' : 'bottom') + \"\\\"></div>\"));\n          $slideEl.append(shadowAfter);\n        }\n        if (shadowBefore.length) { shadowBefore[0].style.opacity = Math.max(-progress, 0); }\n        if (shadowAfter.length) { shadowAfter[0].style.opacity = Math.max(progress, 0); }\n      }\n      $slideEl\n        .transform((\"translate3d(\" + tx + \"px, \" + ty + \"px, 0px) rotateX(\" + rotateX + \"deg) rotateY(\" + rotateY + \"deg)\"));\n    }\n  },\n  setTransition: function setTransition(duration) {\n    var swiper = this;\n    var slides = swiper.slides;\n    var activeIndex = swiper.activeIndex;\n    var $wrapperEl = swiper.$wrapperEl;\n    slides\n      .transition(duration)\n      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')\n      .transition(duration);\n    if (swiper.params.virtualTranslate && duration !== 0) {\n      var eventTriggered = false;\n      // eslint-disable-next-line\n      slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {\n        if (eventTriggered) { return; }\n        if (!swiper || swiper.destroyed) { return; }\n        // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;\n        eventTriggered = true;\n        swiper.animating = false;\n        var triggerEvents = ['webkitTransitionEnd', 'transitionend'];\n        for (var i = 0; i < triggerEvents.length; i += 1) {\n          $wrapperEl.trigger(triggerEvents[i]);\n        }\n      });\n    }\n  },\n};\n\nvar EffectFlip = {\n  name: 'effect-flip',\n  params: {\n    flipEffect: {\n      slideShadows: true,\n      limitRotation: true,\n    },\n  },\n  create: function create() {\n    var swiper = this;\n    Utils.extend(swiper, {\n      flipEffect: {\n        setTranslate: Flip.setTranslate.bind(swiper),\n        setTransition: Flip.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit: function beforeInit() {\n      var swiper = this;\n      if (swiper.params.effect !== 'flip') { return; }\n      swiper.classNames.push(((swiper.params.containerModifierClass) + \"flip\"));\n      swiper.classNames.push(((swiper.params.containerModifierClass) + \"3d\"));\n      var overwriteParams = {\n        slidesPerView: 1,\n        slidesPerColumn: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        spaceBetween: 0,\n        virtualTranslate: true,\n      };\n      Utils.extend(swiper.params, overwriteParams);\n      Utils.extend(swiper.originalParams, overwriteParams);\n    },\n    setTranslate: function setTranslate() {\n      var swiper = this;\n      if (swiper.params.effect !== 'flip') { return; }\n      swiper.flipEffect.setTranslate();\n    },\n    setTransition: function setTransition(duration) {\n      var swiper = this;\n      if (swiper.params.effect !== 'flip') { return; }\n      swiper.flipEffect.setTransition(duration);\n    },\n  },\n};\n\nvar Coverflow = {\n  setTranslate: function setTranslate() {\n    var swiper = this;\n    var swiperWidth = swiper.width;\n    var swiperHeight = swiper.height;\n    var slides = swiper.slides;\n    var $wrapperEl = swiper.$wrapperEl;\n    var slidesSizesGrid = swiper.slidesSizesGrid;\n    var params = swiper.params.coverflowEffect;\n    var isHorizontal = swiper.isHorizontal();\n    var transform = swiper.translate;\n    var center = isHorizontal ? -transform + (swiperWidth / 2) : -transform + (swiperHeight / 2);\n    var rotate = isHorizontal ? params.rotate : -params.rotate;\n    var translate = params.depth;\n    // Each slide offset from center\n    for (var i = 0, length = slides.length; i < length; i += 1) {\n      var $slideEl = slides.eq(i);\n      var slideSize = slidesSizesGrid[i];\n      var slideOffset = $slideEl[0].swiperSlideOffset;\n      var offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;\n\n      var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n      var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n      // var rotateZ = 0\n      var translateZ = -translate * Math.abs(offsetMultiplier);\n\n      var translateY = isHorizontal ? 0 : params.stretch * (offsetMultiplier);\n      var translateX = isHorizontal ? params.stretch * (offsetMultiplier) : 0;\n\n      // Fix for ultra small values\n      if (Math.abs(translateX) < 0.001) { translateX = 0; }\n      if (Math.abs(translateY) < 0.001) { translateY = 0; }\n      if (Math.abs(translateZ) < 0.001) { translateZ = 0; }\n      if (Math.abs(rotateY) < 0.001) { rotateY = 0; }\n      if (Math.abs(rotateX) < 0.001) { rotateX = 0; }\n\n      var slideTransform = \"translate3d(\" + translateX + \"px,\" + translateY + \"px,\" + translateZ + \"px)  rotateX(\" + rotateX + \"deg) rotateY(\" + rotateY + \"deg)\";\n\n      $slideEl.transform(slideTransform);\n      $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n      if (params.slideShadows) {\n        // Set shadows\n        var $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');\n        var $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');\n        if ($shadowBeforeEl.length === 0) {\n          $shadowBeforeEl = $$1((\"<div class=\\\"swiper-slide-shadow-\" + (isHorizontal ? 'left' : 'top') + \"\\\"></div>\"));\n          $slideEl.append($shadowBeforeEl);\n        }\n        if ($shadowAfterEl.length === 0) {\n          $shadowAfterEl = $$1((\"<div class=\\\"swiper-slide-shadow-\" + (isHorizontal ? 'right' : 'bottom') + \"\\\"></div>\"));\n          $slideEl.append($shadowAfterEl);\n        }\n        if ($shadowBeforeEl.length) { $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0; }\n        if ($shadowAfterEl.length) { $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0; }\n      }\n    }\n\n    // Set correct perspective for IE10\n    if (Browser.ie) {\n      var ws = $wrapperEl[0].style;\n      ws.perspectiveOrigin = center + \"px 50%\";\n    }\n  },\n  setTransition: function setTransition(duration) {\n    var swiper = this;\n    swiper.slides\n      .transition(duration)\n      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')\n      .transition(duration);\n  },\n};\n\nvar EffectCoverflow = {\n  name: 'effect-coverflow',\n  params: {\n    coverflowEffect: {\n      rotate: 50,\n      stretch: 0,\n      depth: 100,\n      modifier: 1,\n      slideShadows: true,\n    },\n  },\n  create: function create() {\n    var swiper = this;\n    Utils.extend(swiper, {\n      coverflowEffect: {\n        setTranslate: Coverflow.setTranslate.bind(swiper),\n        setTransition: Coverflow.setTransition.bind(swiper),\n      },\n    });\n  },\n  on: {\n    beforeInit: function beforeInit() {\n      var swiper = this;\n      if (swiper.params.effect !== 'coverflow') { return; }\n\n      swiper.classNames.push(((swiper.params.containerModifierClass) + \"coverflow\"));\n      swiper.classNames.push(((swiper.params.containerModifierClass) + \"3d\"));\n\n      swiper.params.watchSlidesProgress = true;\n      swiper.originalParams.watchSlidesProgress = true;\n    },\n    setTranslate: function setTranslate() {\n      var swiper = this;\n      if (swiper.params.effect !== 'coverflow') { return; }\n      swiper.coverflowEffect.setTranslate();\n    },\n    setTransition: function setTransition(duration) {\n      var swiper = this;\n      if (swiper.params.effect !== 'coverflow') { return; }\n      swiper.coverflowEffect.setTransition(duration);\n    },\n  },\n};\n\n// Swiper Class\n// Core Modules\nSwiper$1.use([\n  Device$2,\n  Support$2,\n  Browser$2,\n  Resize,\n  Observer$1,\n  Virtual$1,\n  Keyboard$1,\n  Mousewheel$1,\n  Navigation$1,\n  Pagination$1,\n  Scrollbar$1,\n  Parallax$1,\n  Zoom$1,\n  Lazy$1,\n  Controller$1,\n  A11y,\n  History$1,\n  HashNavigation$1,\n  Autoplay$1,\n  EffectFade,\n  EffectCube,\n  EffectFlip,\n  EffectCoverflow\n]);\n\nreturn Swiper$1;\n\n})));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/swiper/dist/js/swiper.js\n// module id = 21\n// module chunks = 0\n//# sourceURL=webpack:///./~/swiper/dist/js/swiper.js?")
},function(module,exports,__webpack_require__){eval('var GoogleMapsLoader = __webpack_require__(6);\nvar Promise = __webpack_require__(7);\nGoogleMapsLoader.KEY = \'AIzaSyDor4jeGMzVTzl6x5QgpGPvahUSje9I-E0\';\n\nfunction ContactMap(node){\n    this.$node = node;\n    this.init();\n}\n\n\nContactMap.prototype.init = function(){\n\n    this.initMap();\n\n}\n\nContactMap.prototype.initMap = function() {\n\n    var cxt = this;\n\n    GoogleMapsLoader.load(function(google) {\n        var map;\n          var styles = {\n              silver:\n                [\n                    {\n                        "featureType": "all",\n                        "elementType": "geometry",\n                        "stylers": [\n                            {\n                                "color": "#92d1f4"\n                            }\n                        ]\n                    },\n                    {\n                        "featureType": "all",\n                        "elementType": "labels.text.fill",\n                        "stylers": [\n                            {\n                                "gamma": 0.01\n                            },\n                            {\n                                "lightness": 20\n                            }\n                        ]\n                    },\n                    {\n                        "featureType": "all",\n                        "elementType": "labels.text.stroke",\n                        "stylers": [\n                            {\n                                "saturation": -31\n                            },\n                            {\n                                "lightness": -33\n                            },\n                            {\n                                "weight": 2\n                            },\n                            {\n                                "gamma": 0.8\n                            }\n                        ]\n                    },\n                    {\n                        "featureType": "all",\n                        "elementType": "labels.icon",\n                        "stylers": [\n                            {\n                                "visibility": "off"\n                            }\n                        ]\n                    },\n                    {\n                        "featureType": "landscape",\n                        "elementType": "geometry",\n                        "stylers": [\n                            {\n                                "lightness": 80\n                            },\n                            {\n                                "saturation": 10\n                            }\n                        ]\n                    },\n                    {\n                        "featureType": "poi",\n                        "elementType": "geometry",\n                        "stylers": [\n                            {\n                                "saturation": 20\n                            }\n                        ]\n                    },\n                    {\n                        "featureType": "poi.park",\n                        "elementType": "geometry",\n                        "stylers": [\n                            {\n                                "lightness": 70\n                            },\n                            {\n                                "saturation": -20\n                            }\n                        ]\n                    },\n                    {\n                        "featureType": "road",\n                        "elementType": "geometry",\n                        "stylers": [\n                            {\n                                "lightness": 670\n                            },\n                            {\n                                "saturation": -30\n                            }\n                        ]\n                    },\n                    {\n                        "featureType": "road",\n                        "elementType": "geometry.stroke",\n                        "stylers": [\n                            {\n                                "saturation": 25\n                            },\n                            {\n                                "lightness": 25\n                            }\n                        ]\n                    },\n                    {\n                        "featureType": "water",\n                        "elementType": "all",\n                        "stylers": [\n                            {\n                                "saturation": 35\n                            },\n                            {\n                                "lightness":20\n                            }\n                        ]\n                    }\n                ]\n            };\n\n\n          var myStyles =[\n            {\n                featureType: "poi",\n                elementType: "labels",\n                stylers: [\n                      { visibility: "off" }\n                ]\n            },\n            {\n              featureType: \'transit\',\n              elementType: \'labels.icon\',\n              stylers: [{visibility: \'off\'}]\n            }\n        ];\n\n\n        var locations = [\n          [51.514839, -0.091090]\n        ];\n\n        var options = {\n           draggable: true,\n           scrollwheel: true,\n           panControl: true,\n           zoom: 15,\n           disableDefaultUI: true,\n           zoomControl: true,\n           clickableIcons: false,\n           center: {lat: 51.514809, lng: -0.091095},\n           mapTypeId: google.maps.MapTypeId.ROADMAP,\n           styles: myStyles\n       };\n\n\n          map = new google.maps.Map(cxt.$node, options);\n          map.setOptions({styles: styles[\'silver\']});\n\n          //Resize Function\n          google.maps.event.addDomListener(window, "resize", function() {\n              var center = map.getCenter();\n              google.maps.event.trigger(map, "resize");\n              map.setCenter(center);\n          });\n\n          var image = {\n            url: \'./dist/images/icons/pin.png\',\n            size: new google.maps.Size(37, 40),\n            origin: new google.maps.Point(0, 0),\n            anchor: new google.maps.Point(0, 32)\n          };\n\n\n          var marker, i;\n\n          for (i = 0; i < locations.length; i++) {\n              marker = new google.maps.Marker({\n                  position: new google.maps.LatLng(locations[i][0], locations[i][1]),\n                  map: map,\n                  icon: image\n              });\n           }\n\n\n\n    });\n\n}\n\nmodule.exports = ContactMap;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./assets/scripts/widgets/contact-map.js\n// module id = 22\n// module chunks = 0\n//# sourceURL=webpack:///./assets/scripts/widgets/contact-map.js?')},function(module,exports){eval("function InfoOverlay(node){\n    this.node = node;\n    this.init();\n}\n\nInfoOverlay.prototype.init = function(){\n    this.lnk = document.querySelectorAll('[data-target]');\n    this.bg = document.getElementById('overlayBackgroundHook');\n    this.close = this.node.querySelector('.map__overlay--close');\n    var cxt = this;\n\n    this.close.addEventListener('click', function(e){\n        cxt.closeModal(e);\n    });\n\n    this.bg.addEventListener('click', function(e){\n        cxt.closeModal(e);\n    });\n\n    Array.prototype.forEach.call(this.lnk, function(ele, index, array){\n        ele.addEventListener('click', function(e){\n            cxt.openModal(e);\n        });\n    });\n}\n\nInfoOverlay.prototype.openModal = function(e){\n    e.preventDefault();\n    this.bg.classList.add('active');\n    this.bg.style.zIndex = 998;\n    this.node.classList.add('active');\n}\n\nInfoOverlay.prototype.closeModal = function(e){\n    e.preventDefault();\n    this.node.classList.remove('active');\n    this.bg.classList.remove('active');\n\n    var cxt = this;\n    setTimeout(function(){\n        cxt.bg.style.zIndex = -1;\n    }, 300);\n}\n\nmodule.exports = InfoOverlay;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./assets/scripts/widgets/info-overlay.js\n// module id = 23\n// module chunks = 0\n//# sourceURL=webpack:///./assets/scripts/widgets/info-overlay.js?")},function(module,exports,__webpack_require__){eval("var plyr = __webpack_require__(25);\n\nfunction PlyrInit(node){\n    this.node = node;\n    this.init();\n}\n\nPlyrInit.prototype.init = function(){\n    this.playBtn = this.node.querySelector('.video-prompt--btn');\n    this.heading = this.node.querySelector('.centered-heading');\n    this.videoPlayer = this.node.querySelector('[data-type]');\n    var cxt = this;\n\n    this.vidInstance = plyr.setup(cxt.videoPlayer,\n        {\n            clickToPlay : false\n        }\n    );\n\n    this.playBtn.addEventListener('click', function(e){\n        e.preventDefault();\n        cxt.vidInstance[0].play();\n        cxt.heading.classList.add('remove');\n\n        var vidWrapper = cxt.node.childNodes[0].nextSibling;\n        vidHeight = vidWrapper.getBoundingClientRect().height;\n        cxt.node.style.maxHeight = vidHeight + 'px';\n    });\n\n    this.vidInstance[0].on('pause', function(event) {\n      cxt.node.style.maxHeight = '470px';\n      cxt.heading.classList.remove('remove');\n      cxt.playBtn.classList.remove('remove');\n    });\n\n    this.vidInstance[0].on('play', function(event) {\n      cxt.playBtn.classList.add('remove');\n    });\n\n    this.vidInstance[0].on('stop', function(event) {\n      cxt.node.style.maxHeight = '470px';\n      cxt.heading.classList.remove('remove');\n      cxt.playBtn.classList.remove('remove');\n    });\n}\n\nmodule.exports = PlyrInit;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./assets/scripts/widgets/plyr-init.js\n// module id = 24\n// module chunks = 0\n//# sourceURL=webpack:///./assets/scripts/widgets/plyr-init.js?")},function(module,exports,__webpack_require__){
eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// ==========================================================================\n// Plyr\n// plyr.js v2.0.18\n// https://github.com/sampotts/plyr\n// License: The MIT License (MIT)\n// ==========================================================================\n// Credits: http://paypal.github.io/accessible-html5-video-player/\n// ==========================================================================\n\n(function(root, factory) {\n    'use strict';\n    /*global define,module*/\n\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        // Node, CommonJS-like\n        module.exports = factory(root, document);\n    } else if (true) {\n        // AMD\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n            return factory(root, document);\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {\n        // Browser globals (root is window)\n        root.plyr = factory(root, document);\n    }\n})(typeof window !== 'undefined' ? window : this, function(window, document) {\n    'use strict';\n\n    // Globals\n    var fullscreen,\n        scroll = { x: 0, y: 0 },\n        // Default config\n        defaults = {\n            enabled: true,\n            debug: false,\n            autoplay: false,\n            loop: false,\n            seekTime: 10,\n            volume: 10,\n            volumeMin: 0,\n            volumeMax: 10,\n            volumeStep: 1,\n            duration: null,\n            displayDuration: true,\n            loadSprite: true,\n            iconPrefix: 'plyr',\n            iconUrl: 'https://cdn.plyr.io/2.0.18/plyr.svg',\n            blankUrl: 'https://cdn.plyr.io/static/blank.mp4',\n            clickToPlay: true,\n            hideControls: true,\n            showPosterOnEnd: false,\n            disableContextMenu: true,\n            keyboardShorcuts: {\n                focused: true,\n                global: false,\n            },\n            tooltips: {\n                controls: false,\n                seek: true,\n            },\n            selectors: {\n                html5: 'video, audio',\n                embed: '[data-type]',\n                editable: 'input, textarea, select, [contenteditable]',\n                container: '.plyr',\n                controls: {\n                    container: null,\n                    wrapper: '.plyr__controls',\n                },\n                labels: '[data-plyr]',\n                buttons: {\n                    seek: '[data-plyr=\"seek\"]',\n                    play: '[data-plyr=\"play\"]',\n                    pause: '[data-plyr=\"pause\"]',\n                    restart: '[data-plyr=\"restart\"]',\n                    rewind: '[data-plyr=\"rewind\"]',\n                    forward: '[data-plyr=\"fast-forward\"]',\n                    mute: '[data-plyr=\"mute\"]',\n                    captions: '[data-plyr=\"captions\"]',\n                    fullscreen: '[data-plyr=\"fullscreen\"]',\n                },\n                volume: {\n                    input: '[data-plyr=\"volume\"]',\n                    display: '.plyr__volume--display',\n                },\n                progress: {\n                    container: '.plyr__progress',\n                    buffer: '.plyr__progress--buffer',\n                    played: '.plyr__progress--played',\n                },\n                captions: '.plyr__captions',\n                currentTime: '.plyr__time--current',\n                duration: '.plyr__time--duration',\n            },\n            classes: {\n                setup: 'plyr--setup',\n                ready: 'plyr--ready',\n                videoWrapper: 'plyr__video-wrapper',\n                embedWrapper: 'plyr__video-embed',\n                type: 'plyr--{0}',\n                stopped: 'plyr--stopped',\n                playing: 'plyr--playing',\n                muted: 'plyr--muted',\n                loading: 'plyr--loading',\n                hover: 'plyr--hover',\n                tooltip: 'plyr__tooltip',\n                hidden: 'plyr__sr-only',\n                hideControls: 'plyr--hide-controls',\n                isIos: 'plyr--is-ios',\n                isTouch: 'plyr--is-touch',\n                captions: {\n                    enabled: 'plyr--captions-enabled',\n                    active: 'plyr--captions-active',\n                },\n                fullscreen: {\n                    enabled: 'plyr--fullscreen-enabled',\n                    fallback: 'plyr--fullscreen-fallback',\n                    active: 'plyr--fullscreen-active',\n                },\n                tabFocus: 'tab-focus',\n            },\n            captions: {\n                defaultActive: false,\n            },\n            fullscreen: {\n                enabled: true,\n                fallback: true,\n                allowAudio: false,\n            },\n            storage: {\n                enabled: true,\n                key: 'plyr',\n            },\n            controls: ['play-large', 'play', 'progress', 'current-time', 'mute', 'volume', 'captions', 'fullscreen'],\n            i18n: {\n                restart: 'Restart',\n                rewind: 'Rewind {seektime} secs',\n                play: 'Play',\n                pause: 'Pause',\n                forward: 'Forward {seektime} secs',\n                played: 'played',\n                buffered: 'buffered',\n                currentTime: 'Current time',\n                duration: 'Duration',\n                volume: 'Volume',\n                toggleMute: 'Toggle Mute',\n                toggleCaptions: 'Toggle Captions',\n                toggleFullscreen: 'Toggle Fullscreen',\n                frameTitle: 'Player for {title}',\n            },\n            types: {\n                embed: ['youtube', 'vimeo', 'soundcloud'],\n                html5: ['video', 'audio'],\n            },\n            // URLs\n            urls: {\n                vimeo: {\n                    api: 'https://player.vimeo.com/api/player.js',\n                },\n                youtube: {\n                    api: 'https://www.youtube.com/iframe_api',\n                },\n                soundcloud: {\n                    api: 'https://w.soundcloud.com/player/api.js',\n                },\n            },\n            // Custom control listeners\n            listeners: {\n                seek: null,\n                play: null,\n                pause: null,\n                restart: null,\n                rewind: null,\n                forward: null,\n                mute: null,\n                volume: null,\n                captions: null,\n                fullscreen: null,\n            },\n            // Events to watch on HTML5 media elements\n            events: [\n                'ready',\n                'ended',\n                'progress',\n                'stalled',\n                'playing',\n                'waiting',\n                'canplay',\n                'canplaythrough',\n                'loadstart',\n                'loadeddata',\n                'loadedmetadata',\n                'timeupdate',\n                'volumechange',\n                'play',\n                'pause',\n                'error',\n                'seeking',\n                'seeked',\n                'emptied',\n            ],\n            // Logging\n            logPrefix: '[Plyr]',\n        };\n\n    // Credits: http://paypal.github.io/accessible-html5-video-player/\n    // Unfortunately, due to mixed support, UA sniffing is required\n    function _browserSniff() {\n        var ua = navigator.userAgent,\n            name = navigator.appName,\n            fullVersion = '' + parseFloat(navigator.appVersion),\n            majorVersion = parseInt(navigator.appVersion, 10),\n            nameOffset,\n            verOffset,\n            ix,\n            isIE = false,\n            isFirefox = false,\n            isChrome = false,\n            isSafari = false;\n\n        if (navigator.appVersion.indexOf('Windows NT') !== -1 && navigator.appVersion.indexOf('rv:11') !== -1) {\n            // MSIE 11\n            isIE = true;\n            name = 'IE';\n            fullVersion = '11';\n        } else if ((verOffset = ua.indexOf('MSIE')) !== -1) {\n            // MSIE\n            isIE = true;\n            name = 'IE';\n            fullVersion = ua.substring(verOffset + 5);\n        } else if ((verOffset = ua.indexOf('Chrome')) !== -1) {\n            // Chrome\n            isChrome = true;\n            name = 'Chrome';\n            fullVersion = ua.substring(verOffset + 7);\n        } else if ((verOffset = ua.indexOf('Safari')) !== -1) {\n            // Safari\n            isSafari = true;\n            name = 'Safari';\n            fullVersion = ua.substring(verOffset + 7);\n            if ((verOffset = ua.indexOf('Version')) !== -1) {\n                fullVersion = ua.substring(verOffset + 8);\n            }\n        } else if ((verOffset = ua.indexOf('Firefox')) !== -1) {\n            // Firefox\n            isFirefox = true;\n            name = 'Firefox';\n            fullVersion = ua.substring(verOffset + 8);\n        } else if ((nameOffset = ua.lastIndexOf(' ') + 1) < (verOffset = ua.lastIndexOf('/'))) {\n            // In most other browsers, 'name/version' is at the end of userAgent\n            name = ua.substring(nameOffset, verOffset);\n            fullVersion = ua.substring(verOffset + 1);\n\n            if (name.toLowerCase() === name.toUpperCase()) {\n                name = navigator.appName;\n            }\n        }\n\n        // Trim the fullVersion string at semicolon/space if present\n        if ((ix = fullVersion.indexOf(';')) !== -1) {\n            fullVersion = fullVersion.substring(0, ix);\n        }\n        if ((ix = fullVersion.indexOf(' ')) !== -1) {\n            fullVersion = fullVersion.substring(0, ix);\n        }\n\n        // Get major version\n        majorVersion = parseInt('' + fullVersion, 10);\n        if (isNaN(majorVersion)) {\n            fullVersion = '' + parseFloat(navigator.appVersion);\n            majorVersion = parseInt(navigator.appVersion, 10);\n        }\n\n        // Return data\n        return {\n            name: name,\n            version: majorVersion,\n            isIE: isIE,\n            isFirefox: isFirefox,\n            isChrome: isChrome,\n            isSafari: isSafari,\n            isIos: /(iPad|iPhone|iPod)/g.test(navigator.platform),\n            isIphone: /(iPhone|iPod)/g.test(navigator.userAgent),\n            isTouch: 'ontouchstart' in document.documentElement,\n        };\n    }\n\n    // Check for mime type support against a player instance\n    // Credits: http://diveintohtml5.info/everything.html\n    // Related: http://www.leanbackplyr.com/test/h5mt.html\n    function _supportMime(plyr, mimeType) {\n        var media = plyr.media;\n\n        if (plyr.type === 'video') {\n            // Check type\n            switch (mimeType) {\n                case 'video/webm':\n                    return !!(media.canPlayType && media.canPlayType('video/webm; codecs=\"vp8, vorbis\"').replace(/no/, ''));\n                case 'video/mp4':\n                    return !!(media.canPlayType && media.canPlayType('video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"').replace(/no/, ''));\n                case 'video/ogg':\n                    return !!(media.canPlayType && media.canPlayType('video/ogg; codecs=\"theora\"').replace(/no/, ''));\n            }\n        } else if (plyr.type === 'audio') {\n            // Check type\n            switch (mimeType) {\n                case 'audio/mpeg':\n                    return !!(media.canPlayType && media.canPlayType('audio/mpeg;').replace(/no/, ''));\n                case 'audio/ogg':\n                    return !!(media.canPlayType && media.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/no/, ''));\n                case 'audio/wav':\n                    return !!(media.canPlayType && media.canPlayType('audio/wav; codecs=\"1\"').replace(/no/, ''));\n            }\n        }\n\n        // If we got this far, we're stuffed\n        return false;\n    }\n\n    // Inject a script\n    function _injectScript(source) {\n        if (document.querySelectorAll('script[src=\"' + source + '\"]').length) {\n            return;\n        }\n\n        var tag = document.createElement('script');\n        tag.src = source;\n        var firstScriptTag = document.getElementsByTagName('script')[0];\n        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\n    }\n\n    // Element exists in an array\n    function _inArray(haystack, needle) {\n        return Array.prototype.indexOf && haystack.indexOf(needle) !== -1;\n    }\n\n    // Replace all\n    function _replaceAll(string, find, replace) {\n        return string.replace(new RegExp(find.replace(/([.*+?\\^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1'), 'g'), replace);\n    }\n\n    // Wrap an element\n    function _wrap(elements, wrapper) {\n        // Convert `elements` to an array, if necessary.\n        if (!elements.length) {\n            elements = [elements];\n        }\n\n        // Loops backwards to prevent having to clone the wrapper on the\n        // first element (see `child` below).\n        for (var i = elements.length - 1; i >= 0; i--) {\n            var child = i > 0 ? wrapper.cloneNode(true) : wrapper;\n            var element = elements[i];\n\n            // Cache the current parent and sibling.\n            var parent = element.parentNode;\n            var sibling = element.nextSibling;\n\n            // Wrap the element (is automatically removed from its current\n            // parent).\n            child.appendChild(element);\n\n            // If the element had a sibling, insert the wrapper before\n            // the sibling to maintain the HTML structure; otherwise, just\n            // append it to the parent.\n            if (sibling) {\n                parent.insertBefore(child, sibling);\n            } else {\n                parent.appendChild(child);\n            }\n\n            return child;\n        }\n    }\n\n    // Unwrap an element\n    // http://plainjs.com/javascript/manipulation/unwrap-a-dom-element-35/\n    /*function _unwrap(wrapper) {\n        // Get the element's parent node\n        var parent = wrapper.parentNode;\n\n        // Move all children out of the element\n        while (wrapper.firstChild) {\n            parent.insertBefore(wrapper.firstChild, wrapper);\n        }\n\n        // Remove the empty element\n        parent.removeChild(wrapper);\n    }*/\n\n    // Remove an element\n    function _remove(element) {\n        if (!element) {\n            return;\n        }\n        element.parentNode.removeChild(element);\n    }\n\n    // Prepend child\n    function _prependChild(parent, element) {\n        parent.insertBefore(element, parent.firstChild);\n    }\n\n    // Set attributes\n    function _setAttributes(element, attributes) {\n        for (var key in attributes) {\n            element.setAttribute(key, _is.boolean(attributes[key]) && attributes[key] ? '' : attributes[key]);\n        }\n    }\n\n    // Insert a HTML element\n    function _insertElement(type, parent, attributes) {\n        // Create a new <element>\n        var element = document.createElement(type);\n\n        // Set all passed attributes\n        _setAttributes(element, attributes);\n\n        // Inject the new element\n        _prependChild(parent, element);\n    }\n\n    // Get a classname from selector\n    function _getClassname(selector) {\n        return selector.replace('.', '');\n    }\n\n    // Toggle class on an element\n    function _toggleClass(element, className, state) {\n        if (element) {\n            if (element.classList) {\n                element.classList[state ? 'add' : 'remove'](className);\n            } else {\n                var name = (' ' + element.className + ' ').replace(/\\s+/g, ' ').replace(' ' + className + ' ', '');\n                element.className = name + (state ? ' ' + className : '');\n            }\n        }\n    }\n\n    // Has class name\n    function _hasClass(element, className) {\n        if (element) {\n            if (element.classList) {\n                return element.classList.contains(className);\n            } else {\n                return new RegExp('(\\\\s|^)' + className + '(\\\\s|$)').test(element.className);\n            }\n        }\n        return false;\n    }\n\n    // Element matches selector\n    function _matches(element, selector) {\n        var p = Element.prototype;\n\n        var f =\n            p.matches ||\n            p.webkitMatchesSelector ||\n            p.mozMatchesSelector ||\n            p.msMatchesSelector ||\n            function(s) {\n                return [].indexOf.call(document.querySelectorAll(s), this) !== -1;\n            };\n\n        return f.call(element, selector);\n    }\n\n    // Bind along with custom handler\n    function _proxyListener(element, eventName, userListener, defaultListener, useCapture) {\n        if (userListener) {\n            // Register this before defaultListener\n            _on(\n                element,\n                eventName,\n                function(event) {\n                    userListener.apply(element, [event]);\n                },\n                useCapture\n            );\n        }\n        _on(\n            element,\n            eventName,\n            function(event) {\n                defaultListener.apply(element, [event]);\n            },\n            useCapture\n        );\n    }\n\n    // Toggle event listener\n    function _toggleListener(element, events, callback, toggle, useCapture) {\n        var eventList = events.split(' ');\n\n        // Whether the listener is a capturing listener or not\n        // Default to false\n        if (!_is.boolean(useCapture)) {\n            useCapture = false;\n        }\n\n        // If a nodelist is passed, call itself on each node\n        if (element instanceof NodeList) {\n            for (var x = 0; x < element.length; x++) {\n                if (element[x] instanceof Node) {\n                    _toggleListener(element[x], arguments[1], arguments[2], arguments[3]);\n                }\n            }\n            return;\n        }\n\n        // If a single node is passed, bind the event listener\n        for (var i = 0; i < eventList.length; i++) {\n            element[toggle ? 'addEventListener' : 'removeEventListener'](eventList[i], callback, useCapture);\n        }\n    }\n\n    // Bind event\n    function _on(element, events, callback, useCapture) {\n        if (element) {\n            _toggleListener(element, events, callback, true, useCapture);\n        }\n    }\n\n    // Unbind event\n    function _off(element, events, callback, useCapture) {\n        if (element) {\n            _toggleListener(element, events, callback, false, useCapture);\n        }\n    }\n\n    // Trigger event\n    function _event(element, type, bubbles, properties) {\n        // Bail if no element\n        if (!element || !type) {\n            return;\n        }\n\n        // Default bubbles to false\n        if (!_is.boolean(bubbles)) {\n            bubbles = false;\n        }\n\n        // Create and dispatch the event\n        var event = new CustomEvent(type, {\n            bubbles: bubbles,\n            detail: properties,\n        });\n\n        // Dispatch the event\n        element.dispatchEvent(event);\n    }\n\n    // Toggle aria-pressed state on a toggle button\n    // http://www.ssbbartgroup.com/blog/how-not-to-misuse-aria-states-properties-and-roles\n    function _toggleState(target, state) {\n        // Bail if no target\n        if (!target) {\n            return;\n        }\n\n        // Get state\n        state = _is.boolean(state) ? state : !target.getAttribute('aria-pressed');\n\n        // Set the attribute on target\n        target.setAttribute('aria-pressed', state);\n\n        return state;\n    }\n\n    // Get percentage\n    function _getPercentage(current, max) {\n        if (current === 0 || max === 0 || isNaN(current) || isNaN(max)) {\n            return 0;\n        }\n        return (current / max * 100).toFixed(2);\n    }\n\n    // Deep extend/merge destination object with N more objects\n    // http://andrewdupont.net/2009/08/28/deep-extending-objects-in-javascript/\n    // Removed call to arguments.callee (used explicit function name instead)\n    function _extend() {\n        // Get arguments\n        var objects = arguments;\n\n        // Bail if nothing to merge\n        if (!objects.length) {\n            return;\n        }\n\n        // Return first if specified but nothing to merge\n        if (objects.length === 1) {\n            return objects[0];\n        }\n\n        // First object is the destination\n        var destination = Array.prototype.shift.call(objects),\n            length = objects.length;\n\n        // Loop through all objects to merge\n        for (var i = 0; i < length; i++) {\n            var source = objects[i];\n\n            for (var property in source) {\n                if (source[property] && source[property].constructor && source[property].constructor === Object) {\n                    destination[property] = destination[property] || {};\n                    _extend(destination[property], source[property]);\n                } else {\n                    destination[property] = source[property];\n                }\n            }\n        }\n\n        return destination;\n    }\n\n    // Check variable types\n    var _is = {\n        object: function(input) {\n            return input !== null && typeof input === 'object';\n        },\n        array: function(input) {\n            return input !== null && (typeof input === 'object' && input.constructor === Array);\n        },\n        number: function(input) {\n            return input !== null && ((typeof input === 'number' && !isNaN(input - 0)) || (typeof input === 'object' && input.constructor === Number));\n        },\n        string: function(input) {\n            return input !== null && (typeof input === 'string' || (typeof input === 'object' && input.constructor === String));\n        },\n        boolean: function(input) {\n            return input !== null && typeof input === 'boolean';\n        },\n        nodeList: function(input) {\n            return input !== null && input instanceof NodeList;\n        },\n        htmlElement: function(input) {\n            return input !== null && input instanceof HTMLElement;\n        },\n        function: function(input) {\n            return input !== null && typeof input === 'function';\n        },\n        undefined: function(input) {\n            return input !== null && typeof input === 'undefined';\n        },\n    };\n\n    // Parse YouTube ID from url\n    function _parseYouTubeId(url) {\n        var regex = /^.*(youtu.be\\/|v\\/|u\\/\\w\\/|embed\\/|watch\\?v=|\\&v=)([^#\\&\\?]*).*/;\n        return url.match(regex) ? RegExp.$2 : url;\n    }\n\n    // Parse Vimeo ID from url\n    function _parseVimeoId(url) {\n        var regex = /^.*(vimeo.com\\/|video\\/)(\\d+).*/;\n        return url.match(regex) ? RegExp.$2 : url;\n    }\n\n    // Fullscreen API\n    function _fullscreen() {\n        var fullscreen = {\n                supportsFullScreen: false,\n                isFullScreen: function() {\n                    return false;\n                },\n                requestFullScreen: function() {},\n                cancelFullScreen: function() {},\n                fullScreenEventName: '',\n                element: null,\n                prefix: '',\n            },\n            browserPrefixes = 'webkit o moz ms khtml'.split(' ');\n\n        // Check for native support\n        if (!_is.undefined(document.cancelFullScreen)) {\n            fullscreen.supportsFullScreen = true;\n        } else {\n            // Check for fullscreen support by vendor prefix\n            for (var i = 0, il = browserPrefixes.length; i < il; i++) {\n                fullscreen.prefix = browserPrefixes[i];\n\n                if (!_is.undefined(document[fullscreen.prefix + 'CancelFullScreen'])) {\n                    fullscreen.supportsFullScreen = true;\n                    break;\n                } else if (!_is.undefined(document.msExitFullscreen) && document.msFullscreenEnabled) {\n                    // Special case for MS (when isn't it?)\n                    fullscreen.prefix = 'ms';\n                    fullscreen.supportsFullScreen = true;\n                    break;\n                }\n            }\n        }\n\n        // Update methods to do something useful\n        if (fullscreen.supportsFullScreen) {\n            // Yet again Microsoft awesomeness,\n            // Sometimes the prefix is 'ms', sometimes 'MS' to keep you on your toes\n            fullscreen.fullScreenEventName = fullscreen.prefix === 'ms' ? 'MSFullscreenChange' : fullscreen.prefix + 'fullscreenchange';\n\n            fullscreen.isFullScreen = function(element) {\n                if (_is.undefined(element)) {\n                    element = document.body;\n                }\n                switch (this.prefix) {\n                    case '':\n                        return document.fullscreenElement === element;\n                    case 'moz':\n                        return document.mozFullScreenElement === element;\n                    default:\n                        return document[this.prefix + 'FullscreenElement'] === element;\n                }\n            };\n            fullscreen.requestFullScreen = function(element) {\n                if (_is.undefined(element)) {\n                    element = document.body;\n                }\n                return this.prefix === ''\n                    ? element.requestFullScreen()\n                    : element[this.prefix + (this.prefix === 'ms' ? 'RequestFullscreen' : 'RequestFullScreen')]();\n            };\n            fullscreen.cancelFullScreen = function() {\n                return this.prefix === ''\n                    ? document.cancelFullScreen()\n                    : document[this.prefix + (this.prefix === 'ms' ? 'ExitFullscreen' : 'CancelFullScreen')]();\n            };\n            fullscreen.element = function() {\n                return this.prefix === '' ? document.fullscreenElement : document[this.prefix + 'FullscreenElement'];\n            };\n        }\n\n        return fullscreen;\n    }\n\n    // Local storage\n    var _storage = {\n        supported: (function() {\n            // Try to use it (it might be disabled, e.g. user is in private/porn mode)\n            // see: https://github.com/sampotts/plyr/issues/131\n            try {\n                // Add test item\n                window.localStorage.setItem('___test', 'OK');\n\n                // Get the test item\n                var result = window.localStorage.getItem('___test');\n\n                // Clean up\n                window.localStorage.removeItem('___test');\n\n                // Check if value matches\n                return result === 'OK';\n            } catch (e) {\n                return false;\n            }\n\n            return false;\n        })(),\n    };\n\n    // Player instance\n    function Plyr(media, config) {\n        var plyr = this,\n            timers = {},\n            api;\n\n        // Set media\n        plyr.media = media;\n        var original = media.cloneNode(true);\n\n        // Trigger events, with plyr instance passed\n        function _triggerEvent(element, type, bubbles, properties) {\n            _event(\n                element,\n                type,\n                bubbles,\n                _extend({}, properties, {\n                    plyr: api,\n                })\n            );\n        }\n\n        // Debugging\n        function _console(type, args) {\n            if (config.debug && window.console) {\n                args = Array.prototype.slice.call(args);\n\n                if (_is.string(config.logPrefix) && config.logPrefix.length) {\n                    args.unshift(config.logPrefix);\n                }\n\n                console[type].apply(console, args);\n            }\n        }\n        var _log = function() {\n                _console('log', arguments);\n            },\n            _warn = function() {\n                _console('warn', arguments);\n            };\n\n        // Log config options\n        _log('Config', config);\n\n        // Get icon URL\n        function _getIconUrl() {\n            return {\n                url: config.iconUrl,\n                // If you're using svg4everybody you don't need absolute paths\n                absolute: config.iconUrl.indexOf('http') === 0 || (plyr.browser.isIE && !window.svg4everybody),\n            };\n        }\n\n        // Build the default HTML\n        function _buildControls() {\n            // Create html array\n            var html = [],\n                iconUrl = _getIconUrl(),\n                iconPath = (!iconUrl.absolute ? iconUrl.url : '') + '#' + config.iconPrefix;\n\n            // Larger overlaid play button\n            if (_inArray(config.controls, 'play-large')) {\n                html.push(\n                    '<button type=\"button\" data-plyr=\"play\" class=\"plyr__play-large\">',\n                    '<svg><use xlink:href=\"' + iconPath + '-play\" /></svg>',\n                    '<span class=\"plyr__sr-only\">' + config.i18n.play + '</span>',\n                    '</button>'\n                );\n            }\n\n            html.push('<div class=\"plyr__controls\">');\n\n            // Restart button\n            if (_inArray(config.controls, 'restart')) {\n                html.push(\n                    '<button type=\"button\" data-plyr=\"restart\">',\n                    '<svg><use xlink:href=\"' + iconPath + '-restart\" /></svg>',\n                    '<span class=\"plyr__sr-only\">' + config.i18n.restart + '</span>',\n                    '</button>'\n                );\n            }\n\n            // Rewind button\n            if (_inArray(config.controls, 'rewind')) {\n                html.push(\n                    '<button type=\"button\" data-plyr=\"rewind\">',\n                    '<svg><use xlink:href=\"' + iconPath + '-rewind\" /></svg>',\n                    '<span class=\"plyr__sr-only\">' + config.i18n.rewind + '</span>',\n                    '</button>'\n                );\n            }\n\n            // Play Pause button\n            // TODO: This should be a toggle button really?\n            if (_inArray(config.controls, 'play')) {\n                html.push(\n                    '<button type=\"button\" data-plyr=\"play\">',\n                    '<svg><use xlink:href=\"' + iconPath + '-play\" /></svg>',\n                    '<span class=\"plyr__sr-only\">' + config.i18n.play + '</span>',\n                    '</button>',\n                    '<button type=\"button\" data-plyr=\"pause\">',\n                    '<svg><use xlink:href=\"' + iconPath + '-pause\" /></svg>',\n                    '<span class=\"plyr__sr-only\">' + config.i18n.pause + '</span>',\n                    '</button>'\n                );\n            }\n\n            // Fast forward button\n            if (_inArray(config.controls, 'fast-forward')) {\n                html.push(\n                    '<button type=\"button\" data-plyr=\"fast-forward\">',\n                    '<svg><use xlink:href=\"' + iconPath + '-fast-forward\" /></svg>',\n                    '<span class=\"plyr__sr-only\">' + config.i18n.forward + '</span>',\n                    '</button>'\n                );\n            }\n\n            // Progress\n            if (_inArray(config.controls, 'progress')) {\n                // Create progress\n                html.push(\n                    '<span class=\"plyr__progress\">',\n                    '<label for=\"seek{id}\" class=\"plyr__sr-only\">Seek</label>',\n                    '<input id=\"seek{id}\" class=\"plyr__progress--seek\" type=\"range\" min=\"0\" max=\"100\" step=\"0.1\" value=\"0\" data-plyr=\"seek\">',\n                    '<progress class=\"plyr__progress--played\" max=\"100\" value=\"0\" role=\"presentation\"></progress>',\n                    '<progress class=\"plyr__progress--buffer\" max=\"100\" value=\"0\">',\n                    '<span>0</span>% ' + config.i18n.buffered,\n                    '</progress>'\n                );\n\n                // Seek tooltip\n                if (config.tooltips.seek) {\n                    html.push('<span class=\"plyr__tooltip\">00:00</span>');\n                }\n\n                // Close\n                html.push('</span>');\n            }\n\n            // Media current time display\n            if (_inArray(config.controls, 'current-time')) {\n                html.push(\n                    '<span class=\"plyr__time\">',\n                    '<span class=\"plyr__sr-only\">' + config.i18n.currentTime + '</span>',\n                    '<span class=\"plyr__time--current\">00:00</span>',\n                    '</span>'\n                );\n            }\n\n            // Media duration display\n            if (_inArray(config.controls, 'duration')) {\n                html.push(\n                    '<span class=\"plyr__time\">',\n                    '<span class=\"plyr__sr-only\">' + config.i18n.duration + '</span>',\n                    '<span class=\"plyr__time--duration\">00:00</span>',\n                    '</span>'\n                );\n            }\n\n            // Toggle mute button\n            if (_inArray(config.controls, 'mute')) {\n                html.push(\n                    '<button type=\"button\" data-plyr=\"mute\">',\n                    '<svg class=\"icon--muted\"><use xlink:href=\"' + iconPath + '-muted\" /></svg>',\n                    '<svg><use xlink:href=\"' + iconPath + '-volume\" /></svg>',\n                    '<span class=\"plyr__sr-only\">' + config.i18n.toggleMute + '</span>',\n                    '</button>'\n                );\n            }\n\n            // Volume range control\n            if (_inArray(config.controls, 'volume')) {\n                html.push(\n                    '<span class=\"plyr__volume\">',\n                    '<label for=\"volume{id}\" class=\"plyr__sr-only\">' + config.i18n.volume + '</label>',\n                    '<input id=\"volume{id}\" class=\"plyr__volume--input\" type=\"range\" min=\"' +\n                        config.volumeMin +\n                        '\" max=\"' +\n                        config.volumeMax +\n                        '\" value=\"' +\n                        config.volume +\n                        '\" data-plyr=\"volume\">',\n                    '<progress class=\"plyr__volume--display\" max=\"' + config.volumeMax + '\" value=\"' + config.volumeMin + '\" role=\"presentation\"></progress>',\n                    '</span>'\n                );\n            }\n\n            // Toggle captions button\n            if (_inArray(config.controls, 'captions')) {\n                html.push(\n                    '<button type=\"button\" data-plyr=\"captions\">',\n                    '<svg class=\"icon--captions-on\"><use xlink:href=\"' + iconPath + '-captions-on\" /></svg>',\n                    '<svg><use xlink:href=\"' + iconPath + '-captions-off\" /></svg>',\n                    '<span class=\"plyr__sr-only\">' + config.i18n.toggleCaptions + '</span>',\n                    '</button>'\n                );\n            }\n\n            // Toggle fullscreen button\n            if (_inArray(config.controls, 'fullscreen')) {\n                html.push(\n                    '<button type=\"button\" data-plyr=\"fullscreen\">',\n                    '<svg class=\"icon--exit-fullscreen\"><use xlink:href=\"' + iconPath + '-exit-fullscreen\" /></svg>',\n                    '<svg><use xlink:href=\"' + iconPath + '-enter-fullscreen\" /></svg>',\n                    '<span class=\"plyr__sr-only\">' + config.i18n.toggleFullscreen + '</span>',\n                    '</button>'\n                );\n            }\n\n            // Close everything\n            html.push('</div>');\n\n            return html.join('');\n        }\n\n        // Setup fullscreen\n        function _setupFullscreen() {\n            if (!plyr.supported.full) {\n                return;\n            }\n\n            if ((plyr.type !== 'audio' || config.fullscreen.allowAudio) && config.fullscreen.enabled) {\n                // Check for native support\n                var nativeSupport = fullscreen.supportsFullScreen;\n\n                if (nativeSupport || (config.fullscreen.fallback && !_inFrame())) {\n                    _log((nativeSupport ? 'Native' : 'Fallback') + ' fullscreen enabled');\n\n                    // Add styling hook\n                    if (!nativeSupport) {\n                        _toggleClass(plyr.container, config.classes.fullscreen.fallback, true);\n                    }\n\n                    // Add styling hook\n                    _toggleClass(plyr.container, config.classes.fullscreen.enabled, true);\n                } else {\n                    _log('Fullscreen not supported and fallback disabled');\n                }\n\n                // Toggle state\n                if (plyr.buttons && plyr.buttons.fullscreen) {\n                    _toggleState(plyr.buttons.fullscreen, false);\n                }\n\n                // Setup focus trap\n                _focusTrap();\n            }\n        }\n\n        // Setup captions\n        function _setupCaptions() {\n            // Bail if not HTML5 video\n            if (plyr.type !== 'video') {\n                return;\n            }\n\n            // Inject the container\n            if (!_getElement(config.selectors.captions)) {\n                plyr.videoContainer.insertAdjacentHTML('afterbegin', '<div class=\"' + _getClassname(config.selectors.captions) + '\"></div>');\n            }\n\n            // Determine if HTML5 textTracks is supported\n            plyr.usingTextTracks = false;\n            if (plyr.media.textTracks) {\n                plyr.usingTextTracks = true;\n            }\n\n            // Get URL of caption file if exists\n            var captionSrc = '',\n                kind,\n                children = plyr.media.childNodes;\n\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].nodeName.toLowerCase() === 'track') {\n                    kind = children[i].kind;\n                    if (kind === 'captions' || kind === 'subtitles') {\n                        captionSrc = children[i].getAttribute('src');\n                    }\n                }\n            }\n\n            // Record if caption file exists or not\n            plyr.captionExists = true;\n            if (captionSrc === '') {\n                plyr.captionExists = false;\n                _log('No caption track found');\n            } else {\n                _log('Caption track found; URI: ' + captionSrc);\n            }\n\n            // If no caption file exists, hide container for caption text\n            if (!plyr.captionExists) {\n                _toggleClass(plyr.container, config.classes.captions.enabled);\n            } else {\n                // Turn off native caption rendering to avoid double captions\n                // This doesn't seem to work in Safari 7+, so the <track> elements are removed from the dom below\n                var tracks = plyr.media.textTracks;\n                for (var x = 0; x < tracks.length; x++) {\n                    tracks[x].mode = 'hidden';\n                }\n\n                // Enable UI\n                _showCaptions(plyr);\n\n                // Disable unsupported browsers than report false positive\n                // Firefox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1033144\n                if ((plyr.browser.isIE && plyr.browser.version >= 10) || (plyr.browser.isFirefox && plyr.browser.version >= 31)) {\n                    // Debugging\n                    _log('Detected browser with known TextTrack issues - using manual fallback');\n\n                    // Set to false so skips to 'manual' captioning\n                    plyr.usingTextTracks = false;\n                }\n\n                // Rendering caption tracks\n                // Native support required - http://caniuse.com/webvtt\n                if (plyr.usingTextTracks) {\n                    _log('TextTracks supported');\n\n                    for (var y = 0; y < tracks.length; y++) {\n                        var track = tracks[y];\n\n                        if (track.kind === 'captions' || track.kind === 'subtitles') {\n                            _on(track, 'cuechange', function() {\n                                // Display a cue, if there is one\n                                if (this.activeCues[0] && 'text' in this.activeCues[0]) {\n                                    _setCaption(this.activeCues[0].getCueAsHTML());\n                                } else {\n                                    _setCaption();\n                                }\n                            });\n                        }\n                    }\n                } else {\n                    // Caption tracks not natively supported\n                    _log('TextTracks not supported so rendering captions manually');\n\n                    // Render captions from array at appropriate time\n                    plyr.currentCaption = '';\n                    plyr.captions = [];\n\n                    if (captionSrc !== '') {\n                        // Create XMLHttpRequest Object\n                        var xhr = new XMLHttpRequest();\n\n                        xhr.onreadystatechange = function() {\n                            if (xhr.readyState === 4) {\n                                if (xhr.status === 200) {\n                                    var captions = [],\n                                        caption,\n                                        req = xhr.responseText;\n\n                                    //According to webvtt spec, line terminator consists of one of the following\n                                    // CRLF (U+000D U+000A), LF (U+000A) or CR (U+000D)\n                                    var lineSeparator = '\\r\\n';\n                                    if (req.indexOf(lineSeparator + lineSeparator) === -1) {\n                                        if (req.indexOf('\\r\\r') !== -1) {\n                                            lineSeparator = '\\r';\n                                        } else {\n                                            lineSeparator = '\\n';\n                                        }\n                                    }\n\n                                    captions = req.split(lineSeparator + lineSeparator);\n\n                                    for (var r = 0; r < captions.length; r++) {\n                                        caption = captions[r];\n                                        plyr.captions[r] = [];\n\n                                        // Get the parts of the captions\n                                        var parts = caption.split(lineSeparator),\n                                            index = 0;\n\n                                        // Incase caption numbers are added\n                                        if (parts[index].indexOf(':') === -1) {\n                                            index = 1;\n                                        }\n\n                                        plyr.captions[r] = [parts[index], parts[index + 1]];\n                                    }\n\n                                    // Remove first element ('VTT')\n                                    plyr.captions.shift();\n\n                                    _log('Successfully loaded the caption file via AJAX');\n                                } else {\n                                    _warn(config.logPrefix + 'There was a problem loading the caption file via AJAX');\n                                }\n                            }\n                        };\n\n                        xhr.open('get', captionSrc, true);\n\n                        xhr.send();\n                    }\n                }\n            }\n        }\n\n        // Set the current caption\n        function _setCaption(caption) {\n            /* jshint unused:false */\n            var container = _getElement(config.selectors.captions),\n                content = document.createElement('span');\n\n            // Empty the container\n            container.innerHTML = '';\n\n            // Default to empty\n            if (_is.undefined(caption)) {\n                caption = '';\n            }\n\n            // Set the span content\n            if (_is.string(caption)) {\n                content.innerHTML = caption.trim();\n            } else {\n                content.appendChild(caption);\n            }\n\n            // Set new caption text\n            container.appendChild(content);\n\n            // Force redraw (for Safari)\n            var redraw = container.offsetHeight;\n        }\n\n        // Captions functions\n        // Seek the manual caption time and update UI\n        function _seekManualCaptions(time) {\n            // Utilities for caption time codes\n            function _timecodeCommon(tc, pos) {\n                var tcpair = [];\n                tcpair = tc.split(' --\x3e ');\n                for (var i = 0; i < tcpair.length; i++) {\n                    // WebVTT allows for extra meta data after the timestamp line\n                    // So get rid of this if it exists\n                    tcpair[i] = tcpair[i].replace(/(\\d+:\\d+:\\d+\\.\\d+).*/, '$1');\n                }\n                return _subTcSecs(tcpair[pos]);\n            }\n            function _timecodeMin(tc) {\n                return _timecodeCommon(tc, 0);\n            }\n            function _timecodeMax(tc) {\n                return _timecodeCommon(tc, 1);\n            }\n            function _subTcSecs(tc) {\n                if (tc === null || tc === undefined) {\n                    return 0;\n                } else {\n                    var tc1 = [],\n                        tc2 = [],\n                        seconds;\n                    tc1 = tc.split(',');\n                    tc2 = tc1[0].split(':');\n                    seconds = Math.floor(tc2[0] * 60 * 60) + Math.floor(tc2[1] * 60) + Math.floor(tc2[2]);\n                    return seconds;\n                }\n            }\n\n            // If it's not video, or we're using textTracks, bail.\n            if (plyr.usingTextTracks || plyr.type !== 'video' || !plyr.supported.full) {\n                return;\n            }\n\n            // Reset subcount\n            plyr.subcount = 0;\n\n            // Check time is a number, if not use currentTime\n            // IE has a bug where currentTime doesn't go to 0\n            // https://twitter.com/Sam_Potts/status/573715746506731521\n            time = _is.number(time) ? time : plyr.media.currentTime;\n\n            // If there's no subs available, bail\n            if (!plyr.captions[plyr.subcount]) {\n                return;\n            }\n\n            while (_timecodeMax(plyr.captions[plyr.subcount][0]) < time.toFixed(1)) {\n                plyr.subcount++;\n                if (plyr.subcount > plyr.captions.length - 1) {\n                    plyr.subcount = plyr.captions.length - 1;\n                    break;\n                }\n            }\n\n            // Check if the next caption is in the current time range\n            if (\n                plyr.media.currentTime.toFixed(1) >= _timecodeMin(plyr.captions[plyr.subcount][0]) &&\n                plyr.media.currentTime.toFixed(1) <= _timecodeMax(plyr.captions[plyr.subcount][0])\n            ) {\n                plyr.currentCaption = plyr.captions[plyr.subcount][1];\n\n                // Render the caption\n                _setCaption(plyr.currentCaption);\n            } else {\n                _setCaption();\n            }\n        }\n\n        // Display captions container and button (for initialization)\n        function _showCaptions() {\n            // If there's no caption toggle, bail\n            if (!plyr.buttons.captions) {\n                return;\n            }\n\n            _toggleClass(plyr.container, config.classes.captions.enabled, true);\n\n            // Try to load the value from storage\n            var active = plyr.storage.captionsEnabled;\n\n            // Otherwise fall back to the default config\n            if (!_is.boolean(active)) {\n                active = config.captions.defaultActive;\n            }\n\n            if (active) {\n                _toggleClass(plyr.container, config.classes.captions.active, true);\n                _toggleState(plyr.buttons.captions, true);\n            }\n        }\n\n        // Find all elements\n        function _getElements(selector) {\n            return plyr.container.querySelectorAll(selector);\n        }\n\n        // Find a single element\n        function _getElement(selector) {\n            return _getElements(selector)[0];\n        }\n\n        // Determine if we're in an iframe\n        function _inFrame() {\n            try {\n                return window.self !== window.top;\n            } catch (e) {\n                return true;\n            }\n        }\n\n        // Trap focus inside container\n        function _focusTrap() {\n            var tabbables = _getElements('input:not([disabled]), button:not([disabled])'),\n                first = tabbables[0],\n                last = tabbables[tabbables.length - 1];\n\n            function _checkFocus(event) {\n                // If it is TAB\n                if (event.which === 9 && plyr.isFullscreen) {\n                    if (event.target === last && !event.shiftKey) {\n                        // Move focus to first element that can be tabbed if Shift isn't used\n                        event.preventDefault();\n                        first.focus();\n                    } else if (event.target === first && event.shiftKey) {\n                        // Move focus to last element that can be tabbed if Shift is used\n                        event.preventDefault();\n                        last.focus();\n                    }\n                }\n            }\n\n            // Bind the handler\n            _on(plyr.container, 'keydown', _checkFocus);\n        }\n\n        // Add elements to HTML5 media (source, tracks, etc)\n        function _insertChildElements(type, attributes) {\n            if (_is.string(attributes)) {\n                _insertElement(type, plyr.media, { src: attributes });\n            } else if (attributes.constructor === Array) {\n                for (var i = attributes.length - 1; i >= 0; i--) {\n                    _insertElement(type, plyr.media, attributes[i]);\n                }\n            }\n        }\n\n        // Insert controls\n        function _injectControls() {\n            // Sprite\n            if (config.loadSprite) {\n                var iconUrl = _getIconUrl();\n\n                // Only load external sprite using AJAX\n                if (iconUrl.absolute) {\n                    _log('AJAX loading absolute SVG sprite' + (plyr.browser.isIE ? ' (due to IE)' : ''));\n                    loadSprite(iconUrl.url, 'sprite-plyr');\n                } else {\n                    _log('Sprite will be used as external resource directly');\n                }\n            }\n\n            // Make a copy of the html\n            var html = config.html;\n\n            // Insert custom video controls\n            _log('Injecting custom controls');\n\n            // If no controls are specified, create default\n            if (!html) {\n                html = _buildControls();\n            }\n\n            // Replace seek time instances\n            html = _replaceAll(html, '{seektime}', config.seekTime);\n\n            // Replace all id references with random numbers\n            html = _replaceAll(html, '{id}', Math.floor(Math.random() * 10000));\n\n            // Replace Title, if it exists\n            if (config.title) {\n                html = _replaceAll(html, '{title}', config.title);\n            }\n\n            // Controls container\n            var target;\n\n            // Inject to custom location\n            if (_is.string(config.selectors.controls.container)) {\n                target = document.querySelector(config.selectors.controls.container);\n            }\n\n            // Inject into the container by default\n            if (!_is.htmlElement(target)) {\n                target = plyr.container;\n            }\n\n            // Inject controls HTML\n            target.insertAdjacentHTML('beforeend', html);\n\n            // Setup tooltips\n            if (config.tooltips.controls) {\n                var labels = _getElements([config.selectors.controls.wrapper, ' ', config.selectors.labels, ' .', config.classes.hidden].join(''));\n\n                for (var i = labels.length - 1; i >= 0; i--) {\n                    var label = labels[i];\n\n                    _toggleClass(label, config.classes.hidden, false);\n                    _toggleClass(label, config.classes.tooltip, true);\n                }\n            }\n        }\n\n        // Find the UI controls and store references\n        function _findElements() {\n            try {\n                plyr.controls = _getElement(config.selectors.controls.wrapper);\n\n                // Buttons\n                plyr.buttons = {};\n                plyr.buttons.seek = _getElement(config.selectors.buttons.seek);\n                plyr.buttons.play = _getElements(config.selectors.buttons.play);\n                plyr.buttons.pause = _getElement(config.selectors.buttons.pause);\n                plyr.buttons.restart = _getElement(config.selectors.buttons.restart);\n                plyr.buttons.rewind = _getElement(config.selectors.buttons.rewind);\n                plyr.buttons.forward = _getElement(config.selectors.buttons.forward);\n                plyr.buttons.fullscreen = _getElement(config.selectors.buttons.fullscreen);\n\n                // Inputs\n                plyr.buttons.mute = _getElement(config.selectors.buttons.mute);\n                plyr.buttons.captions = _getElement(config.selectors.buttons.captions);\n\n                // Progress\n                plyr.progress = {};\n                plyr.progress.container = _getElement(config.selectors.progress.container);\n\n                // Progress - Buffering\n                plyr.progress.buffer = {};\n                plyr.progress.buffer.bar = _getElement(config.selectors.progress.buffer);\n                plyr.progress.buffer.text = plyr.progress.buffer.bar && plyr.progress.buffer.bar.getElementsByTagName('span')[0];\n\n                // Progress - Played\n                plyr.progress.played = _getElement(config.selectors.progress.played);\n\n                // Seek tooltip\n                plyr.progress.tooltip = plyr.progress.container && plyr.progress.container.querySelector('.' + config.classes.tooltip);\n\n                // Volume\n                plyr.volume = {};\n                plyr.volume.input = _getElement(config.selectors.volume.input);\n                plyr.volume.display = _getElement(config.selectors.volume.display);\n\n                // Timing\n                plyr.duration = _getElement(config.selectors.duration);\n                plyr.currentTime = _getElement(config.selectors.currentTime);\n                plyr.seekTime = _getElements(config.selectors.seekTime);\n\n                return true;\n            } catch (e) {\n                _warn('It looks like there is a problem with your controls HTML');\n\n                // Restore native video controls\n                _toggleNativeControls(true);\n\n                return false;\n            }\n        }\n\n        // Toggle style hook\n        function _toggleStyleHook() {\n            _toggleClass(plyr.container, config.selectors.container.replace('.', ''), plyr.supported.full);\n        }\n\n        // Toggle native controls\n        function _toggleNativeControls(toggle) {\n            if (toggle && _inArray(config.types.html5, plyr.type)) {\n                plyr.media.setAttribute('controls', '');\n            } else {\n                plyr.media.removeAttribute('controls');\n            }\n        }\n\n        // Setup aria attribute for play and iframe title\n        function _setTitle(iframe) {\n            // Find the current text\n            var label = config.i18n.play;\n\n            // If there's a media title set, use that for the label\n            if (_is.string(config.title) && config.title.length) {\n                label += ', ' + config.title;\n\n                // Set container label\n                plyr.container.setAttribute('aria-label', config.title);\n            }\n\n            // If there's a play button, set label\n            if (plyr.supported.full && plyr.buttons.play) {\n                for (var i = plyr.buttons.play.length - 1; i >= 0; i--) {\n                    plyr.buttons.play[i].setAttribute('aria-label', label);\n                }\n            }\n\n            // Set iframe title\n            // https://github.com/sampotts/plyr/issues/124\n            if (_is.htmlElement(iframe)) {\n                iframe.setAttribute('title', config.i18n.frameTitle.replace('{title}', config.title));\n            }\n        }\n\n        // Setup localStorage\n        function _setupStorage() {\n            var value = null;\n            plyr.storage = {};\n\n            // Bail if we don't have localStorage support or it's disabled\n            if (!_storage.supported || !config.storage.enabled) {\n                return;\n            }\n\n            // Clean up old volume\n            // https://github.com/sampotts/plyr/issues/171\n            window.localStorage.removeItem('plyr-volume');\n\n            // load value from the current key\n            value = window.localStorage.getItem(config.storage.key);\n\n            if (!value) {\n                // Key wasn't set (or had been cleared), move along\n                return;\n            } else if (/^\\d+(\\.\\d+)?$/.test(value)) {\n                // If value is a number, it's probably volume from an older\n                // version of plyr. See: https://github.com/sampotts/plyr/pull/313\n                // Update the key to be JSON\n                _updateStorage({ volume: parseFloat(value) });\n            } else {\n                // Assume it's JSON from this or a later version of plyr\n                plyr.storage = JSON.parse(value);\n            }\n        }\n\n        // Save a value back to local storage\n        function _updateStorage(value) {\n            // Bail if we don't have localStorage support or it's disabled\n            if (!_storage.supported || !config.storage.enabled) {\n                return;\n            }\n\n            // Update the working copy of the values\n            _extend(plyr.storage, value);\n\n            // Update storage\n            window.localStorage.setItem(config.storage.key, JSON.stringify(plyr.storage));\n        }\n\n        // Setup media\n        function _setupMedia() {\n            // If there's no media, bail\n            if (!plyr.media) {\n                _warn('No media element found!');\n                return;\n            }\n\n            if (plyr.supported.full) {\n                // Add type class\n                _toggleClass(plyr.container, config.classes.type.replace('{0}', plyr.type), true);\n\n                // Add video class for embeds\n                // This will require changes if audio embeds are added\n                if (_inArray(config.types.embed, plyr.type)) {\n                    _toggleClass(plyr.container, config.classes.type.replace('{0}', 'video'), true);\n                }\n\n                // If there's no autoplay attribute, assume the video is stopped and add state class\n                _toggleClass(plyr.container, config.classes.stopped, config.autoplay);\n\n                // Add iOS class\n                _toggleClass(plyr.container, config.classes.isIos, plyr.browser.isIos);\n\n                // Add touch class\n                _toggleClass(plyr.container, config.classes.isTouch, plyr.browser.isTouch);\n\n                // Inject the player wrapper\n                if (plyr.type === 'video') {\n                    // Create the wrapper div\n                    var wrapper = document.createElement('div');\n                    wrapper.setAttribute('class', config.classes.videoWrapper);\n\n                    // Wrap the video in a container\n                    _wrap(plyr.media, wrapper);\n\n                    // Cache the container\n                    plyr.videoContainer = wrapper;\n                }\n            }\n\n            // Embeds\n            if (_inArray(config.types.embed, plyr.type)) {\n                _setupEmbed();\n            }\n        }\n\n        // Setup YouTube/Vimeo\n        function _setupEmbed() {\n            var container = document.createElement('div'),\n                mediaId,\n                mediaUrl,\n                id = plyr.type + '-' + Math.floor(Math.random() * 10000);\n\n            // Parse IDs from URLs if supplied\n            switch (plyr.type) {\n                case 'youtube':\n                    mediaId = _parseYouTubeId(plyr.embedId);\n                    break;\n\n                case 'vimeo':\n                    mediaId = _parseVimeoId(plyr.embedId);\n                    break;\n\n                default:\n                    mediaId = plyr.embedId;\n            }\n\n            // Remove old containers\n            var containers = _getElements('[id^=\"' + plyr.type + '-\"]');\n            for (var i = containers.length - 1; i >= 0; i--) {\n                _remove(containers[i]);\n            }\n\n            // Add embed class for responsive\n            _toggleClass(plyr.media, config.classes.videoWrapper, true);\n            _toggleClass(plyr.media, config.classes.embedWrapper, true);\n\n            if (plyr.type === 'youtube') {\n                // Create the YouTube container\n                plyr.media.appendChild(container);\n\n                // Set ID\n                container.setAttribute('id', id);\n\n                // Setup API\n                if (_is.object(window.YT)) {\n                    _youTubeReady(mediaId, container);\n                } else {\n                    // Load the API\n                    _injectScript(config.urls.youtube.api);\n\n                    // Setup callback for the API\n                    window.onYouTubeReadyCallbacks = window.onYouTubeReadyCallbacks || [];\n\n                    // Add to queue\n                    window.onYouTubeReadyCallbacks.push(function() {\n                        _youTubeReady(mediaId, container);\n                    });\n\n                    // Set callback to process queue\n                    window.onYouTubeIframeAPIReady = function() {\n                        window.onYouTubeReadyCallbacks.forEach(function(callback) {\n                            callback();\n                        });\n                    };\n                }\n            } else if (plyr.type === 'vimeo') {\n                // Vimeo needs an extra div to hide controls on desktop (which has full support)\n                if (plyr.supported.full) {\n                    plyr.media.appendChild(container);\n                } else {\n                    container = plyr.media;\n                }\n\n                // Set ID\n                container.setAttribute('id', id);\n\n                // Load the API if not already\n                if (!_is.object(window.Vimeo)) {\n                    _injectScript(config.urls.vimeo.api);\n\n                    // Wait for fragaloop load\n                    var vimeoTimer = window.setInterval(function() {\n                        if (_is.object(window.Vimeo)) {\n                            window.clearInterval(vimeoTimer);\n                            _vimeoReady(mediaId, container);\n                        }\n                    }, 50);\n                } else {\n                    _vimeoReady(mediaId, container);\n                }\n            } else if (plyr.type === 'soundcloud') {\n                // TODO: Currently unsupported and undocumented\n                // Inject the iframe\n                var soundCloud = document.createElement('iframe');\n\n                // Watch for iframe load\n                soundCloud.loaded = false;\n                _on(soundCloud, 'load', function() {\n                    soundCloud.loaded = true;\n                });\n\n                _setAttributes(soundCloud, {\n                    src: 'https://w.soundcloud.com/player/?url=https://api.soundcloud.com/tracks/' + mediaId,\n                    id: id,\n                });\n\n                container.appendChild(soundCloud);\n                plyr.media.appendChild(container);\n\n                // Load the API if not already\n                if (!window.SC) {\n                    _injectScript(config.urls.soundcloud.api);\n                }\n\n                // Wait for SC load\n                var soundCloudTimer = window.setInterval(function() {\n                    if (window.SC && soundCloud.loaded) {\n                        window.clearInterval(soundCloudTimer);\n                        _soundcloudReady.call(soundCloud);\n                    }\n                }, 50);\n            }\n        }\n\n        // When embeds are ready\n        function _embedReady() {\n            // Setup the UI and call ready if full support\n            if (plyr.supported.full) {\n                _setupInterface();\n                _ready();\n            }\n\n            // Set title\n            _setTitle(_getElement('iframe'));\n        }\n\n        // Handle YouTube API ready\n        function _youTubeReady(videoId, container) {\n            // Setup instance\n            // https://developers.google.com/youtube/iframe_api_reference\n            plyr.embed = new window.YT.Player(container.id, {\n                videoId: videoId,\n                playerVars: {\n                    autoplay: config.autoplay ? 1 : 0,\n                    controls: plyr.supported.full ? 0 : 1,\n                    rel: 0,\n                    showinfo: 0,\n                    iv_load_policy: 3,\n                    cc_load_policy: config.captions.defaultActive ? 1 : 0,\n                    cc_lang_pref: 'en',\n                    wmode: 'transparent',\n                    modestbranding: 1,\n                    disablekb: 1,\n                    origin: '*', // https://code.google.com/p/gdata-issues/issues/detail?id=5788#c45\n                },\n                events: {\n                    onError: function(event) {\n                        _triggerEvent(plyr.container, 'error', true, {\n                            code: event.data,\n                            embed: event.target,\n                        });\n                    },\n                    onReady: function(event) {\n                        // Get the instance\n                        var instance = event.target;\n\n                        // Create a faux HTML5 API using the YouTube API\n                        plyr.media.play = function() {\n                            instance.playVideo();\n                            plyr.media.paused = false;\n                        };\n                        plyr.media.pause = function() {\n                            instance.pauseVideo();\n                            plyr.media.paused = true;\n                        };\n                        plyr.media.stop = function() {\n                            instance.stopVideo();\n                            plyr.media.paused = true;\n                        };\n                        plyr.media.duration = instance.getDuration();\n                        plyr.media.paused = true;\n                        plyr.media.currentTime = 0;\n                        plyr.media.muted = instance.isMuted();\n\n                        // Set title if possible\n                        if (typeof instance.getVideoData === 'function') {\n                            config.title = instance.getVideoData().title;\n                        }\n\n                        // Set the tabindex\n                        if (plyr.supported.full) {\n                            plyr.media.querySelector('iframe').setAttribute('tabindex', '-1');\n                        }\n\n                        // Update UI\n                        _embedReady();\n\n                        // Trigger timeupdate\n                        _triggerEvent(plyr.media, 'timeupdate');\n\n                        // Trigger timeupdate\n                        _triggerEvent(plyr.media, 'durationchange');\n\n                        // Reset timer\n                        window.clearInterval(timers.buffering);\n\n                        // Setup buffering\n                        timers.buffering = window.setInterval(function() {\n                            // Get loaded % from YouTube\n                            plyr.media.buffered = instance.getVideoLoadedFraction();\n\n                            // Trigger progress only when we actually buffer something\n                            if (plyr.media.lastBuffered === null || plyr.media.lastBuffered < plyr.media.buffered) {\n                                _triggerEvent(plyr.media, 'progress');\n                            }\n\n                            // Set last buffer point\n                            plyr.media.lastBuffered = plyr.media.buffered;\n\n                            // Bail if we're at 100%\n                            if (plyr.media.buffered === 1) {\n                                window.clearInterval(timers.buffering);\n\n                                // Trigger event\n                                _triggerEvent(plyr.media, 'canplaythrough');\n                            }\n                        }, 200);\n                    },\n                    onStateChange: function(event) {\n                        // Get the instance\n                        var instance = event.target;\n\n                        // Reset timer\n                        window.clearInterval(timers.playing);\n\n                        // Handle events\n                        // -1   Unstarted\n                        // 0    Ended\n                        // 1    Playing\n                        // 2    Paused\n                        // 3    Buffering\n                        // 5    Video cued\n                        switch (event.data) {\n                            case 0:\n                                plyr.media.paused = true;\n                                _triggerEvent(plyr.media, 'ended');\n                                break;\n\n                            case 1:\n                                plyr.media.paused = false;\n\n                                // If we were seeking, fire seeked event\n                                if (plyr.media.seeking) {\n                                    _triggerEvent(plyr.media, 'seeked');\n                                }\n\n                                plyr.media.seeking = false;\n                                _triggerEvent(plyr.media, 'play');\n                                _triggerEvent(plyr.media, 'playing');\n\n                                // Poll to get playback progress\n                                timers.playing = window.setInterval(function() {\n                                    // Set the current time\n                                    plyr.media.currentTime = instance.getCurrentTime();\n\n                                    // Trigger timeupdate\n                                    _triggerEvent(plyr.media, 'timeupdate');\n                                }, 100);\n\n                                // Check duration again due to YouTube bug\n                                // https://github.com/sampotts/plyr/issues/374\n                                // https://code.google.com/p/gdata-issues/issues/detail?id=8690\n                                if (plyr.media.duration !== instance.getDuration()) {\n                                    plyr.media.duration = instance.getDuration();\n                                    _triggerEvent(plyr.media, 'durationchange');\n                                }\n\n                                break;\n\n                            case 2:\n                                plyr.media.paused = true;\n                                _triggerEvent(plyr.media, 'pause');\n                                break;\n                        }\n\n                        _triggerEvent(plyr.container, 'statechange', false, {\n                            code: event.data,\n                        });\n                    },\n                },\n            });\n        }\n\n        // Vimeo ready\n        function _vimeoReady(mediaId, container) {\n            // Setup instance\n            // https://github.com/vimeo/player.js\n\n            var options = {\n                loop: config.loop,\n                autoplay: config.autoplay,\n                byline: false,\n                portrait: false,\n                title: false,\n                speed: true,\n                transparent: 0,\n            };\n\n            // Convert options into URL params for iframe\n            function buildUrlParameters(options) {\n                return Object.keys(options)\n                    .map(function(key) {\n                        return encodeURIComponent(key) + '=' + encodeURIComponent(options[key]);\n                    })\n                    .join('&');\n            }\n\n            // Get Vimeo params for the iframe\n            var params = buildUrlParameters(options);\n\n            // Build an iframe\n            var iframe = document.createElement('iframe');\n            var src = 'https://player.vimeo.com/video/' + mediaId + '?' + params;\n            iframe.setAttribute('src', src);\n            iframe.setAttribute('allowfullscreen', '');\n            container.appendChild(iframe);\n\n            plyr.embed = new window.Vimeo.Player(iframe);\n\n            // Create a faux HTML5 API using the Vimeo API\n            plyr.media.play = function() {\n                plyr.embed.play();\n                plyr.media.paused = false;\n            };\n            plyr.media.pause = function() {\n                plyr.embed.pause();\n                plyr.media.paused = true;\n            };\n            plyr.media.stop = function() {\n                plyr.embed.stop();\n                plyr.media.paused = true;\n            };\n\n            plyr.media.paused = true;\n            plyr.media.currentTime = 0;\n\n            // Update UI\n            _embedReady();\n\n            plyr.embed.getCurrentTime().then(function(value) {\n                plyr.media.currentTime = value;\n\n                // Trigger timeupdate\n                _triggerEvent(plyr.media, 'timeupdate');\n            });\n\n            plyr.embed.getDuration().then(function(value) {\n                plyr.media.duration = value;\n\n                // Trigger timeupdate\n                _triggerEvent(plyr.media, 'durationchange');\n            });\n\n            // TODO: Captions\n            /*if (config.captions.defaultActive) {\n                plyr.embed.enableTextTrack('en');\n            }*/\n\n            plyr.embed.on('loaded', function() {\n                // Fix keyboard focus issues\n                // https://github.com/sampotts/plyr/issues/317\n                if (_is.htmlElement(plyr.embed.element) && plyr.supported.full) {\n                    plyr.embed.element.setAttribute('tabindex', '-1');\n                }\n            });\n\n            plyr.embed.on('play', function() {\n                plyr.media.paused = false;\n                _triggerEvent(plyr.media, 'play');\n                _triggerEvent(plyr.media, 'playing');\n            });\n\n            plyr.embed.on('pause', function() {\n                plyr.media.paused = true;\n                _triggerEvent(plyr.media, 'pause');\n            });\n\n            plyr.embed.on('timeupdate', function(data) {\n                plyr.media.seeking = false;\n                plyr.media.currentTime = data.seconds;\n                _triggerEvent(plyr.media, 'timeupdate');\n            });\n\n            plyr.embed.on('progress', function(data) {\n                plyr.media.buffered = data.percent;\n                _triggerEvent(plyr.media, 'progress');\n\n                if (parseInt(data.percent) === 1) {\n                    // Trigger event\n                    _triggerEvent(plyr.media, 'canplaythrough');\n                }\n            });\n\n            plyr.embed.on('seeked', function() {\n                plyr.media.seeking = false;\n                _triggerEvent(plyr.media, 'seeked');\n                _triggerEvent(plyr.media, 'play');\n            });\n\n            plyr.embed.on('ended', function() {\n                plyr.media.paused = true;\n                _triggerEvent(plyr.media, 'ended');\n            });\n        }\n\n        // Soundcloud ready\n        function _soundcloudReady() {\n            /* jshint validthis: true */\n            plyr.embed = window.SC.Widget(this);\n\n            // Setup on ready\n            plyr.embed.bind(window.SC.Widget.Events.READY, function() {\n                // Create a faux HTML5 API using the Soundcloud API\n                plyr.media.play = function() {\n                    plyr.embed.play();\n                    plyr.media.paused = false;\n                };\n                plyr.media.pause = function() {\n                    plyr.embed.pause();\n                    plyr.media.paused = true;\n                };\n                plyr.media.stop = function() {\n                    plyr.embed.seekTo(0);\n                    plyr.embed.pause();\n                    plyr.media.paused = true;\n                };\n\n                plyr.media.paused = true;\n                plyr.media.currentTime = 0;\n\n                plyr.embed.getDuration(function(value) {\n                    plyr.media.duration = value / 1000;\n\n                    // Update UI\n                    _embedReady();\n                });\n\n                plyr.embed.getPosition(function(value) {\n                    plyr.media.currentTime = value;\n\n                    // Trigger timeupdate\n                    _triggerEvent(plyr.media, 'timeupdate');\n                });\n\n                plyr.embed.bind(window.SC.Widget.Events.PLAY, function() {\n                    plyr.media.paused = false;\n                    _triggerEvent(plyr.media, 'play');\n                    _triggerEvent(plyr.media, 'playing');\n                });\n\n                plyr.embed.bind(window.SC.Widget.Events.PAUSE, function() {\n                    plyr.media.paused = true;\n                    _triggerEvent(plyr.media, 'pause');\n                });\n\n                plyr.embed.bind(window.SC.Widget.Events.PLAY_PROGRESS, function(data) {\n                    plyr.media.seeking = false;\n                    plyr.media.currentTime = data.currentPosition / 1000;\n                    _triggerEvent(plyr.media, 'timeupdate');\n                });\n\n                plyr.embed.bind(window.SC.Widget.Events.LOAD_PROGRESS, function(data) {\n                    plyr.media.buffered = data.loadProgress;\n                    _triggerEvent(plyr.media, 'progress');\n\n                    if (parseInt(data.loadProgress) === 1) {\n                        // Trigger event\n                        _triggerEvent(plyr.media, 'canplaythrough');\n                    }\n                });\n\n                plyr.embed.bind(window.SC.Widget.Events.FINISH, function() {\n                    plyr.media.paused = true;\n                    _triggerEvent(plyr.media, 'ended');\n                });\n            });\n        }\n\n        // Play media\n        function _play() {\n            if ('play' in plyr.media) {\n                plyr.media.play();\n            }\n        }\n\n        // Pause media\n        function _pause() {\n            if ('pause' in plyr.media) {\n                plyr.media.pause();\n            }\n        }\n\n        // Toggle playback\n        function _togglePlay(toggle) {\n            // True toggle\n            if (!_is.boolean(toggle)) {\n                toggle = plyr.media.paused;\n            }\n\n            if (toggle) {\n                _play();\n            } else {\n                _pause();\n            }\n\n            return toggle;\n        }\n\n        // Rewind\n        function _rewind(seekTime) {\n            // Use default if needed\n            if (!_is.number(seekTime)) {\n                seekTime = config.seekTime;\n            }\n            _seek(plyr.media.currentTime - seekTime);\n        }\n\n        // Fast forward\n        function _forward(seekTime) {\n            // Use default if needed\n            if (!_is.number(seekTime)) {\n                seekTime = config.seekTime;\n            }\n            _seek(plyr.media.currentTime + seekTime);\n        }\n\n        // Seek to time\n        // The input parameter can be an event or a number\n        function _seek(input) {\n            var targetTime = 0,\n                paused = plyr.media.paused,\n                duration = _getDuration();\n\n            if (_is.number(input)) {\n                targetTime = input;\n            } else if (_is.object(input) && _inArray(['input', 'change'], input.type)) {\n                // It's the seek slider\n                // Seek to the selected time\n                targetTime = input.target.value / input.target.max * duration;\n            }\n\n            // Normalise targetTime\n            if (targetTime < 0) {\n                targetTime = 0;\n            } else if (targetTime > duration) {\n                targetTime = duration;\n            }\n\n            // Update seek range and progress\n            _updateSeekDisplay(targetTime);\n\n            // Set the current time\n            // Try/catch incase the media isn't set and we're calling seek() from source() and IE moans\n            try {\n                plyr.media.currentTime = targetTime.toFixed(4);\n            } catch (e) {}\n\n            // Embeds\n            if (_inArray(config.types.embed, plyr.type)) {\n                switch (plyr.type) {\n                    case 'youtube':\n                        plyr.embed.seekTo(targetTime);\n                        break;\n\n                    case 'vimeo':\n                        // Round to nearest second for vimeo\n                        plyr.embed.setCurrentTime(targetTime.toFixed(0));\n                        break;\n\n                    case 'soundcloud':\n                        plyr.embed.seekTo(targetTime * 1000);\n                        break;\n                }\n\n                if (paused) {\n                    _pause();\n                }\n\n                // Trigger timeupdate\n                _triggerEvent(plyr.media, 'timeupdate');\n\n                // Set seeking flag\n                plyr.media.seeking = true;\n\n                // Trigger seeking\n                _triggerEvent(plyr.media, 'seeking');\n            }\n\n            // Logging\n            _log('Seeking to ' + plyr.media.currentTime + ' seconds');\n\n            // Special handling for 'manual' captions\n            _seekManualCaptions(targetTime);\n        }\n\n        // Get the duration (or custom if set)\n        function _getDuration() {\n            // It should be a number, but parse it just incase\n            var duration = parseInt(config.duration),\n                // True duration\n                mediaDuration = 0;\n\n            // Only if duration available\n            if (plyr.media.duration !== null && !isNaN(plyr.media.duration)) {\n                mediaDuration = plyr.media.duration;\n            }\n\n            // If custom duration is funky, use regular duration\n            return isNaN(duration) ? mediaDuration : duration;\n        }\n\n        // Check playing state\n        function _checkPlaying() {\n            _toggleClass(plyr.container, config.classes.playing, !plyr.media.paused);\n\n            _toggleClass(plyr.container, config.classes.stopped, plyr.media.paused);\n\n            _toggleControls(plyr.media.paused);\n        }\n\n        // Save scroll position\n        function _saveScrollPosition() {\n            scroll = {\n                x: window.pageXOffset || 0,\n                y: window.pageYOffset || 0,\n            };\n        }\n\n        // Restore scroll position\n        function _restoreScrollPosition() {\n            window.scrollTo(scroll.x, scroll.y);\n        }\n\n        // Toggle fullscreen\n        function _toggleFullscreen(event) {\n            // Check for native support\n            var nativeSupport = fullscreen.supportsFullScreen;\n\n            if (nativeSupport) {\n                // If it's a fullscreen change event, update the UI\n                if (event && event.type === fullscreen.fullScreenEventName) {\n                    plyr.isFullscreen = fullscreen.isFullScreen(plyr.container);\n                } else {\n                    // Else it's a user request to enter or exit\n                    if (!fullscreen.isFullScreen(plyr.container)) {\n                        // Save scroll position\n                        _saveScrollPosition();\n\n                        // Request full screen\n                        fullscreen.requestFullScreen(plyr.container);\n                    } else {\n                        // Bail from fullscreen\n                        fullscreen.cancelFullScreen();\n                    }\n\n                    // Check if we're actually full screen (it could fail)\n                    plyr.isFullscreen = fullscreen.isFullScreen(plyr.container);\n\n                    return;\n                }\n            } else {\n                // Otherwise, it's a simple toggle\n                plyr.isFullscreen = !plyr.isFullscreen;\n\n                // Bind/unbind escape key\n                document.body.style.overflow = plyr.isFullscreen ? 'hidden' : '';\n            }\n\n            // Set class hook\n            _toggleClass(plyr.container, config.classes.fullscreen.active, plyr.isFullscreen);\n\n            // Trap focus\n            _focusTrap(plyr.isFullscreen);\n\n            // Set button state\n            if (plyr.buttons && plyr.buttons.fullscreen) {\n                _toggleState(plyr.buttons.fullscreen, plyr.isFullscreen);\n            }\n\n            // Trigger an event\n            _triggerEvent(plyr.container, plyr.isFullscreen ? 'enterfullscreen' : 'exitfullscreen', true);\n\n            // Restore scroll position\n            if (!plyr.isFullscreen && nativeSupport) {\n                _restoreScrollPosition();\n            }\n        }\n\n        // Mute\n        function _toggleMute(muted) {\n            // If the method is called without parameter, toggle based on current value\n            if (!_is.boolean(muted)) {\n                muted = !plyr.media.muted;\n            }\n\n            // Set button state\n            _toggleState(plyr.buttons.mute, muted);\n\n            // Set mute on the player\n            plyr.media.muted = muted;\n\n            // If volume is 0 after unmuting, set to default\n            if (plyr.media.volume === 0) {\n                _setVolume(config.volume);\n            }\n\n            // Embeds\n            if (_inArray(config.types.embed, plyr.type)) {\n                // YouTube\n                switch (plyr.type) {\n                    case 'youtube':\n                        plyr.embed[plyr.media.muted ? 'mute' : 'unMute']();\n                        break;\n\n                    case 'vimeo':\n                    case 'soundcloud':\n                        plyr.embed.setVolume(plyr.media.muted ? 0 : parseFloat(config.volume / config.volumeMax));\n                        break;\n                }\n\n                // Trigger volumechange for embeds\n                _triggerEvent(plyr.media, 'volumechange');\n            }\n        }\n\n        // Set volume\n        function _setVolume(volume) {\n            var max = config.volumeMax,\n                min = config.volumeMin;\n\n            // Load volume from storage if no value specified\n            if (_is.undefined(volume)) {\n                volume = plyr.storage.volume;\n            }\n\n            // Use config if all else fails\n            if (volume === null || isNaN(volume)) {\n                volume = config.volume;\n            }\n\n            // Maximum is volumeMax\n            if (volume > max) {\n                volume = max;\n            }\n            // Minimum is volumeMin\n            if (volume < min) {\n                volume = min;\n            }\n\n            // Set the player volume\n            plyr.media.volume = parseFloat(volume / max);\n\n            // Set the display\n            if (plyr.volume.display) {\n                plyr.volume.display.value = volume;\n            }\n\n            // Embeds\n            if (_inArray(config.types.embed, plyr.type)) {\n                switch (plyr.type) {\n                    case 'youtube':\n                        plyr.embed.setVolume(plyr.media.volume * 100);\n                        break;\n\n                    case 'vimeo':\n                    case 'soundcloud':\n                        plyr.embed.setVolume(plyr.media.volume);\n                        break;\n                }\n\n                // Trigger volumechange for embeds\n                _triggerEvent(plyr.media, 'volumechange');\n            }\n\n            // Toggle muted state\n            if (volume === 0) {\n                plyr.media.muted = true;\n            } else if (plyr.media.muted && volume > 0) {\n                _toggleMute();\n            }\n        }\n\n        // Increase volume\n        function _increaseVolume(step) {\n            var volume = plyr.media.muted ? 0 : plyr.media.volume * config.volumeMax;\n\n            if (!_is.number(step)) {\n                step = config.volumeStep;\n            }\n\n            _setVolume(volume + step);\n        }\n\n        // Decrease volume\n        function _decreaseVolume(step) {\n            var volume = plyr.media.muted ? 0 : plyr.media.volume * config.volumeMax;\n\n            if (!_is.number(step)) {\n                step = config.volumeStep;\n            }\n\n            _setVolume(volume - step);\n        }\n\n        // Update volume UI and storage\n        function _updateVolume() {\n            // Get the current volume\n            var volume = plyr.media.muted ? 0 : plyr.media.volume * config.volumeMax;\n\n            // Update the <input type=\"range\"> if present\n            if (plyr.supported.full) {\n                if (plyr.volume.input) {\n                    plyr.volume.input.value = volume;\n                }\n                if (plyr.volume.display) {\n                    plyr.volume.display.value = volume;\n                }\n            }\n\n            // Update the volume in storage\n            _updateStorage({ volume: volume });\n\n            // Toggle class if muted\n            _toggleClass(plyr.container, config.classes.muted, volume === 0);\n\n            // Update checkbox for mute state\n            if (plyr.supported.full && plyr.buttons.mute) {\n                _toggleState(plyr.buttons.mute, volume === 0);\n            }\n        }\n\n        // Toggle captions\n        function _toggleCaptions(show) {\n            // If there's no full support, or there's no caption toggle\n            if (!plyr.supported.full || !plyr.buttons.captions) {\n                return;\n            }\n\n            // If the method is called without parameter, toggle based on current value\n            if (!_is.boolean(show)) {\n                show = plyr.container.className.indexOf(config.classes.captions.active) === -1;\n            }\n\n            // Set global\n            plyr.captionsEnabled = show;\n\n            // Toggle state\n            _toggleState(plyr.buttons.captions, plyr.captionsEnabled);\n\n            // Add class hook\n            _toggleClass(plyr.container, config.classes.captions.active, plyr.captionsEnabled);\n\n            // Trigger an event\n            _triggerEvent(plyr.container, plyr.captionsEnabled ? 'captionsenabled' : 'captionsdisabled', true);\n\n            // Save captions state to localStorage\n            _updateStorage({ captionsEnabled: plyr.captionsEnabled });\n        }\n\n        // Check if media is loading\n        function _checkLoading(event) {\n            var loading = event.type === 'waiting';\n\n            // Clear timer\n            clearTimeout(timers.loading);\n\n            // Timer to prevent flicker when seeking\n            timers.loading = setTimeout(function() {\n                // Toggle container class hook\n                _toggleClass(plyr.container, config.classes.loading, loading);\n\n                // Show controls if loading, hide if done\n                _toggleControls(loading);\n            }, loading ? 250 : 0);\n        }\n\n        // Update <progress> elements\n        function _updateProgress(event) {\n            if (!plyr.supported.full) {\n                return;\n            }\n\n            var progress = plyr.progress.played,\n                value = 0,\n                duration = _getDuration();\n\n            if (event) {\n                switch (event.type) {\n                    // Video playing\n                    case 'timeupdate':\n                    case 'seeking':\n                        if (plyr.controls.pressed) {\n                            return;\n                        }\n\n                        value = _getPercentage(plyr.media.currentTime, duration);\n\n                        // Set seek range value only if it's a 'natural' time event\n                        if (event.type === 'timeupdate' && plyr.buttons.seek) {\n                            plyr.buttons.seek.value = value;\n                        }\n\n                        break;\n\n                    // Check buffer status\n                    case 'playing':\n                    case 'progress':\n                        progress = plyr.progress.buffer;\n                        value = (function() {\n                            var buffered = plyr.media.buffered;\n\n                            if (buffered && buffered.length) {\n                                // HTML5\n                                return _getPercentage(buffered.end(0), duration);\n                            } else if (_is.number(buffered)) {\n                                // YouTube returns between 0 and 1\n                                return buffered * 100;\n                            }\n\n                            return 0;\n                        })();\n\n                        break;\n                }\n            }\n\n            // Set values\n            _setProgress(progress, value);\n        }\n\n        // Set <progress> value\n        function _setProgress(progress, value) {\n            if (!plyr.supported.full) {\n                return;\n            }\n\n            // Default to 0\n            if (_is.undefined(value)) {\n                value = 0;\n            }\n            // Default to buffer or bail\n            if (_is.undefined(progress)) {\n                if (plyr.progress && plyr.progress.buffer) {\n                    progress = plyr.progress.buffer;\n                } else {\n                    return;\n                }\n            }\n\n            // One progress element passed\n            if (_is.htmlElement(progress)) {\n                progress.value = value;\n            } else if (progress) {\n                // Object of progress + text element\n                if (progress.bar) {\n                    progress.bar.value = value;\n                }\n                if (progress.text) {\n                    progress.text.innerHTML = value;\n                }\n            }\n        }\n\n        // Update the displayed time\n        function _updateTimeDisplay(time, element) {\n            // Bail if there's no duration display\n            if (!element) {\n                return;\n            }\n\n            // Fallback to 0\n            if (isNaN(time)) {\n                time = 0;\n            }\n\n            plyr.secs = parseInt(time % 60);\n            plyr.mins = parseInt((time / 60) % 60);\n            plyr.hours = parseInt((time / 60 / 60) % 60);\n\n            // Do we need to display hours?\n            var displayHours = parseInt((_getDuration() / 60 / 60) % 60) > 0;\n\n            // Ensure it's two digits. For example, 03 rather than 3.\n            plyr.secs = ('0' + plyr.secs).slice(-2);\n            plyr.mins = ('0' + plyr.mins).slice(-2);\n\n            // Render\n            element.innerHTML = (displayHours ? plyr.hours + ':' : '') + plyr.mins + ':' + plyr.secs;\n        }\n\n        // Show the duration on metadataloaded\n        function _displayDuration() {\n            if (!plyr.supported.full) {\n                return;\n            }\n\n            // Determine duration\n            var duration = _getDuration() || 0;\n\n            // If there's only one time display, display duration there\n            if (!plyr.duration && config.displayDuration && plyr.media.paused) {\n                _updateTimeDisplay(duration, plyr.currentTime);\n            }\n\n            // If there's a duration element, update content\n            if (plyr.duration) {\n                _updateTimeDisplay(duration, plyr.duration);\n            }\n\n            // Update the tooltip (if visible)\n            _updateSeekTooltip();\n        }\n\n        // Handle time change event\n        function _timeUpdate(event) {\n            // Duration\n            _updateTimeDisplay(plyr.media.currentTime, plyr.currentTime);\n\n            // Ignore updates while seeking\n            if (event && event.type === 'timeupdate' && plyr.media.seeking) {\n                return;\n            }\n\n            // Playing progress\n            _updateProgress(event);\n        }\n\n        // Update seek range and progress\n        function _updateSeekDisplay(time) {\n            // Default to 0\n            if (!_is.number(time)) {\n                time = 0;\n            }\n\n            var duration = _getDuration(),\n                value = _getPercentage(time, duration);\n\n            // Update progress\n            if (plyr.progress && plyr.progress.played) {\n                plyr.progress.played.value = value;\n            }\n\n            // Update seek range input\n            if (plyr.buttons && plyr.buttons.seek) {\n                plyr.buttons.seek.value = value;\n            }\n        }\n\n        // Update hover tooltip for seeking\n        function _updateSeekTooltip(event) {\n            var duration = _getDuration();\n\n            // Bail if setting not true\n            if (!config.tooltips.seek || !plyr.progress.container || duration === 0) {\n                return;\n            }\n\n            // Calculate percentage\n            var clientRect = plyr.progress.container.getBoundingClientRect(),\n                percent = 0,\n                visible = config.classes.tooltip + '--visible';\n\n            // Determine percentage, if already visible\n            if (!event) {\n                if (_hasClass(plyr.progress.tooltip, visible)) {\n                    percent = plyr.progress.tooltip.style.left.replace('%', '');\n                } else {\n                    return;\n                }\n            } else {\n                percent = 100 / clientRect.width * (event.pageX - clientRect.left);\n            }\n\n            // Set bounds\n            if (percent < 0) {\n                percent = 0;\n            } else if (percent > 100) {\n                percent = 100;\n            }\n\n            // Display the time a click would seek to\n            _updateTimeDisplay(duration / 100 * percent, plyr.progress.tooltip);\n\n            // Set position\n            plyr.progress.tooltip.style.left = percent + '%';\n\n            // Show/hide the tooltip\n            // If the event is a moues in/out and percentage is inside bounds\n            if (event && _inArray(['mouseenter', 'mouseleave'], event.type)) {\n                _toggleClass(plyr.progress.tooltip, visible, event.type === 'mouseenter');\n            }\n        }\n\n        // Show the player controls in fullscreen mode\n        function _toggleControls(toggle) {\n            // Don't hide if config says not to, it's audio, or not ready or loading\n            if (!config.hideControls || plyr.type === 'audio') {\n                return;\n            }\n\n            var delay = 0,\n                isEnterFullscreen = false,\n                show = toggle,\n                loading = _hasClass(plyr.container, config.classes.loading);\n\n            // Default to false if no boolean\n            if (!_is.boolean(toggle)) {\n                if (toggle && toggle.type) {\n                    // Is the enter fullscreen event\n                    isEnterFullscreen = toggle.type === 'enterfullscreen';\n\n                    // Whether to show controls\n                    show = _inArray(['mousemove', 'touchstart', 'mouseenter', 'focus'], toggle.type);\n\n                    // Delay hiding on move events\n                    if (_inArray(['mousemove', 'touchmove'], toggle.type)) {\n                        delay = 2000;\n                    }\n\n                    // Delay a little more for keyboard users\n                    if (toggle.type === 'focus') {\n                        delay = 3000;\n                    }\n                } else {\n                    show = _hasClass(plyr.container, config.classes.hideControls);\n                }\n            }\n\n            // Clear timer every movement\n            window.clearTimeout(timers.hover);\n\n            // If the mouse is not over the controls, set a timeout to hide them\n            if (show || plyr.media.paused || loading) {\n                _toggleClass(plyr.container, config.classes.hideControls, false);\n\n                // Always show controls when paused or if touch\n                if (plyr.media.paused || loading) {\n                    return;\n                }\n\n                // Delay for hiding on touch\n                if (plyr.browser.isTouch) {\n                    delay = 3000;\n                }\n            }\n\n            // If toggle is false or if we're playing (regardless of toggle),\n            // then set the timer to hide the controls\n            if (!show || !plyr.media.paused) {\n                timers.hover = window.setTimeout(function() {\n                    // If the mouse is over the controls (and not entering fullscreen), bail\n                    if ((plyr.controls.pressed || plyr.controls.hover) && !isEnterFullscreen) {\n                        return;\n                    }\n\n                    _toggleClass(plyr.container, config.classes.hideControls, true);\n                }, delay);\n            }\n        }\n\n        // Add common function to retrieve media source\n        function _source(source) {\n            // If not null or undefined, parse it\n            if (!_is.undefined(source)) {\n                _updateSource(source);\n                return;\n            }\n\n            // Return the current source\n            var url;\n            switch (plyr.type) {\n                case 'youtube':\n                    url = plyr.embed.getVideoUrl();\n                    break;\n\n                case 'vimeo':\n                    plyr.embed.getVideoUrl.then(function(value) {\n                        url = value;\n                    });\n                    break;\n\n                case 'soundcloud':\n                    plyr.embed.getCurrentSound(function(object) {\n                        url = object.permalink_url;\n                    });\n                    break;\n\n                default:\n                    url = plyr.media.currentSrc;\n                    break;\n            }\n\n            return url || '';\n        }\n\n        // Update source\n        // Sources are not checked for support so be careful\n        function _updateSource(source) {\n            if (!_is.object(source) || !('sources' in source) || !source.sources.length) {\n                _warn('Invalid source format');\n                return;\n            }\n\n            // Remove ready class hook\n            _toggleClass(plyr.container, config.classes.ready, false);\n\n            // Pause playback\n            _pause();\n\n            // Update seek range and progress\n            _updateSeekDisplay();\n\n            // Reset buffer progress\n            _setProgress();\n\n            // Cancel current network requests\n            _cancelRequests();\n\n            // Setup new source\n            function setup() {\n                // Remove embed object\n                plyr.embed = null;\n\n                // Remove the old media\n                _remove(plyr.media);\n\n                // Remove video container\n                if (plyr.type === 'video' && plyr.videoContainer) {\n                    _remove(plyr.videoContainer);\n                }\n\n                // Reset class name\n                if (plyr.container) {\n                    plyr.container.removeAttribute('class');\n                }\n\n                // Set the type\n                if ('type' in source) {\n                    plyr.type = source.type;\n\n                    // Get child type for video (it might be an embed)\n                    if (plyr.type === 'video') {\n                        var firstSource = source.sources[0];\n\n                        if ('type' in firstSource && _inArray(config.types.embed, firstSource.type)) {\n                            plyr.type = firstSource.type;\n                        }\n                    }\n                }\n\n                // Check for support\n                plyr.supported = supported(plyr.type);\n\n                // Create new markup\n                switch (plyr.type) {\n                    case 'video':\n                        plyr.media = document.createElement('video');\n                        break;\n\n                    case 'audio':\n                        plyr.media = document.createElement('audio');\n                        break;\n\n                    case 'youtube':\n                    case 'vimeo':\n                    case 'soundcloud':\n                        plyr.media = document.createElement('div');\n                        plyr.embedId = source.sources[0].src;\n                        break;\n                }\n\n                // Inject the new element\n                _prependChild(plyr.container, plyr.media);\n\n                // Autoplay the new source?\n                if (_is.boolean(source.autoplay)) {\n                    config.autoplay = source.autoplay;\n                }\n\n                // Set attributes for audio and video\n                if (_inArray(config.types.html5, plyr.type)) {\n                    if (config.crossorigin) {\n                        plyr.media.setAttribute('crossorigin', '');\n                    }\n                    if (config.autoplay) {\n                        plyr.media.setAttribute('autoplay', '');\n                    }\n                    if ('poster' in source) {\n                        plyr.media.setAttribute('poster', source.poster);\n                    }\n                    if (config.loop) {\n                        plyr.media.setAttribute('loop', '');\n                    }\n                }\n\n                // Restore class hooks\n                _toggleClass(plyr.container, config.classes.fullscreen.active, plyr.isFullscreen);\n                _toggleClass(plyr.container, config.classes.captions.active, plyr.captionsEnabled);\n                _toggleStyleHook();\n\n                // Set new sources for html5\n                if (_inArray(config.types.html5, plyr.type)) {\n                    _insertChildElements('source', source.sources);\n                }\n\n                // Set up from scratch\n                _setupMedia();\n\n                // HTML5 stuff\n                if (_inArray(config.types.html5, plyr.type)) {\n                    // Setup captions\n                    if ('tracks' in source) {\n                        _insertChildElements('track', source.tracks);\n                    }\n\n                    // Load HTML5 sources\n                    plyr.media.load();\n                }\n\n                // If HTML5 or embed but not fully supported, setupInterface and call ready now\n                if (_inArray(config.types.html5, plyr.type) || (_inArray(config.types.embed, plyr.type) && !plyr.supported.full)) {\n                    // Setup interface\n                    _setupInterface();\n\n                    // Call ready\n                    _ready();\n                }\n\n                // Set aria title and iframe title\n                config.title = source.title;\n                _setTitle();\n            }\n\n            // Destroy instance adn wait for callback\n            // Vimeo throws a wobbly if you don't wait\n            _destroy(setup, false);\n        }\n\n        // Update poster\n        function _updatePoster(source) {\n            if (plyr.type === 'video') {\n                plyr.media.setAttribute('poster', source);\n            }\n        }\n\n        function onBodyClick() {\n            _toggleClass(_getElement('.' + config.classes.tabFocus), config.classes.tabFocus, false);\n        }\n\n        // Listen for control events\n        function _controlListeners() {\n            // IE doesn't support input event, so we fallback to change\n            var inputEvent = plyr.browser.isIE ? 'change' : 'input';\n\n            // Click play/pause helper\n            function togglePlay() {\n                var play = _togglePlay();\n\n                // Determine which buttons\n                var trigger = plyr.buttons[play ? 'play' : 'pause'],\n                    target = plyr.buttons[play ? 'pause' : 'play'];\n\n                // Get the last play button to account for the large play button\n                if (target) {\n                    if (target.length > 1) {\n                        target = target[target.length - 1];\n                    } else {\n                        target = target[0];\n                    }\n                }\n\n                // Setup focus and tab focus\n                if (target) {\n                    var hadTabFocus = _hasClass(trigger, config.classes.tabFocus);\n\n                    setTimeout(function() {\n                        target.focus();\n\n                        if (hadTabFocus) {\n                            _toggleClass(trigger, config.classes.tabFocus, false);\n                            _toggleClass(target, config.classes.tabFocus, true);\n                        }\n                    }, 100);\n                }\n            }\n\n            // Get the focused element\n            function getFocusElement() {\n                var focused = document.activeElement;\n\n                if (!focused || focused === document.body) {\n                    focused = null;\n                } else {\n                    focused = document.querySelector(':focus');\n                }\n\n                return focused;\n            }\n\n            // Get the key code for an event\n            function getKeyCode(event) {\n                return event.keyCode ? event.keyCode : event.which;\n            }\n\n            // Detect tab focus\n            function checkTabFocus(focused) {\n                for (var button in plyr.buttons) {\n                    var element = plyr.buttons[button];\n\n                    if (_is.nodeList(element)) {\n                        for (var i = 0; i < element.length; i++) {\n                            _toggleClass(element[i], config.classes.tabFocus, element[i] === focused);\n                        }\n                    } else {\n                        _toggleClass(element, config.classes.tabFocus, element === focused);\n                    }\n                }\n            }\n\n            // Keyboard shortcuts\n            if (config.keyboardShorcuts.focused) {\n                var last = null;\n\n                // Handle global presses\n                if (config.keyboardShorcuts.global) {\n                    _on(window, 'keydown keyup', function(event) {\n                        var code = getKeyCode(event),\n                            focused = getFocusElement(),\n                            allowed = [48, 49, 50, 51, 52, 53, 54, 56, 57, 75, 77, 70, 67],\n                            count = get().length;\n\n                        // Only handle global key press if there's only one player\n                        // and the key is in the allowed keys\n                        // and if the focused element is not editable (e.g. text input)\n                        // and any that accept key input http://webaim.org/techniques/keyboard/\n                        if (count === 1 && _inArray(allowed, code) && (!_is.htmlElement(focused) || !_matches(focused, config.selectors.editable))) {\n                            handleKey(event);\n                        }\n                    });\n                }\n\n                // Handle presses on focused\n                _on(plyr.container, 'keydown keyup', handleKey);\n            }\n\n            function handleKey(event) {\n                var code = getKeyCode(event),\n                    pressed = event.type === 'keydown',\n                    held = pressed && code === last;\n\n                // If the event is bubbled from the media element\n                // Firefox doesn't get the keycode for whatever reason\n                if (!_is.number(code)) {\n                    return;\n                }\n\n                // Seek by the number keys\n                function seekByKey() {\n                    // Get current duration\n                    var duration = plyr.media.duration;\n\n                    // Bail if we have no duration set\n                    if (!_is.number(duration)) {\n                        return;\n                    }\n\n                    // Divide the max duration into 10th's and times by the number value\n                    _seek(duration / 10 * (code - 48));\n                }\n\n                // Handle the key on keydown\n                // Reset on keyup\n                if (pressed) {\n                    // Which keycodes should we prevent default\n                    var preventDefault = [48, 49, 50, 51, 52, 53, 54, 56, 57, 32, 75, 38, 40, 77, 39, 37, 70, 67];\n\n                    // If the code is found prevent default (e.g. prevent scrolling for arrows)\n                    if (_inArray(preventDefault, code)) {\n                        event.preventDefault();\n                        event.stopPropagation();\n                    }\n\n                    switch (code) {\n                        // 0-9\n                        case 48:\n                        case 49:\n                        case 50:\n                        case 51:\n                        case 52:\n                        case 53:\n                        case 54:\n                        case 55:\n                        case 56:\n                        case 57:\n                            if (!held) {\n                                seekByKey();\n                            }\n                            break;\n                        // Space and K key\n                        case 32:\n                        case 75:\n                            if (!held) {\n                                _togglePlay();\n                            }\n                            break;\n                        // Arrow up\n                        case 38:\n                            _increaseVolume();\n                            break;\n                        // Arrow down\n                        case 40:\n                            _decreaseVolume();\n                            break;\n                        // M key\n                        case 77:\n                            if (!held) {\n                                _toggleMute();\n                            }\n                            break;\n                        // Arrow forward\n                        case 39:\n                            _forward();\n                            break;\n                        // Arrow back\n                        case 37:\n                            _rewind();\n                            break;\n                        // F key\n                        case 70:\n                            _toggleFullscreen();\n                            break;\n                        // C key\n                        case 67:\n                            if (!held) {\n                                _toggleCaptions();\n                            }\n                            break;\n                    }\n\n                    // Escape is handle natively when in full screen\n                    // So we only need to worry about non native\n                    if (!fullscreen.supportsFullScreen && plyr.isFullscreen && code === 27) {\n                        _toggleFullscreen();\n                    }\n\n                    // Store last code for next cycle\n                    last = code;\n                } else {\n                    last = null;\n                }\n            }\n\n            // Focus/tab management\n            _on(window, 'keyup', function(event) {\n                var code = getKeyCode(event),\n                    focused = getFocusElement();\n\n                if (code === 9) {\n                    checkTabFocus(focused);\n                }\n            });\n            _on(document.body, 'click', onBodyClick);\n            for (var button in plyr.buttons) {\n                var element = plyr.buttons[button];\n\n                _on(element, 'blur', function() {\n                    _toggleClass(element, 'tab-focus', false);\n                });\n            }\n\n            // Play\n            _proxyListener(plyr.buttons.play, 'click', config.listeners.play, togglePlay);\n\n            // Pause\n            _proxyListener(plyr.buttons.pause, 'click', config.listeners.pause, togglePlay);\n\n            // Restart\n            _proxyListener(plyr.buttons.restart, 'click', config.listeners.restart, _seek);\n\n            // Rewind\n            _proxyListener(plyr.buttons.rewind, 'click', config.listeners.rewind, _rewind);\n\n            // Fast forward\n            _proxyListener(plyr.buttons.forward, 'click', config.listeners.forward, _forward);\n\n            // Seek\n            _proxyListener(plyr.buttons.seek, inputEvent, config.listeners.seek, _seek);\n\n            // Set volume\n            _proxyListener(plyr.volume.input, inputEvent, config.listeners.volume, function() {\n                _setVolume(plyr.volume.input.value);\n            });\n\n            // Mute\n            _proxyListener(plyr.buttons.mute, 'click', config.listeners.mute, _toggleMute);\n\n            // Fullscreen\n            _proxyListener(plyr.buttons.fullscreen, 'click', config.listeners.fullscreen, _toggleFullscreen);\n\n            // Handle user exiting fullscreen by escaping etc\n            if (fullscreen.supportsFullScreen) {\n                _on(document, fullscreen.fullScreenEventName, _toggleFullscreen);\n            }\n\n            // Captions\n            _proxyListener(plyr.buttons.captions, 'click', config.listeners.captions, _toggleCaptions);\n\n            // Seek tooltip\n            _on(plyr.progress.container, 'mouseenter mouseleave mousemove', _updateSeekTooltip);\n\n            // Toggle controls visibility based on mouse movement\n            if (config.hideControls) {\n                // Toggle controls on mouse events and entering fullscreen\n                _on(plyr.container, 'mouseenter mouseleave mousemove touchstart touchend touchcancel touchmove enterfullscreen', _toggleControls);\n\n                // Watch for cursor over controls so they don't hide when trying to interact\n                _on(plyr.controls, 'mouseenter mouseleave', function(event) {\n                    plyr.controls.hover = event.type === 'mouseenter';\n                });\n\n                // Watch for cursor over controls so they don't hide when trying to interact\n                _on(plyr.controls, 'mousedown mouseup touchstart touchend touchcancel', function(event) {\n                    plyr.controls.pressed = _inArray(['mousedown', 'touchstart'], event.type);\n                });\n\n                // Focus in/out on controls\n                _on(plyr.controls, 'focus blur', _toggleControls, true);\n            }\n\n            // Adjust volume on scroll\n            _on(plyr.volume.input, 'wheel', function(event) {\n                event.preventDefault();\n\n                // Detect \"natural\" scroll - suppored on OS X Safari only\n                // Other browsers on OS X will be inverted until support improves\n                var inverted = event.webkitDirectionInvertedFromDevice,\n                    step = config.volumeStep / 5;\n\n                // Scroll down (or up on natural) to decrease\n                if (event.deltaY < 0 || event.deltaX > 0) {\n                    if (inverted) {\n                        _decreaseVolume(step);\n                    } else {\n                        _increaseVolume(step);\n                    }\n                }\n\n                // Scroll up (or down on natural) to increase\n                if (event.deltaY > 0 || event.deltaX < 0) {\n                    if (inverted) {\n                        _increaseVolume(step);\n                    } else {\n                        _decreaseVolume(step);\n                    }\n                }\n            });\n        }\n\n        // Listen for media events\n        function _mediaListeners() {\n            // Time change on media\n            _on(plyr.media, 'timeupdate seeking', _timeUpdate);\n\n            // Update manual captions\n            _on(plyr.media, 'timeupdate', _seekManualCaptions);\n\n            // Display duration\n            _on(plyr.media, 'durationchange loadedmetadata', _displayDuration);\n\n            // Handle the media finishing\n            _on(plyr.media, 'ended', function() {\n                // Show poster on end\n                if (plyr.type === 'video' && config.showPosterOnEnd) {\n                    // Clear\n                    if (plyr.type === 'video') {\n                        _setCaption();\n                    }\n\n                    // Restart\n                    _seek();\n\n                    // Re-load media\n                    plyr.media.load();\n                }\n            });\n\n            // Check for buffer progress\n            _on(plyr.media, 'progress playing', _updateProgress);\n\n            // Handle native mute\n            _on(plyr.media, 'volumechange', _updateVolume);\n\n            // Handle native play/pause\n            _on(plyr.media, 'play pause ended', _checkPlaying);\n\n            // Loading\n            _on(plyr.media, 'waiting canplay seeked', _checkLoading);\n\n            // Click video\n            if (config.clickToPlay && plyr.type !== 'audio') {\n                // Re-fetch the wrapper\n                var wrapper = _getElement('.' + config.classes.videoWrapper);\n\n                // Bail if there's no wrapper (this should never happen)\n                if (!wrapper) {\n                    return;\n                }\n\n                // Set cursor\n                wrapper.style.cursor = 'pointer';\n\n                // On click play, pause ore restart\n                _on(wrapper, 'click', function() {\n                    // Touch devices will just show controls (if we're hiding controls)\n                    if (config.hideControls && plyr.browser.isTouch && !plyr.media.paused) {\n                        return;\n                    }\n\n                    if (plyr.media.paused) {\n                        _play();\n                    } else if (plyr.media.ended) {\n                        _seek();\n                        _play();\n                    } else {\n                        _pause();\n                    }\n                });\n            }\n\n            // Disable right click\n            if (config.disableContextMenu) {\n                _on(plyr.media, 'contextmenu', function(event) {\n                    event.preventDefault();\n                });\n            }\n\n            // Proxy events to container\n            // Bubble up key events for Edge\n            _on(plyr.media, config.events.concat(['keyup', 'keydown']).join(' '), function(event) {\n                _triggerEvent(plyr.container, event.type, true);\n            });\n        }\n\n        // Cancel current network requests\n        // See https://github.com/sampotts/plyr/issues/174\n        function _cancelRequests() {\n            if (!_inArray(config.types.html5, plyr.type)) {\n                return;\n            }\n\n            // Remove child sources\n            var sources = plyr.media.querySelectorAll('source');\n            for (var i = 0; i < sources.length; i++) {\n                _remove(sources[i]);\n            }\n\n            // Set blank video src attribute\n            // This is to prevent a MEDIA_ERR_SRC_NOT_SUPPORTED error\n            // Info: http://stackoverflow.com/questions/32231579/how-to-properly-dispose-of-an-html5-video-and-close-socket-or-connection\n            plyr.media.setAttribute('src', config.blankUrl);\n\n            // Load the new empty source\n            // This will cancel existing requests\n            // See https://github.com/sampotts/plyr/issues/174\n            plyr.media.load();\n\n            // Debugging\n            _log('Cancelled network requests');\n        }\n\n        // Destroy an instance\n        // Event listeners are removed when elements are removed\n        // http://stackoverflow.com/questions/12528049/if-a-dom-element-is-removed-are-its-listeners-also-removed-from-memory\n        function _destroy(callback, restore) {\n            // Bail if the element is not initialized\n            if (!plyr.init) {\n                return null;\n            }\n\n            // Type specific stuff\n            switch (plyr.type) {\n                case 'youtube':\n                    // Clear timers\n                    window.clearInterval(timers.buffering);\n                    window.clearInterval(timers.playing);\n\n                    // Destroy YouTube API\n                    plyr.embed.destroy();\n\n                    // Clean up\n                    cleanUp();\n\n                    break;\n\n                case 'vimeo':\n                    // Destroy Vimeo API\n                    // then clean up (wait, to prevent postmessage errors)\n                    plyr.embed.unload().then(cleanUp);\n\n                    // Vimeo does not always return\n                    timers.cleanUp = window.setTimeout(cleanUp, 200);\n\n                    break;\n\n                case 'video':\n                case 'audio':\n                    // Restore native video controls\n                    _toggleNativeControls(true);\n\n                    // Clean up\n                    cleanUp();\n\n                    break;\n            }\n\n            function cleanUp() {\n                clearTimeout(timers.cleanUp);\n\n                // Default to restore original element\n                if (!_is.boolean(restore)) {\n                    restore = true;\n                }\n\n                // Callback\n                if (_is.function(callback)) {\n                    callback.call(original);\n                }\n\n                // Bail if we don't need to restore the original element\n                if (!restore) {\n                    return;\n                }\n\n                // Remove init flag\n                plyr.init = false;\n\n                // Replace the container with the original element provided\n                plyr.container.parentNode.replaceChild(original, plyr.container);\n\n                // Free container in order for GC to remove it and prevent memory leaks due to added events\n                plyr.container = null;\n\n                // Allow overflow (set on fullscreen)\n                document.body.style.overflow = '';\n\n                //remove events\n                _off(document.body, 'click', onBodyClick);\n\n                // Event\n                _triggerEvent(original, 'destroyed', true);\n            }\n        }\n\n        // Setup a player\n        function _init() {\n            // Bail if the element is initialized\n            if (plyr.init) {\n                return null;\n            }\n\n            // Setup the fullscreen api\n            fullscreen = _fullscreen();\n\n            // Sniff out the browser\n            plyr.browser = _browserSniff();\n\n            // Bail if nothing to setup\n            if (!_is.htmlElement(plyr.media)) {\n                return;\n            }\n\n            // Load saved settings from localStorage\n            _setupStorage();\n\n            // Set media type based on tag or data attribute\n            // Supported: video, audio, vimeo, youtube\n            var tagName = media.tagName.toLowerCase();\n            if (tagName === 'div') {\n                plyr.type = media.getAttribute('data-type');\n                plyr.embedId = media.getAttribute('data-video-id');\n\n                // Clean up\n                media.removeAttribute('data-type');\n                media.removeAttribute('data-video-id');\n            } else {\n                plyr.type = tagName;\n                config.crossorigin = media.getAttribute('crossorigin') !== null;\n                config.autoplay = config.autoplay || media.getAttribute('autoplay') !== null;\n                config.loop = config.loop || media.getAttribute('loop') !== null;\n            }\n\n            // Check for support\n            plyr.supported = supported(plyr.type);\n\n            // If no native support, bail\n            if (!plyr.supported.basic) {\n                return;\n            }\n\n            // Wrap media\n            plyr.container = _wrap(media, document.createElement('div'));\n\n            // Allow focus to be captured\n            plyr.container.setAttribute('tabindex', 0);\n\n            // Add style hook\n            _toggleStyleHook();\n\n            // Debug info\n            _log('' + plyr.browser.name + ' ' + plyr.browser.version);\n\n            // Setup media\n            _setupMedia();\n\n            // Setup interface\n            // If embed but not fully supported, setupInterface (to avoid flash of controls) and call ready now\n            if (_inArray(config.types.html5, plyr.type) || (_inArray(config.types.embed, plyr.type) && !plyr.supported.full)) {\n                // Setup UI\n                _setupInterface();\n\n                // Call ready\n                _ready();\n\n                // Set title on button and frame\n                _setTitle();\n            }\n\n            // Successful setup\n            plyr.init = true;\n        }\n\n        // Setup the UI\n        function _setupInterface() {\n            // Don't setup interface if no support\n            if (!plyr.supported.full) {\n                _warn('Basic support only', plyr.type);\n\n                // Remove controls\n                _remove(_getElement(config.selectors.controls.wrapper));\n\n                // Remove large play\n                _remove(_getElement(config.selectors.buttons.play));\n\n                // Restore native controls\n                _toggleNativeControls(true);\n\n                // Bail\n                return;\n            }\n\n            // Inject custom controls if not present\n            var controlsMissing = !_getElements(config.selectors.controls.wrapper).length;\n            if (controlsMissing) {\n                // Inject custom controls\n                _injectControls();\n            }\n\n            // Find the elements\n            if (!_findElements()) {\n                return;\n            }\n\n            // If the controls are injected, re-bind listeners for controls\n            if (controlsMissing) {\n                _controlListeners();\n            }\n\n            // Media element listeners\n            _mediaListeners();\n\n            // Remove native controls\n            _toggleNativeControls();\n\n            // Setup fullscreen\n            _setupFullscreen();\n\n            // Captions\n            _setupCaptions();\n\n            // Set volume\n            _setVolume();\n            _updateVolume();\n\n            // Reset time display\n            _timeUpdate();\n\n            // Update the UI\n            _checkPlaying();\n\n            // Display duration\n            _displayDuration();\n        }\n\n        api = {\n            getOriginal: function() {\n                return original;\n            },\n            getContainer: function() {\n                return plyr.container;\n            },\n            getEmbed: function() {\n                return plyr.embed;\n            },\n            getMedia: function() {\n                return plyr.media;\n            },\n            getType: function() {\n                return plyr.type;\n            },\n            getDuration: _getDuration,\n            getCurrentTime: function() {\n                return plyr.media.currentTime;\n            },\n            getVolume: function() {\n                return plyr.media.volume;\n            },\n            isMuted: function() {\n                return plyr.media.muted;\n            },\n            isReady: function() {\n                return _hasClass(plyr.container, config.classes.ready);\n            },\n            isLoading: function() {\n                return _hasClass(plyr.container, config.classes.loading);\n            },\n            isPaused: function() {\n                return plyr.media.paused;\n            },\n            on: function(event, callback) {\n                _on(plyr.container, event, callback);\n                return this;\n            },\n            play: _play,\n            pause: _pause,\n            stop: function() {\n                _pause();\n                _seek();\n            },\n            restart: _seek,\n            rewind: _rewind,\n            forward: _forward,\n            seek: _seek,\n            source: _source,\n            poster: _updatePoster,\n            setVolume: _setVolume,\n            togglePlay: _togglePlay,\n            toggleMute: _toggleMute,\n            toggleCaptions: _toggleCaptions,\n            toggleFullscreen: _toggleFullscreen,\n            toggleControls: _toggleControls,\n            isFullscreen: function() {\n                return plyr.isFullscreen || false;\n            },\n            support: function(mimeType) {\n                return _supportMime(plyr, mimeType);\n            },\n            destroy: _destroy,\n        };\n\n        // Everything done\n        function _ready() {\n            // Ready event at end of execution stack\n            window.setTimeout(function() {\n                _triggerEvent(plyr.media, 'ready');\n            }, 0);\n\n            // Set class hook on media element\n            _toggleClass(plyr.media, defaults.classes.setup, true);\n\n            // Set container class for ready\n            _toggleClass(plyr.container, config.classes.ready, true);\n\n            // Store a refernce to instance\n            plyr.media.plyr = api;\n\n            // Autoplay\n            if (config.autoplay) {\n                _play();\n            }\n        }\n\n        // Initialize instance\n        _init();\n\n        // If init failed, return null\n        if (!plyr.init) {\n            return null;\n        }\n\n        return api;\n    }\n\n    // Load a sprite\n    function loadSprite(url, id) {\n        var x = new XMLHttpRequest();\n\n        // If the id is set and sprite exists, bail\n        if (_is.string(id) && _is.htmlElement(document.querySelector('#' + id))) {\n            return;\n        }\n\n        // Create placeholder (to prevent loading twice)\n        var container = document.createElement('div');\n        container.setAttribute('hidden', '');\n        if (_is.string(id)) {\n            container.setAttribute('id', id);\n        }\n        document.body.insertBefore(container, document.body.childNodes[0]);\n\n        // Check for CORS support\n        if ('withCredentials' in x) {\n            x.open('GET', url, true);\n        } else {\n            return;\n        }\n\n        // Inject hidden div with sprite on load\n        x.onload = function() {\n            container.innerHTML = x.responseText;\n        };\n\n        x.send();\n    }\n\n    // Check for support\n    function supported(type) {\n        var browser = _browserSniff(),\n            isOldIE = browser.isIE && browser.version <= 9,\n            isIos = browser.isIos,\n            isIphone = browser.isIphone,\n            audioSupport = !!document.createElement('audio').canPlayType,\n            videoSupport = !!document.createElement('video').canPlayType,\n            basic = false,\n            full = false;\n\n        switch (type) {\n            case 'video':\n                basic = videoSupport;\n                full = basic && (!isOldIE && !isIphone);\n                break;\n\n            case 'audio':\n                basic = audioSupport;\n                full = basic && !isOldIE;\n                break;\n\n            // Vimeo does not seem to be supported on iOS via API\n            // Issue raised https://github.com/vimeo/player.js/issues/87\n            case 'vimeo':\n                basic = true;\n                full = !isOldIE && !isIos;\n                break;\n\n            case 'youtube':\n                basic = true;\n                full = !isOldIE && !isIos;\n\n                // YouTube seems to work on iOS 10+ on iPad\n                if (isIos && !isIphone && browser.version >= 10) {\n                    full = true;\n                }\n\n                break;\n\n            case 'soundcloud':\n                basic = true;\n                full = !isOldIE && !isIphone;\n                break;\n\n            default:\n                basic = audioSupport && videoSupport;\n                full = basic && !isOldIE;\n        }\n\n        return {\n            basic: basic,\n            full: full,\n        };\n    }\n\n    // Setup function\n    function setup(targets, options) {\n        // Get the players\n        var players = [],\n            instances = [],\n            selector = [defaults.selectors.html5, defaults.selectors.embed].join(',');\n\n        // Select the elements\n        if (_is.string(targets)) {\n            // String selector passed\n            targets = document.querySelectorAll(targets);\n        } else if (_is.htmlElement(targets)) {\n            // Single HTMLElement passed\n            targets = [targets];\n        } else if (!_is.nodeList(targets) && !_is.array(targets) && !_is.string(targets)) {\n            // No selector passed, possibly options as first argument\n            // If options are the first argument\n            if (_is.undefined(options) && _is.object(targets)) {\n                options = targets;\n            }\n\n            // Use default selector\n            targets = document.querySelectorAll(selector);\n        }\n\n        // Convert NodeList to array\n        if (_is.nodeList(targets)) {\n            targets = Array.prototype.slice.call(targets);\n        }\n\n        // Bail if disabled or no basic support\n        // You may want to disable certain UAs etc\n        if (!supported().basic || !targets.length) {\n            return false;\n        }\n\n        // Add to container list\n        function add(target, media) {\n            if (!_hasClass(media, defaults.classes.hook)) {\n                players.push({\n                    // Always wrap in a <div> for styling\n                    //container:  _wrap(media, document.createElement('div')),\n                    // Could be a container or the media itself\n                    target: target,\n                    // This should be the <video>, <audio> or <div> (YouTube/Vimeo)\n                    media: media,\n                });\n            }\n        }\n\n        // Check if the targets have multiple media elements\n        for (var i = 0; i < targets.length; i++) {\n            var target = targets[i];\n\n            // Get children\n            var children = target.querySelectorAll(selector);\n\n            // If there's more than one media element child, wrap them\n            if (children.length) {\n                for (var x = 0; x < children.length; x++) {\n                    add(target, children[x]);\n                }\n            } else if (_matches(target, selector)) {\n                // Target is media element\n                add(target, target);\n            }\n        }\n\n        // Create a player instance for each element\n        players.forEach(function(player) {\n            var element = player.target,\n                media = player.media,\n                match = false;\n\n            // The target element can also be the media element\n            if (media === element) {\n                match = true;\n            }\n\n            // Setup a player instance and add to the element\n            // Create instance-specific config\n            var data = {};\n\n            // Try parsing data attribute config\n            try {\n                data = JSON.parse(element.getAttribute('data-plyr'));\n            } catch (e) {}\n\n            var config = _extend({}, defaults, options, data);\n\n            // Bail if not enabled\n            if (!config.enabled) {\n                return null;\n            }\n\n            // Create new instance\n            var instance = new Plyr(media, config);\n\n            // Go to next if setup failed\n            if (!_is.object(instance)) {\n                return;\n            }\n\n            // Listen for events if debugging\n            if (config.debug) {\n                var events = config.events.concat(['setup', 'statechange', 'enterfullscreen', 'exitfullscreen', 'captionsenabled', 'captionsdisabled']);\n\n                _on(instance.getContainer(), events.join(' '), function(event) {\n                    console.log([config.logPrefix, 'event:', event.type].join(' '), event.detail.plyr);\n                });\n            }\n\n            // Callback\n            _event(instance.getContainer(), 'setup', true, {\n                plyr: instance,\n            });\n\n            // Add to return array even if it's already setup\n            instances.push(instance);\n        });\n\n        return instances;\n    }\n\n    // Get all instances within a provided container\n    function get(container) {\n        if (_is.string(container)) {\n            // Get selector if string passed\n            container = document.querySelector(container);\n        } else if (_is.undefined(container)) {\n            // Use body by default to get all on page\n            container = document.body;\n        }\n\n        // If we have a HTML element\n        if (_is.htmlElement(container)) {\n            var elements = container.querySelectorAll('.' + defaults.classes.setup),\n                instances = [];\n\n            Array.prototype.slice.call(elements).forEach(function(element) {\n                if (_is.object(element.plyr)) {\n                    instances.push(element.plyr);\n                }\n            });\n\n            return instances;\n        }\n\n        return [];\n    }\n\n    return {\n        setup: setup,\n        supported: supported,\n        loadSprite: loadSprite,\n        get: get,\n    };\n});\n\n// Custom event polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n(function() {\n    if (typeof window.CustomEvent === 'function') {\n        return;\n    }\n\n    function CustomEvent(event, params) {\n        params = params || { bubbles: false, cancelable: false, detail: undefined };\n        var evt = document.createEvent('CustomEvent');\n        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n        return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n\n    window.CustomEvent = CustomEvent;\n})();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/plyr/src/js/plyr.js\n// module id = 25\n// module chunks = 0\n//# sourceURL=webpack:///./~/plyr/src/js/plyr.js?")
},function(module,exports){eval('function NavTabs(node){\n    this.node = node;\n    this.init();\n}\n\nNavTabs.prototype.init = function(){\n\t// store tabs variable\n\tvar myTabs = document.querySelectorAll("ul.nav-tabs > li");\n\n\tfunction myTabClicks(tabClickEvent) {\n\n\t\tfor (var i = 0; i < myTabs.length; i++) {\n\t\t\tmyTabs[i].classList.remove("active");\n\t\t}\n\n\t\tvar clickedTab = tabClickEvent.currentTarget;\n\n\t\tclickedTab.classList.add("active");\n\n\t\ttabClickEvent.preventDefault();\n\n\t\tvar myContentPanes = document.querySelectorAll(".tab-pane");\n\n\t\tfor (i = 0; i < myContentPanes.length; i++) {\n\t\t\tmyContentPanes[i].classList.remove("active");\n\t\t}\n\n\t\tvar anchorReference = tabClickEvent.target;\n\t\tvar activePaneId = anchorReference.getAttribute("href");\n\t\tvar activePane = document.querySelector(activePaneId);\n\n\t\tactivePane.classList.add("active");\n\n\t}\n\n\tfor (i = 0; i < myTabs.length; i++) {\n\t\tmyTabs[i].addEventListener("click", myTabClicks)\n\t}\n\n}\n\nmodule.exports = NavTabs;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./assets/scripts/widgets/nav-tabs.js\n// module id = 26\n// module chunks = 0\n//# sourceURL=webpack:///./assets/scripts/widgets/nav-tabs.js?')},function(module,exports){eval("function StaffOverlay(node){\n    this.node = node;\n    this.init();\n}\n\nStaffOverlay.prototype.init = function(){\n    var lnk = this.node.querySelector('[data-target]');\n\n    this.h3 = this.node.querySelector('h3').innerText;\n    this.h5 = this.node.querySelector('h5').innerText;\n    this.content = this.node.querySelector('.staff-panel--hidden-content').innerText;\n\n    this.overlay = document.getElementById('overlayHook');\n    this.overlayH3 = this.overlay.querySelector('h3');\n    this.overlayH5 = this.overlay.querySelector('h5');\n    this.overlayP = this.overlay.querySelector('p');\n\n    var bg = document.getElementById('overlayBackgroundHook');\n    var close = this.overlay.querySelector('.map__overlay--close');\n    var cxt = this;\n\n    close.addEventListener('click', function(e){\n        e.preventDefault();\n        cxt.overlay.classList.remove('active');\n        bg.classList.remove('active');\n        setTimeout(function(){\n            bg.style.zIndex = -1;\n        }, 300);\n    });\n\n    lnk.addEventListener('click', function(e){\n        e.preventDefault();\n        bg.classList.add('active');\n        bg.style.zIndex = 998;\n        cxt.overlay.classList.add('active');\n        cxt.populateOverlay();\n    });\n}\n\nStaffOverlay.prototype.populateOverlay = function(){\n    this.overlayH3.innerText = this.h3;\n    this.overlayH5.innerText = this.h5;\n    this.overlayP.innerText = this.content;\n}\n\nmodule.exports = StaffOverlay;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./assets/scripts/widgets/staff-overlay.js\n// module id = 27\n// module chunks = 0\n//# sourceURL=webpack:///./assets/scripts/widgets/staff-overlay.js?")},function(module,exports,__webpack_require__){eval("var Isotope = __webpack_require__(29);\nvar Promise = __webpack_require__(7);\n\n\nfunction Matrix(node){\n    this.node = node;\n    this.setVars();\n    this.init();\n}\n\nMatrix.prototype.setVars = function(){\n    this.css = {\n        states : {\n            'init' : 'init',\n            'active' : 'active',\n            'disabled' : 'disabled',\n            'dblWidth' : 'grid-item--width2'\n        },\n        selectors : {\n            'grid' : '.grid',\n            'newsNavigation' : '.grid--navigation',\n            'btn' : '.btn__primary--teal',\n            'gridMatrix' : '.grid--matrix',\n            'gridItem' : '.grid-item'\n        }\n    }\n}\n\n\nMatrix.prototype.init = function(){\n    this.elem = this.node.querySelector(this.css.selectors.grid);\n    this.navigation = this.node.querySelector(this.css.selectors.newsNavigation);\n    this.navAnchor = this.navigation.querySelectorAll('a');\n    this.btn = this.node.querySelector(this.css.selectors.btn);\n    this.gridMatrix = this.node.querySelector(this.css.selectors.gridMatrix);\n    this.gridItem = this.node.querySelectorAll(this.css.selectors.gridItem);\n\n    var cxt = this;\n\n    //check whether it already contains properties and has initialised\n    if(!this.node.classList.contains(cxt.css.states.init)) {\n        cxt.get('json/news.json').then(function(news) {\n            for (var i = 0; i < news.length; i++) {\n                if(i < 12) {\n                    cxt.buildNewsItem(news[i], news[i].img, news[i].date, news[i].title, news[i].url, news[i].cat);\n                }\n                cxt.setClassNames(); // set class names\n                cxt.setGrid();\n            }\n           cxt.node.classList.add(cxt.css.states.init);\n        }, function(error) {\n          console.error(\"Failed!\", error);\n        });\n    }\n\n\n    [].forEach.call(this.navAnchor, function(element, index, array){\n        element.addEventListener('click', function(e){\n            e.preventDefault();\n            var active = cxt.navigation.querySelector('.'+cxt.css.states.active);\n            active.classList.remove(cxt.css.states.active);\n            e.currentTarget.parentNode.classList.add(cxt.css.states.active);\n            var filterValue = e.currentTarget.getAttribute('data-filter');\n            cxt.iso.arrange({filter: filterValue});\n            cxt.setClassNames(); // set class names\n            cxt.iso.layout(); //reset layout\n        });\n    });\n\n    this.btn.addEventListener('click', this.loadData.bind(this));\n}\n\n\nMatrix.prototype.loadData = function(e){\n    //load more button functionality\n    // NOTE: move json out into seperate method\n    var cxt = this;\n    e.preventDefault();\n\n    var activeFilter = this.navigation.querySelector('.active').childNodes[0];\n    var activeFilterValue = activeFilter.getAttribute('data-filter');\n\n    this.gridItem = this.node.querySelectorAll(this.css.selectors.gridItem);\n\n    if(!e.currentTarget.classList.contains(cxt.css.states.disabled)) {\n\n        cxt.get('json/news.json').then(function(news) {\n\n            var newsMax = news.length; //max number of locations\n            var panelsMax = cxt.gridItem.length;\n            var num2Load = 3;\n\n            if(newsMax <= (panelsMax+num2Load)) {\n                cxt.btn.classList.add(cxt.css.states.disabled);\n                for (i = panelsMax; i < (panelsMax+num2Load); i++) {\n                    cxt.buildNewsItem(news[i], news[i].img, news[i].date, news[i].title, news[i].url, news[i].cat);\n                }\n                cxt.setClassNames(); // set class names\n                cxt.iso.layout(); //reset layout\n            } else {\n                for (i = panelsMax; i < (panelsMax+num2Load); i++) {\n                    cxt.buildNewsItem(news[i], news[i].img, news[i].date, news[i].title, news[i].url, news[i].cat);\n                }\n                cxt.setClassNames(); // set class names\n                cxt.iso.layout(); //reset layout\n            }\n\n        }, function(error) {\n          console.error(\"Failed!\", error);\n        });\n\n    }\n\n}\n\n\nMatrix.prototype.setClassNames = function(e){\n    var cxt = this;\n    var arr = [];\n    var k = 0;\n\n    this.gridItem = this.node.querySelectorAll(this.css.selectors.gridItem);\n\n    [].forEach.call(this.gridItem, function(element, index, array){\n        element.classList.remove(cxt.css.states.dblWidth);\n        var l = arr.length;\n\n        if(l == 0 || l == 5) {\n            element.classList.add(cxt.css.states.dblWidth);\n        } else if(l == 6) {\n            element.classList.add(cxt.css.states.dblWidth);\n            arr = [];\n            k = 0;\n        }\n\n        arr.push(k);\n        k++;\n    });\n}\n\nMatrix.prototype.setGrid = function(e){\n    this.iso = new Isotope( this.elem, {\n      itemSelector: '.grid-item',\n      layoutMode: 'fitRows'\n    });\n}\n\n\nMatrix.prototype.buildNewsItem = function(data, img, date, title, url, cat) {\n\n    var parent = document.createElement('a');\n    var content = document.createElement('div');\n    var a = document.createElement('a');\n    var p1 = document.createElement('p');\n    var p2 = document.createElement('p');\n\n    a.innerText = title;\n    a.setAttribute('href', url);\n    p2.innerText = date;\n    console.log(img);\n    parent.classList.add('grid-item');\n    parent.classList.add(cat);\n    parent.setAttribute('href', url);\n    content.classList.add('grid-item__content');\n    content.style.backgroundImage = \"url('\"+img+\"')\";\n    p1.classList.add('grid-item__content--title');\n    p2.classList.add('grid-item__content--date');\n    parent.appendChild(content);\n    content.appendChild(p1);\n    content.appendChild(p2);\n    p1.appendChild(a);\n\n    if(this.node.classList.contains(this.css.states.init)) {\n        this.iso.insert(parent);\n    } else {\n        this.gridMatrix.appendChild(parent);\n    }\n}\n\n\nMatrix.prototype.get = function(url) {\n\n  return new Promise(function(resolve, reject) {\n\n    var req = new XMLHttpRequest();\n    req.open('GET', url);\n\n    req.onload = function() {\n\n      if (req.status == 200) {\n        resolve(JSON.parse(req.response));\n      }\n      else {\n        reject(Error(req.statusText));\n      }\n    };\n\n    // Handle network errors\n    req.onerror = function() {\n      reject(Error(\"Network Error\"));\n    };\n\n    req.send();\n  });\n}\n\nmodule.exports = Matrix;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./assets/scripts/widgets/matrix.js\n// module id = 28\n// module chunks = 0\n//# sourceURL=webpack:///./assets/scripts/widgets/matrix.js?")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Isotope v3.0.4\n *\n * Licensed GPLv3 for open source use\n * or Isotope Commercial License for commercial use\n *\n * http://isotope.metafizzy.co\n * Copyright 2017 Metafizzy\n */\n\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /*globals define, module, require */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(33),\n        __webpack_require__(30),\n        __webpack_require__(31),\n        __webpack_require__(32),\n        __webpack_require__(41),\n        __webpack_require__(36),\n        // include default layout modes\n        __webpack_require__(37),\n        __webpack_require__(39),\n        __webpack_require__(40)\n      ], __WEBPACK_AMD_DEFINE_RESULT__ = function( Outlayer, getSize, matchesSelector, utils, Item, LayoutMode ) {\n        return factory( window, Outlayer, getSize, matchesSelector, utils, Item, LayoutMode );\n      }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      window,\n      require('outlayer'),\n      require('get-size'),\n      require('desandro-matches-selector'),\n      require('fizzy-ui-utils'),\n      require('./item'),\n      require('./layout-mode'),\n      // include default layout modes\n      require('./layout-modes/masonry'),\n      require('./layout-modes/fit-rows'),\n      require('./layout-modes/vertical')\n    );\n  } else {\n    // browser global\n    window.Isotope = factory(\n      window,\n      window.Outlayer,\n      window.getSize,\n      window.matchesSelector,\n      window.fizzyUIUtils,\n      window.Isotope.Item,\n      window.Isotope.LayoutMode\n    );\n  }\n\n}( window, function factory( window, Outlayer, getSize, matchesSelector, utils,\n  Item, LayoutMode ) {\n\n'use strict';\n\n// -------------------------- vars -------------------------- //\n\nvar jQuery = window.jQuery;\n\n// -------------------------- helpers -------------------------- //\n\nvar trim = String.prototype.trim ?\n  function( str ) {\n    return str.trim();\n  } :\n  function( str ) {\n    return str.replace( /^\\s+|\\s+$/g, '' );\n  };\n\n// -------------------------- isotopeDefinition -------------------------- //\n\n  // create an Outlayer layout class\n  var Isotope = Outlayer.create( 'isotope', {\n    layoutMode: 'masonry',\n    isJQueryFiltering: true,\n    sortAscending: true\n  });\n\n  Isotope.Item = Item;\n  Isotope.LayoutMode = LayoutMode;\n\n  var proto = Isotope.prototype;\n\n  proto._create = function() {\n    this.itemGUID = 0;\n    // functions that sort items\n    this._sorters = {};\n    this._getSorters();\n    // call super\n    Outlayer.prototype._create.call( this );\n\n    // create layout modes\n    this.modes = {};\n    // start filteredItems with all items\n    this.filteredItems = this.items;\n    // keep of track of sortBys\n    this.sortHistory = [ 'original-order' ];\n    // create from registered layout modes\n    for ( var name in LayoutMode.modes ) {\n      this._initLayoutMode( name );\n    }\n  };\n\n  proto.reloadItems = function() {\n    // reset item ID counter\n    this.itemGUID = 0;\n    // call super\n    Outlayer.prototype.reloadItems.call( this );\n  };\n\n  proto._itemize = function() {\n    var items = Outlayer.prototype._itemize.apply( this, arguments );\n    // assign ID for original-order\n    for ( var i=0; i < items.length; i++ ) {\n      var item = items[i];\n      item.id = this.itemGUID++;\n    }\n    this._updateItemsSortData( items );\n    return items;\n  };\n\n\n  // -------------------------- layout -------------------------- //\n\n  proto._initLayoutMode = function( name ) {\n    var Mode = LayoutMode.modes[ name ];\n    // set mode options\n    // HACK extend initial options, back-fill in default options\n    var initialOpts = this.options[ name ] || {};\n    this.options[ name ] = Mode.options ?\n      utils.extend( Mode.options, initialOpts ) : initialOpts;\n    // init layout mode instance\n    this.modes[ name ] = new Mode( this );\n  };\n\n\n  proto.layout = function() {\n    // if first time doing layout, do all magic\n    if ( !this._isLayoutInited && this._getOption('initLayout') ) {\n      this.arrange();\n      return;\n    }\n    this._layout();\n  };\n\n  // private method to be used in layout() & magic()\n  proto._layout = function() {\n    // don't animate first layout\n    var isInstant = this._getIsInstant();\n    // layout flow\n    this._resetLayout();\n    this._manageStamps();\n    this.layoutItems( this.filteredItems, isInstant );\n\n    // flag for initalized\n    this._isLayoutInited = true;\n  };\n\n  // filter + sort + layout\n  proto.arrange = function( opts ) {\n    // set any options pass\n    this.option( opts );\n    this._getIsInstant();\n    // filter, sort, and layout\n\n    // filter\n    var filtered = this._filter( this.items );\n    this.filteredItems = filtered.matches;\n\n    this._bindArrangeComplete();\n\n    if ( this._isInstant ) {\n      this._noTransition( this._hideReveal, [ filtered ] );\n    } else {\n      this._hideReveal( filtered );\n    }\n\n    this._sort();\n    this._layout();\n  };\n  // alias to _init for main plugin method\n  proto._init = proto.arrange;\n\n  proto._hideReveal = function( filtered ) {\n    this.reveal( filtered.needReveal );\n    this.hide( filtered.needHide );\n  };\n\n  // HACK\n  // Don't animate/transition first layout\n  // Or don't animate/transition other layouts\n  proto._getIsInstant = function() {\n    var isLayoutInstant = this._getOption('layoutInstant');\n    var isInstant = isLayoutInstant !== undefined ? isLayoutInstant :\n      !this._isLayoutInited;\n    this._isInstant = isInstant;\n    return isInstant;\n  };\n\n  // listen for layoutComplete, hideComplete and revealComplete\n  // to trigger arrangeComplete\n  proto._bindArrangeComplete = function() {\n    // listen for 3 events to trigger arrangeComplete\n    var isLayoutComplete, isHideComplete, isRevealComplete;\n    var _this = this;\n    function arrangeParallelCallback() {\n      if ( isLayoutComplete && isHideComplete && isRevealComplete ) {\n        _this.dispatchEvent( 'arrangeComplete', null, [ _this.filteredItems ] );\n      }\n    }\n    this.once( 'layoutComplete', function() {\n      isLayoutComplete = true;\n      arrangeParallelCallback();\n    });\n    this.once( 'hideComplete', function() {\n      isHideComplete = true;\n      arrangeParallelCallback();\n    });\n    this.once( 'revealComplete', function() {\n      isRevealComplete = true;\n      arrangeParallelCallback();\n    });\n  };\n\n  // -------------------------- filter -------------------------- //\n\n  proto._filter = function( items ) {\n    var filter = this.options.filter;\n    filter = filter || '*';\n    var matches = [];\n    var hiddenMatched = [];\n    var visibleUnmatched = [];\n\n    var test = this._getFilterTest( filter );\n\n    // test each item\n    for ( var i=0; i < items.length; i++ ) {\n      var item = items[i];\n      if ( item.isIgnored ) {\n        continue;\n      }\n      // add item to either matched or unmatched group\n      var isMatched = test( item );\n      // item.isFilterMatched = isMatched;\n      // add to matches if its a match\n      if ( isMatched ) {\n        matches.push( item );\n      }\n      // add to additional group if item needs to be hidden or revealed\n      if ( isMatched && item.isHidden ) {\n        hiddenMatched.push( item );\n      } else if ( !isMatched && !item.isHidden ) {\n        visibleUnmatched.push( item );\n      }\n    }\n\n    // return collections of items to be manipulated\n    return {\n      matches: matches,\n      needReveal: hiddenMatched,\n      needHide: visibleUnmatched\n    };\n  };\n\n  // get a jQuery, function, or a matchesSelector test given the filter\n  proto._getFilterTest = function( filter ) {\n    if ( jQuery && this.options.isJQueryFiltering ) {\n      // use jQuery\n      return function( item ) {\n        return jQuery( item.element ).is( filter );\n      };\n    }\n    if ( typeof filter == 'function' ) {\n      // use filter as function\n      return function( item ) {\n        return filter( item.element );\n      };\n    }\n    // default, use filter as selector string\n    return function( item ) {\n      return matchesSelector( item.element, filter );\n    };\n  };\n\n  // -------------------------- sorting -------------------------- //\n\n  /**\n   * @params {Array} elems\n   * @public\n   */\n  proto.updateSortData = function( elems ) {\n    // get items\n    var items;\n    if ( elems ) {\n      elems = utils.makeArray( elems );\n      items = this.getItems( elems );\n    } else {\n      // update all items if no elems provided\n      items = this.items;\n    }\n\n    this._getSorters();\n    this._updateItemsSortData( items );\n  };\n\n  proto._getSorters = function() {\n    var getSortData = this.options.getSortData;\n    for ( var key in getSortData ) {\n      var sorter = getSortData[ key ];\n      this._sorters[ key ] = mungeSorter( sorter );\n    }\n  };\n\n  /**\n   * @params {Array} items - of Isotope.Items\n   * @private\n   */\n  proto._updateItemsSortData = function( items ) {\n    // do not update if no items\n    var len = items && items.length;\n\n    for ( var i=0; len && i < len; i++ ) {\n      var item = items[i];\n      item.updateSortData();\n    }\n  };\n\n  // ----- munge sorter ----- //\n\n  // encapsulate this, as we just need mungeSorter\n  // other functions in here are just for munging\n  var mungeSorter = ( function() {\n    // add a magic layer to sorters for convienent shorthands\n    // `.foo-bar` will use the text of .foo-bar querySelector\n    // `[foo-bar]` will use attribute\n    // you can also add parser\n    // `.foo-bar parseInt` will parse that as a number\n    function mungeSorter( sorter ) {\n      // if not a string, return function or whatever it is\n      if ( typeof sorter != 'string' ) {\n        return sorter;\n      }\n      // parse the sorter string\n      var args = trim( sorter ).split(' ');\n      var query = args[0];\n      // check if query looks like [an-attribute]\n      var attrMatch = query.match( /^\\[(.+)\\]$/ );\n      var attr = attrMatch && attrMatch[1];\n      var getValue = getValueGetter( attr, query );\n      // use second argument as a parser\n      var parser = Isotope.sortDataParsers[ args[1] ];\n      // parse the value, if there was a parser\n      sorter = parser ? function( elem ) {\n        return elem && parser( getValue( elem ) );\n      } :\n      // otherwise just return value\n      function( elem ) {\n        return elem && getValue( elem );\n      };\n\n      return sorter;\n    }\n\n    // get an attribute getter, or get text of the querySelector\n    function getValueGetter( attr, query ) {\n      // if query looks like [foo-bar], get attribute\n      if ( attr ) {\n        return function getAttribute( elem ) {\n          return elem.getAttribute( attr );\n        };\n      }\n\n      // otherwise, assume its a querySelector, and get its text\n      return function getChildText( elem ) {\n        var child = elem.querySelector( query );\n        return child && child.textContent;\n      };\n    }\n\n    return mungeSorter;\n  })();\n\n  // parsers used in getSortData shortcut strings\n  Isotope.sortDataParsers = {\n    'parseInt': function( val ) {\n      return parseInt( val, 10 );\n    },\n    'parseFloat': function( val ) {\n      return parseFloat( val );\n    }\n  };\n\n  // ----- sort method ----- //\n\n  // sort filteredItem order\n  proto._sort = function() {\n    if ( !this.options.sortBy ) {\n      return;\n    }\n    // keep track of sortBy History\n    var sortBys = utils.makeArray( this.options.sortBy );\n    if ( !this._getIsSameSortBy( sortBys ) ) {\n      // concat all sortBy and sortHistory, add to front, oldest goes in last\n      this.sortHistory = sortBys.concat( this.sortHistory );\n    }\n    // sort magic\n    var itemSorter = getItemSorter( this.sortHistory, this.options.sortAscending );\n    this.filteredItems.sort( itemSorter );\n  };\n\n  // check if sortBys is same as start of sortHistory\n  proto._getIsSameSortBy = function( sortBys ) {\n    for ( var i=0; i < sortBys.length; i++ ) {\n      if ( sortBys[i] != this.sortHistory[i] ) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  // returns a function used for sorting\n  function getItemSorter( sortBys, sortAsc ) {\n    return function sorter( itemA, itemB ) {\n      // cycle through all sortKeys\n      for ( var i = 0; i < sortBys.length; i++ ) {\n        var sortBy = sortBys[i];\n        var a = itemA.sortData[ sortBy ];\n        var b = itemB.sortData[ sortBy ];\n        if ( a > b || a < b ) {\n          // if sortAsc is an object, use the value given the sortBy key\n          var isAscending = sortAsc[ sortBy ] !== undefined ? sortAsc[ sortBy ] : sortAsc;\n          var direction = isAscending ? 1 : -1;\n          return ( a > b ? 1 : -1 ) * direction;\n        }\n      }\n      return 0;\n    };\n  }\n\n  // -------------------------- methods -------------------------- //\n\n  // get layout mode\n  proto._mode = function() {\n    var layoutMode = this.options.layoutMode;\n    var mode = this.modes[ layoutMode ];\n    if ( !mode ) {\n      // TODO console.error\n      throw new Error( 'No layout mode: ' + layoutMode );\n    }\n    // HACK sync mode's options\n    // any options set after init for layout mode need to be synced\n    mode.options = this.options[ layoutMode ];\n    return mode;\n  };\n\n  proto._resetLayout = function() {\n    // trigger original reset layout\n    Outlayer.prototype._resetLayout.call( this );\n    this._mode()._resetLayout();\n  };\n\n  proto._getItemLayoutPosition = function( item  ) {\n    return this._mode()._getItemLayoutPosition( item );\n  };\n\n  proto._manageStamp = function( stamp ) {\n    this._mode()._manageStamp( stamp );\n  };\n\n  proto._getContainerSize = function() {\n    return this._mode()._getContainerSize();\n  };\n\n  proto.needsResizeLayout = function() {\n    return this._mode().needsResizeLayout();\n  };\n\n  // -------------------------- adding & removing -------------------------- //\n\n  // HEADS UP overwrites default Outlayer appended\n  proto.appended = function( elems ) {\n    var items = this.addItems( elems );\n    if ( !items.length ) {\n      return;\n    }\n    // filter, layout, reveal new items\n    var filteredItems = this._filterRevealAdded( items );\n    // add to filteredItems\n    this.filteredItems = this.filteredItems.concat( filteredItems );\n  };\n\n  // HEADS UP overwrites default Outlayer prepended\n  proto.prepended = function( elems ) {\n    var items = this._itemize( elems );\n    if ( !items.length ) {\n      return;\n    }\n    // start new layout\n    this._resetLayout();\n    this._manageStamps();\n    // filter, layout, reveal new items\n    var filteredItems = this._filterRevealAdded( items );\n    // layout previous items\n    this.layoutItems( this.filteredItems );\n    // add to items and filteredItems\n    this.filteredItems = filteredItems.concat( this.filteredItems );\n    this.items = items.concat( this.items );\n  };\n\n  proto._filterRevealAdded = function( items ) {\n    var filtered = this._filter( items );\n    this.hide( filtered.needHide );\n    // reveal all new items\n    this.reveal( filtered.matches );\n    // layout new items, no transition\n    this.layoutItems( filtered.matches, true );\n    return filtered.matches;\n  };\n\n  /**\n   * Filter, sort, and layout newly-appended item elements\n   * @param {Array or NodeList or Element} elems\n   */\n  proto.insert = function( elems ) {\n    var items = this.addItems( elems );\n    if ( !items.length ) {\n      return;\n    }\n    // append item elements\n    var i, item;\n    var len = items.length;\n    for ( i=0; i < len; i++ ) {\n      item = items[i];\n      this.element.appendChild( item.element );\n    }\n    // filter new stuff\n    var filteredInsertItems = this._filter( items ).matches;\n    // set flag\n    for ( i=0; i < len; i++ ) {\n      items[i].isLayoutInstant = true;\n    }\n    this.arrange();\n    // reset flag\n    for ( i=0; i < len; i++ ) {\n      delete items[i].isLayoutInstant;\n    }\n    this.reveal( filteredInsertItems );\n  };\n\n  var _remove = proto.remove;\n  proto.remove = function( elems ) {\n    elems = utils.makeArray( elems );\n    var removeItems = this.getItems( elems );\n    // do regular thing\n    _remove.call( this, elems );\n    // bail if no items to remove\n    var len = removeItems && removeItems.length;\n    // remove elems from filteredItems\n    for ( var i=0; len && i < len; i++ ) {\n      var item = removeItems[i];\n      // remove item from collection\n      utils.removeFrom( this.filteredItems, item );\n    }\n  };\n\n  proto.shuffle = function() {\n    // update random sortData\n    for ( var i=0; i < this.items.length; i++ ) {\n      var item = this.items[i];\n      item.sortData.random = Math.random();\n    }\n    this.options.sortBy = 'random';\n    this._sort();\n    this._layout();\n  };\n\n  /**\n   * trigger fn without transition\n   * kind of hacky to have this in the first place\n   * @param {Function} fn\n   * @param {Array} args\n   * @returns ret\n   * @private\n   */\n  proto._noTransition = function( fn, args ) {\n    // save transitionDuration before disabling\n    var transitionDuration = this.options.transitionDuration;\n    // disable transition\n    this.options.transitionDuration = 0;\n    // do it\n    var returnValue = fn.apply( this, args );\n    // re-enable transition for reveal\n    this.options.transitionDuration = transitionDuration;\n    return returnValue;\n  };\n\n  // ----- helper methods ----- //\n\n  /**\n   * getter method for getting filtered item elements\n   * @returns {Array} elems - collection of item elements\n   */\n  proto.getFilteredItemElements = function() {\n    return this.filteredItems.map( function( item ) {\n      return item.element;\n    });\n  };\n\n  // -----  ----- //\n\n  return Isotope;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isotope-layout/js/isotope.js\n// module id = 29\n// module chunks = 0\n//# sourceURL=webpack:///./~/isotope-layout/js/isotope.js?")},function(module,exports,__webpack_require__){
eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * getSize v2.0.2\n * measure size of elements\n * MIT license\n */\n\n/*jshint browser: true, strict: true, undef: true, unused: true */\n/*global define: false, module: false, console: false */\n\n( function( window, factory ) {\n  'use strict';\n\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n      return factory();\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory();\n  } else {\n    // browser global\n    window.getSize = factory();\n  }\n\n})( window, function factory() {\n'use strict';\n\n// -------------------------- helpers -------------------------- //\n\n// get a number from a string, not a percentage\nfunction getStyleSize( value ) {\n  var num = parseFloat( value );\n  // not a percent like '100%', and a number\n  var isValid = value.indexOf('%') == -1 && !isNaN( num );\n  return isValid && num;\n}\n\nfunction noop() {}\n\nvar logError = typeof console == 'undefined' ? noop :\n  function( message ) {\n    console.error( message );\n  };\n\n// -------------------------- measurements -------------------------- //\n\nvar measurements = [\n  'paddingLeft',\n  'paddingRight',\n  'paddingTop',\n  'paddingBottom',\n  'marginLeft',\n  'marginRight',\n  'marginTop',\n  'marginBottom',\n  'borderLeftWidth',\n  'borderRightWidth',\n  'borderTopWidth',\n  'borderBottomWidth'\n];\n\nvar measurementsLength = measurements.length;\n\nfunction getZeroSize() {\n  var size = {\n    width: 0,\n    height: 0,\n    innerWidth: 0,\n    innerHeight: 0,\n    outerWidth: 0,\n    outerHeight: 0\n  };\n  for ( var i=0; i < measurementsLength; i++ ) {\n    var measurement = measurements[i];\n    size[ measurement ] = 0;\n  }\n  return size;\n}\n\n// -------------------------- getStyle -------------------------- //\n\n/**\n * getStyle, get style of element, check for Firefox bug\n * https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n */\nfunction getStyle( elem ) {\n  var style = getComputedStyle( elem );\n  if ( !style ) {\n    logError( 'Style returned ' + style +\n      '. Are you running this code in a hidden iframe on Firefox? ' +\n      'See http://bit.ly/getsizebug1' );\n  }\n  return style;\n}\n\n// -------------------------- setup -------------------------- //\n\nvar isSetup = false;\n\nvar isBoxSizeOuter;\n\n/**\n * setup\n * check isBoxSizerOuter\n * do on first getSize() rather than on page load for Firefox bug\n */\nfunction setup() {\n  // setup once\n  if ( isSetup ) {\n    return;\n  }\n  isSetup = true;\n\n  // -------------------------- box sizing -------------------------- //\n\n  /**\n   * WebKit measures the outer-width on style.width on border-box elems\n   * IE & Firefox<29 measures the inner-width\n   */\n  var div = document.createElement('div');\n  div.style.width = '200px';\n  div.style.padding = '1px 2px 3px 4px';\n  div.style.borderStyle = 'solid';\n  div.style.borderWidth = '1px 2px 3px 4px';\n  div.style.boxSizing = 'border-box';\n\n  var body = document.body || document.documentElement;\n  body.appendChild( div );\n  var style = getStyle( div );\n\n  getSize.isBoxSizeOuter = isBoxSizeOuter = getStyleSize( style.width ) == 200;\n  body.removeChild( div );\n\n}\n\n// -------------------------- getSize -------------------------- //\n\nfunction getSize( elem ) {\n  setup();\n\n  // use querySeletor if elem is string\n  if ( typeof elem == 'string' ) {\n    elem = document.querySelector( elem );\n  }\n\n  // do not proceed on non-objects\n  if ( !elem || typeof elem != 'object' || !elem.nodeType ) {\n    return;\n  }\n\n  var style = getStyle( elem );\n\n  // if hidden, everything is 0\n  if ( style.display == 'none' ) {\n    return getZeroSize();\n  }\n\n  var size = {};\n  size.width = elem.offsetWidth;\n  size.height = elem.offsetHeight;\n\n  var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';\n\n  // get all measurements\n  for ( var i=0; i < measurementsLength; i++ ) {\n    var measurement = measurements[i];\n    var value = style[ measurement ];\n    var num = parseFloat( value );\n    // any 'auto', 'medium' value will be 0\n    size[ measurement ] = !isNaN( num ) ? num : 0;\n  }\n\n  var paddingWidth = size.paddingLeft + size.paddingRight;\n  var paddingHeight = size.paddingTop + size.paddingBottom;\n  var marginWidth = size.marginLeft + size.marginRight;\n  var marginHeight = size.marginTop + size.marginBottom;\n  var borderWidth = size.borderLeftWidth + size.borderRightWidth;\n  var borderHeight = size.borderTopWidth + size.borderBottomWidth;\n\n  var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;\n\n  // overwrite width and height if we can get it from style\n  var styleWidth = getStyleSize( style.width );\n  if ( styleWidth !== false ) {\n    size.width = styleWidth +\n      // add padding and border unless it's already including it\n      ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );\n  }\n\n  var styleHeight = getStyleSize( style.height );\n  if ( styleHeight !== false ) {\n    size.height = styleHeight +\n      // add padding and border unless it's already including it\n      ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );\n  }\n\n  size.innerWidth = size.width - ( paddingWidth + borderWidth );\n  size.innerHeight = size.height - ( paddingHeight + borderHeight );\n\n  size.outerWidth = size.width + marginWidth;\n  size.outerHeight = size.height + marginHeight;\n\n  return size;\n}\n\nreturn getSize;\n\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/get-size/get-size.js\n// module id = 30\n// module chunks = 0\n//# sourceURL=webpack:///./~/get-size/get-size.js?")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * matchesSelector v2.0.2\n * matchesSelector( element, '.selector' )\n * MIT license\n */\n\n/*jshint browser: true, strict: true, undef: true, unused: true */\n\n( function( window, factory ) {\n  /*global define: false, module: false */\n  'use strict';\n  // universal module definition\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory();\n  } else {\n    // browser global\n    window.matchesSelector = factory();\n  }\n\n}( window, function factory() {\n  'use strict';\n\n  var matchesMethod = ( function() {\n    var ElemProto = window.Element.prototype;\n    // check for the standard method name first\n    if ( ElemProto.matches ) {\n      return 'matches';\n    }\n    // check un-prefixed\n    if ( ElemProto.matchesSelector ) {\n      return 'matchesSelector';\n    }\n    // check vendor prefixes\n    var prefixes = [ 'webkit', 'moz', 'ms', 'o' ];\n\n    for ( var i=0; i < prefixes.length; i++ ) {\n      var prefix = prefixes[i];\n      var method = prefix + 'MatchesSelector';\n      if ( ElemProto[ method ] ) {\n        return method;\n      }\n    }\n  })();\n\n  return function matchesSelector( elem, selector ) {\n    return elem[ matchesMethod ]( selector );\n  };\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/desandro-matches-selector/matches-selector.js\n// module id = 31\n// module chunks = 0\n//# sourceURL=webpack:///./~/desandro-matches-selector/matches-selector.js?")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Fizzy UI utils v2.0.5\n * MIT license\n */\n\n/*jshint browser: true, undef: true, unused: true, strict: true */\n\n( function( window, factory ) {\n  // universal module definition\n  /*jshint strict: false */ /*globals define, module, require */\n\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(31)\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = function( matchesSelector ) {\n      return factory( window, matchesSelector );\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      window,\n      require('desandro-matches-selector')\n    );\n  } else {\n    // browser global\n    window.fizzyUIUtils = factory(\n      window,\n      window.matchesSelector\n    );\n  }\n\n}( window, function factory( window, matchesSelector ) {\n\n'use strict';\n\nvar utils = {};\n\n// ----- extend ----- //\n\n// extends objects\nutils.extend = function( a, b ) {\n  for ( var prop in b ) {\n    a[ prop ] = b[ prop ];\n  }\n  return a;\n};\n\n// ----- modulo ----- //\n\nutils.modulo = function( num, div ) {\n  return ( ( num % div ) + div ) % div;\n};\n\n// ----- makeArray ----- //\n\n// turn element or nodeList into an array\nutils.makeArray = function( obj ) {\n  var ary = [];\n  if ( Array.isArray( obj ) ) {\n    // use object if already an array\n    ary = obj;\n  } else if ( obj && typeof obj == 'object' &&\n    typeof obj.length == 'number' ) {\n    // convert nodeList to array\n    for ( var i=0; i < obj.length; i++ ) {\n      ary.push( obj[i] );\n    }\n  } else {\n    // array of single index\n    ary.push( obj );\n  }\n  return ary;\n};\n\n// ----- removeFrom ----- //\n\nutils.removeFrom = function( ary, obj ) {\n  var index = ary.indexOf( obj );\n  if ( index != -1 ) {\n    ary.splice( index, 1 );\n  }\n};\n\n// ----- getParent ----- //\n\nutils.getParent = function( elem, selector ) {\n  while ( elem.parentNode && elem != document.body ) {\n    elem = elem.parentNode;\n    if ( matchesSelector( elem, selector ) ) {\n      return elem;\n    }\n  }\n};\n\n// ----- getQueryElement ----- //\n\n// use element as selector string\nutils.getQueryElement = function( elem ) {\n  if ( typeof elem == 'string' ) {\n    return document.querySelector( elem );\n  }\n  return elem;\n};\n\n// ----- handleEvent ----- //\n\n// enable .ontype to trigger from .addEventListener( elem, 'type' )\nutils.handleEvent = function( event ) {\n  var method = 'on' + event.type;\n  if ( this[ method ] ) {\n    this[ method ]( event );\n  }\n};\n\n// ----- filterFindElements ----- //\n\nutils.filterFindElements = function( elems, selector ) {\n  // make array of elems\n  elems = utils.makeArray( elems );\n  var ffElems = [];\n\n  elems.forEach( function( elem ) {\n    // check that elem is an actual element\n    if ( !( elem instanceof HTMLElement ) ) {\n      return;\n    }\n    // add elem if no selector\n    if ( !selector ) {\n      ffElems.push( elem );\n      return;\n    }\n    // filter & find items if we have a selector\n    // filter\n    if ( matchesSelector( elem, selector ) ) {\n      ffElems.push( elem );\n    }\n    // find children\n    var childElems = elem.querySelectorAll( selector );\n    // concat childElems to filterFound array\n    for ( var i=0; i < childElems.length; i++ ) {\n      ffElems.push( childElems[i] );\n    }\n  });\n\n  return ffElems;\n};\n\n// ----- debounceMethod ----- //\n\nutils.debounceMethod = function( _class, methodName, threshold ) {\n  // original method\n  var method = _class.prototype[ methodName ];\n  var timeoutName = methodName + 'Timeout';\n\n  _class.prototype[ methodName ] = function() {\n    var timeout = this[ timeoutName ];\n    if ( timeout ) {\n      clearTimeout( timeout );\n    }\n    var args = arguments;\n\n    var _this = this;\n    this[ timeoutName ] = setTimeout( function() {\n      method.apply( _this, args );\n      delete _this[ timeoutName ];\n    }, threshold || 100 );\n  };\n};\n\n// ----- docReady ----- //\n\nutils.docReady = function( callback ) {\n  var readyState = document.readyState;\n  if ( readyState == 'complete' || readyState == 'interactive' ) {\n    // do async to allow for other scripts to run. metafizzy/flickity#441\n    setTimeout( callback );\n  } else {\n    document.addEventListener( 'DOMContentLoaded', callback );\n  }\n};\n\n// ----- htmlInit ----- //\n\n// http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/\nutils.toDashed = function( str ) {\n  return str.replace( /(.)([A-Z])/g, function( match, $1, $2 ) {\n    return $1 + '-' + $2;\n  }).toLowerCase();\n};\n\nvar console = window.console;\n/**\n * allow user to initialize classes via [data-namespace] or .js-namespace class\n * htmlInit( Widget, 'widgetName' )\n * options are parsed from data-namespace-options\n */\nutils.htmlInit = function( WidgetClass, namespace ) {\n  utils.docReady( function() {\n    var dashedNamespace = utils.toDashed( namespace );\n    var dataAttr = 'data-' + dashedNamespace;\n    var dataAttrElems = document.querySelectorAll( '[' + dataAttr + ']' );\n    var jsDashElems = document.querySelectorAll( '.js-' + dashedNamespace );\n    var elems = utils.makeArray( dataAttrElems )\n      .concat( utils.makeArray( jsDashElems ) );\n    var dataOptionsAttr = dataAttr + '-options';\n    var jQuery = window.jQuery;\n\n    elems.forEach( function( elem ) {\n      var attr = elem.getAttribute( dataAttr ) ||\n        elem.getAttribute( dataOptionsAttr );\n      var options;\n      try {\n        options = attr && JSON.parse( attr );\n      } catch ( error ) {\n        // log error, do not initialize\n        if ( console ) {\n          console.error( 'Error parsing ' + dataAttr + ' on ' + elem.className +\n          ': ' + error );\n        }\n        return;\n      }\n      // initialize\n      var instance = new WidgetClass( elem, options );\n      // make available via $().data('namespace')\n      if ( jQuery ) {\n        jQuery.data( elem, namespace, instance );\n      }\n    });\n\n  });\n};\n\n// -----  ----- //\n\nreturn utils;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fizzy-ui-utils/utils.js\n// module id = 32\n// module chunks = 0\n//# sourceURL=webpack:///./~/fizzy-ui-utils/utils.js?")},function(module,exports,__webpack_require__){
eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Outlayer v2.1.1\n * the brains and guts of a layout library\n * MIT license\n */\n\n( function( window, factory ) {\n  'use strict';\n  // universal module definition\n  /* jshint strict: false */ /* globals define, module, require */\n  if ( true ) {\n    // AMD - RequireJS\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(34),\n        __webpack_require__(30),\n        __webpack_require__(32),\n        __webpack_require__(35)\n      ], __WEBPACK_AMD_DEFINE_RESULT__ = function( EvEmitter, getSize, utils, Item ) {\n        return factory( window, EvEmitter, getSize, utils, Item);\n      }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS - Browserify, Webpack\n    module.exports = factory(\n      window,\n      require('ev-emitter'),\n      require('get-size'),\n      require('fizzy-ui-utils'),\n      require('./item')\n    );\n  } else {\n    // browser global\n    window.Outlayer = factory(\n      window,\n      window.EvEmitter,\n      window.getSize,\n      window.fizzyUIUtils,\n      window.Outlayer.Item\n    );\n  }\n\n}( window, function factory( window, EvEmitter, getSize, utils, Item ) {\n'use strict';\n\n// ----- vars ----- //\n\nvar console = window.console;\nvar jQuery = window.jQuery;\nvar noop = function() {};\n\n// -------------------------- Outlayer -------------------------- //\n\n// globally unique identifiers\nvar GUID = 0;\n// internal store of all Outlayer intances\nvar instances = {};\n\n\n/**\n * @param {Element, String} element\n * @param {Object} options\n * @constructor\n */\nfunction Outlayer( element, options ) {\n  var queryElement = utils.getQueryElement( element );\n  if ( !queryElement ) {\n    if ( console ) {\n      console.error( 'Bad element for ' + this.constructor.namespace +\n        ': ' + ( queryElement || element ) );\n    }\n    return;\n  }\n  this.element = queryElement;\n  // add jQuery\n  if ( jQuery ) {\n    this.$element = jQuery( this.element );\n  }\n\n  // options\n  this.options = utils.extend( {}, this.constructor.defaults );\n  this.option( options );\n\n  // add id for Outlayer.getFromElement\n  var id = ++GUID;\n  this.element.outlayerGUID = id; // expando\n  instances[ id ] = this; // associate via id\n\n  // kick it off\n  this._create();\n\n  var isInitLayout = this._getOption('initLayout');\n  if ( isInitLayout ) {\n    this.layout();\n  }\n}\n\n// settings are for internal use only\nOutlayer.namespace = 'outlayer';\nOutlayer.Item = Item;\n\n// default options\nOutlayer.defaults = {\n  containerStyle: {\n    position: 'relative'\n  },\n  initLayout: true,\n  originLeft: true,\n  originTop: true,\n  resize: true,\n  resizeContainer: true,\n  // item options\n  transitionDuration: '0.4s',\n  hiddenStyle: {\n    opacity: 0,\n    transform: 'scale(0.001)'\n  },\n  visibleStyle: {\n    opacity: 1,\n    transform: 'scale(1)'\n  }\n};\n\nvar proto = Outlayer.prototype;\n// inherit EvEmitter\nutils.extend( proto, EvEmitter.prototype );\n\n/**\n * set options\n * @param {Object} opts\n */\nproto.option = function( opts ) {\n  utils.extend( this.options, opts );\n};\n\n/**\n * get backwards compatible option value, check old name\n */\nproto._getOption = function( option ) {\n  var oldOption = this.constructor.compatOptions[ option ];\n  return oldOption && this.options[ oldOption ] !== undefined ?\n    this.options[ oldOption ] : this.options[ option ];\n};\n\nOutlayer.compatOptions = {\n  // currentName: oldName\n  initLayout: 'isInitLayout',\n  horizontal: 'isHorizontal',\n  layoutInstant: 'isLayoutInstant',\n  originLeft: 'isOriginLeft',\n  originTop: 'isOriginTop',\n  resize: 'isResizeBound',\n  resizeContainer: 'isResizingContainer'\n};\n\nproto._create = function() {\n  // get items from children\n  this.reloadItems();\n  // elements that affect layout, but are not laid out\n  this.stamps = [];\n  this.stamp( this.options.stamp );\n  // set container style\n  utils.extend( this.element.style, this.options.containerStyle );\n\n  // bind resize method\n  var canBindResize = this._getOption('resize');\n  if ( canBindResize ) {\n    this.bindResize();\n  }\n};\n\n// goes through all children again and gets bricks in proper order\nproto.reloadItems = function() {\n  // collection of item elements\n  this.items = this._itemize( this.element.children );\n};\n\n\n/**\n * turn elements into Outlayer.Items to be used in layout\n * @param {Array or NodeList or HTMLElement} elems\n * @returns {Array} items - collection of new Outlayer Items\n */\nproto._itemize = function( elems ) {\n\n  var itemElems = this._filterFindItemElements( elems );\n  var Item = this.constructor.Item;\n\n  // create new Outlayer Items for collection\n  var items = [];\n  for ( var i=0; i < itemElems.length; i++ ) {\n    var elem = itemElems[i];\n    var item = new Item( elem, this );\n    items.push( item );\n  }\n\n  return items;\n};\n\n/**\n * get item elements to be used in layout\n * @param {Array or NodeList or HTMLElement} elems\n * @returns {Array} items - item elements\n */\nproto._filterFindItemElements = function( elems ) {\n  return utils.filterFindElements( elems, this.options.itemSelector );\n};\n\n/**\n * getter method for getting item elements\n * @returns {Array} elems - collection of item elements\n */\nproto.getItemElements = function() {\n  return this.items.map( function( item ) {\n    return item.element;\n  });\n};\n\n// ----- init & layout ----- //\n\n/**\n * lays out all items\n */\nproto.layout = function() {\n  this._resetLayout();\n  this._manageStamps();\n\n  // don't animate first layout\n  var layoutInstant = this._getOption('layoutInstant');\n  var isInstant = layoutInstant !== undefined ?\n    layoutInstant : !this._isLayoutInited;\n  this.layoutItems( this.items, isInstant );\n\n  // flag for initalized\n  this._isLayoutInited = true;\n};\n\n// _init is alias for layout\nproto._init = proto.layout;\n\n/**\n * logic before any new layout\n */\nproto._resetLayout = function() {\n  this.getSize();\n};\n\n\nproto.getSize = function() {\n  this.size = getSize( this.element );\n};\n\n/**\n * get measurement from option, for columnWidth, rowHeight, gutter\n * if option is String -> get element from selector string, & get size of element\n * if option is Element -> get size of element\n * else use option as a number\n *\n * @param {String} measurement\n * @param {String} size - width or height\n * @private\n */\nproto._getMeasurement = function( measurement, size ) {\n  var option = this.options[ measurement ];\n  var elem;\n  if ( !option ) {\n    // default to 0\n    this[ measurement ] = 0;\n  } else {\n    // use option as an element\n    if ( typeof option == 'string' ) {\n      elem = this.element.querySelector( option );\n    } else if ( option instanceof HTMLElement ) {\n      elem = option;\n    }\n    // use size of element, if element\n    this[ measurement ] = elem ? getSize( elem )[ size ] : option;\n  }\n};\n\n/**\n * layout a collection of item elements\n * @api public\n */\nproto.layoutItems = function( items, isInstant ) {\n  items = this._getItemsForLayout( items );\n\n  this._layoutItems( items, isInstant );\n\n  this._postLayout();\n};\n\n/**\n * get the items to be laid out\n * you may want to skip over some items\n * @param {Array} items\n * @returns {Array} items\n */\nproto._getItemsForLayout = function( items ) {\n  return items.filter( function( item ) {\n    return !item.isIgnored;\n  });\n};\n\n/**\n * layout items\n * @param {Array} items\n * @param {Boolean} isInstant\n */\nproto._layoutItems = function( items, isInstant ) {\n  this._emitCompleteOnItems( 'layout', items );\n\n  if ( !items || !items.length ) {\n    // no items, emit event with empty array\n    return;\n  }\n\n  var queue = [];\n\n  items.forEach( function( item ) {\n    // get x/y object from method\n    var position = this._getItemLayoutPosition( item );\n    // enqueue\n    position.item = item;\n    position.isInstant = isInstant || item.isLayoutInstant;\n    queue.push( position );\n  }, this );\n\n  this._processLayoutQueue( queue );\n};\n\n/**\n * get item layout position\n * @param {Outlayer.Item} item\n * @returns {Object} x and y position\n */\nproto._getItemLayoutPosition = function( /* item */ ) {\n  return {\n    x: 0,\n    y: 0\n  };\n};\n\n/**\n * iterate over array and position each item\n * Reason being - separating this logic prevents 'layout invalidation'\n * thx @paul_irish\n * @param {Array} queue\n */\nproto._processLayoutQueue = function( queue ) {\n  this.updateStagger();\n  queue.forEach( function( obj, i ) {\n    this._positionItem( obj.item, obj.x, obj.y, obj.isInstant, i );\n  }, this );\n};\n\n// set stagger from option in milliseconds number\nproto.updateStagger = function() {\n  var stagger = this.options.stagger;\n  if ( stagger === null || stagger === undefined ) {\n    this.stagger = 0;\n    return;\n  }\n  this.stagger = getMilliseconds( stagger );\n  return this.stagger;\n};\n\n/**\n * Sets position of item in DOM\n * @param {Outlayer.Item} item\n * @param {Number} x - horizontal position\n * @param {Number} y - vertical position\n * @param {Boolean} isInstant - disables transitions\n */\nproto._positionItem = function( item, x, y, isInstant, i ) {\n  if ( isInstant ) {\n    // if not transition, just set CSS\n    item.goTo( x, y );\n  } else {\n    item.stagger( i * this.stagger );\n    item.moveTo( x, y );\n  }\n};\n\n/**\n * Any logic you want to do after each layout,\n * i.e. size the container\n */\nproto._postLayout = function() {\n  this.resizeContainer();\n};\n\nproto.resizeContainer = function() {\n  var isResizingContainer = this._getOption('resizeContainer');\n  if ( !isResizingContainer ) {\n    return;\n  }\n  var size = this._getContainerSize();\n  if ( size ) {\n    this._setContainerMeasure( size.width, true );\n    this._setContainerMeasure( size.height, false );\n  }\n};\n\n/**\n * Sets width or height of container if returned\n * @returns {Object} size\n *   @param {Number} width\n *   @param {Number} height\n */\nproto._getContainerSize = noop;\n\n/**\n * @param {Number} measure - size of width or height\n * @param {Boolean} isWidth\n */\nproto._setContainerMeasure = function( measure, isWidth ) {\n  if ( measure === undefined ) {\n    return;\n  }\n\n  var elemSize = this.size;\n  // add padding and border width if border box\n  if ( elemSize.isBorderBox ) {\n    measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight +\n      elemSize.borderLeftWidth + elemSize.borderRightWidth :\n      elemSize.paddingBottom + elemSize.paddingTop +\n      elemSize.borderTopWidth + elemSize.borderBottomWidth;\n  }\n\n  measure = Math.max( measure, 0 );\n  this.element.style[ isWidth ? 'width' : 'height' ] = measure + 'px';\n};\n\n/**\n * emit eventComplete on a collection of items events\n * @param {String} eventName\n * @param {Array} items - Outlayer.Items\n */\nproto._emitCompleteOnItems = function( eventName, items ) {\n  var _this = this;\n  function onComplete() {\n    _this.dispatchEvent( eventName + 'Complete', null, [ items ] );\n  }\n\n  var count = items.length;\n  if ( !items || !count ) {\n    onComplete();\n    return;\n  }\n\n  var doneCount = 0;\n  function tick() {\n    doneCount++;\n    if ( doneCount == count ) {\n      onComplete();\n    }\n  }\n\n  // bind callback\n  items.forEach( function( item ) {\n    item.once( eventName, tick );\n  });\n};\n\n/**\n * emits events via EvEmitter and jQuery events\n * @param {String} type - name of event\n * @param {Event} event - original event\n * @param {Array} args - extra arguments\n */\nproto.dispatchEvent = function( type, event, args ) {\n  // add original event to arguments\n  var emitArgs = event ? [ event ].concat( args ) : args;\n  this.emitEvent( type, emitArgs );\n\n  if ( jQuery ) {\n    // set this.$element\n    this.$element = this.$element || jQuery( this.element );\n    if ( event ) {\n      // create jQuery event\n      var $event = jQuery.Event( event );\n      $event.type = type;\n      this.$element.trigger( $event, args );\n    } else {\n      // just trigger with type if no event available\n      this.$element.trigger( type, args );\n    }\n  }\n};\n\n// -------------------------- ignore & stamps -------------------------- //\n\n\n/**\n * keep item in collection, but do not lay it out\n * ignored items do not get skipped in layout\n * @param {Element} elem\n */\nproto.ignore = function( elem ) {\n  var item = this.getItem( elem );\n  if ( item ) {\n    item.isIgnored = true;\n  }\n};\n\n/**\n * return item to layout collection\n * @param {Element} elem\n */\nproto.unignore = function( elem ) {\n  var item = this.getItem( elem );\n  if ( item ) {\n    delete item.isIgnored;\n  }\n};\n\n/**\n * adds elements to stamps\n * @param {NodeList, Array, Element, or String} elems\n */\nproto.stamp = function( elems ) {\n  elems = this._find( elems );\n  if ( !elems ) {\n    return;\n  }\n\n  this.stamps = this.stamps.concat( elems );\n  // ignore\n  elems.forEach( this.ignore, this );\n};\n\n/**\n * removes elements to stamps\n * @param {NodeList, Array, or Element} elems\n */\nproto.unstamp = function( elems ) {\n  elems = this._find( elems );\n  if ( !elems ){\n    return;\n  }\n\n  elems.forEach( function( elem ) {\n    // filter out removed stamp elements\n    utils.removeFrom( this.stamps, elem );\n    this.unignore( elem );\n  }, this );\n};\n\n/**\n * finds child elements\n * @param {NodeList, Array, Element, or String} elems\n * @returns {Array} elems\n */\nproto._find = function( elems ) {\n  if ( !elems ) {\n    return;\n  }\n  // if string, use argument as selector string\n  if ( typeof elems == 'string' ) {\n    elems = this.element.querySelectorAll( elems );\n  }\n  elems = utils.makeArray( elems );\n  return elems;\n};\n\nproto._manageStamps = function() {\n  if ( !this.stamps || !this.stamps.length ) {\n    return;\n  }\n\n  this._getBoundingRect();\n\n  this.stamps.forEach( this._manageStamp, this );\n};\n\n// update boundingLeft / Top\nproto._getBoundingRect = function() {\n  // get bounding rect for container element\n  var boundingRect = this.element.getBoundingClientRect();\n  var size = this.size;\n  this._boundingRect = {\n    left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,\n    top: boundingRect.top + size.paddingTop + size.borderTopWidth,\n    right: boundingRect.right - ( size.paddingRight + size.borderRightWidth ),\n    bottom: boundingRect.bottom - ( size.paddingBottom + size.borderBottomWidth )\n  };\n};\n\n/**\n * @param {Element} stamp\n**/\nproto._manageStamp = noop;\n\n/**\n * get x/y position of element relative to container element\n * @param {Element} elem\n * @returns {Object} offset - has left, top, right, bottom\n */\nproto._getElementOffset = function( elem ) {\n  var boundingRect = elem.getBoundingClientRect();\n  var thisRect = this._boundingRect;\n  var size = getSize( elem );\n  var offset = {\n    left: boundingRect.left - thisRect.left - size.marginLeft,\n    top: boundingRect.top - thisRect.top - size.marginTop,\n    right: thisRect.right - boundingRect.right - size.marginRight,\n    bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom\n  };\n  return offset;\n};\n\n// -------------------------- resize -------------------------- //\n\n// enable event handlers for listeners\n// i.e. resize -> onresize\nproto.handleEvent = utils.handleEvent;\n\n/**\n * Bind layout to window resizing\n */\nproto.bindResize = function() {\n  window.addEventListener( 'resize', this );\n  this.isResizeBound = true;\n};\n\n/**\n * Unbind layout to window resizing\n */\nproto.unbindResize = function() {\n  window.removeEventListener( 'resize', this );\n  this.isResizeBound = false;\n};\n\nproto.onresize = function() {\n  this.resize();\n};\n\nutils.debounceMethod( Outlayer, 'onresize', 100 );\n\nproto.resize = function() {\n  // don't trigger if size did not change\n  // or if resize was unbound. See #9\n  if ( !this.isResizeBound || !this.needsResizeLayout() ) {\n    return;\n  }\n\n  this.layout();\n};\n\n/**\n * check if layout is needed post layout\n * @returns Boolean\n */\nproto.needsResizeLayout = function() {\n  var size = getSize( this.element );\n  // check that this.size and size are there\n  // IE8 triggers resize on body size change, so they might not be\n  var hasSizes = this.size && size;\n  return hasSizes && size.innerWidth !== this.size.innerWidth;\n};\n\n// -------------------------- methods -------------------------- //\n\n/**\n * add items to Outlayer instance\n * @param {Array or NodeList or Element} elems\n * @returns {Array} items - Outlayer.Items\n**/\nproto.addItems = function( elems ) {\n  var items = this._itemize( elems );\n  // add items to collection\n  if ( items.length ) {\n    this.items = this.items.concat( items );\n  }\n  return items;\n};\n\n/**\n * Layout newly-appended item elements\n * @param {Array or NodeList or Element} elems\n */\nproto.appended = function( elems ) {\n  var items = this.addItems( elems );\n  if ( !items.length ) {\n    return;\n  }\n  // layout and reveal just the new items\n  this.layoutItems( items, true );\n  this.reveal( items );\n};\n\n/**\n * Layout prepended elements\n * @param {Array or NodeList or Element} elems\n */\nproto.prepended = function( elems ) {\n  var items = this._itemize( elems );\n  if ( !items.length ) {\n    return;\n  }\n  // add items to beginning of collection\n  var previousItems = this.items.slice(0);\n  this.items = items.concat( previousItems );\n  // start new layout\n  this._resetLayout();\n  this._manageStamps();\n  // layout new stuff without transition\n  this.layoutItems( items, true );\n  this.reveal( items );\n  // layout previous items\n  this.layoutItems( previousItems );\n};\n\n/**\n * reveal a collection of items\n * @param {Array of Outlayer.Items} items\n */\nproto.reveal = function( items ) {\n  this._emitCompleteOnItems( 'reveal', items );\n  if ( !items || !items.length ) {\n    return;\n  }\n  var stagger = this.updateStagger();\n  items.forEach( function( item, i ) {\n    item.stagger( i * stagger );\n    item.reveal();\n  });\n};\n\n/**\n * hide a collection of items\n * @param {Array of Outlayer.Items} items\n */\nproto.hide = function( items ) {\n  this._emitCompleteOnItems( 'hide', items );\n  if ( !items || !items.length ) {\n    return;\n  }\n  var stagger = this.updateStagger();\n  items.forEach( function( item, i ) {\n    item.stagger( i * stagger );\n    item.hide();\n  });\n};\n\n/**\n * reveal item elements\n * @param {Array}, {Element}, {NodeList} items\n */\nproto.revealItemElements = function( elems ) {\n  var items = this.getItems( elems );\n  this.reveal( items );\n};\n\n/**\n * hide item elements\n * @param {Array}, {Element}, {NodeList} items\n */\nproto.hideItemElements = function( elems ) {\n  var items = this.getItems( elems );\n  this.hide( items );\n};\n\n/**\n * get Outlayer.Item, given an Element\n * @param {Element} elem\n * @param {Function} callback\n * @returns {Outlayer.Item} item\n */\nproto.getItem = function( elem ) {\n  // loop through items to get the one that matches\n  for ( var i=0; i < this.items.length; i++ ) {\n    var item = this.items[i];\n    if ( item.element == elem ) {\n      // return item\n      return item;\n    }\n  }\n};\n\n/**\n * get collection of Outlayer.Items, given Elements\n * @param {Array} elems\n * @returns {Array} items - Outlayer.Items\n */\nproto.getItems = function( elems ) {\n  elems = utils.makeArray( elems );\n  var items = [];\n  elems.forEach( function( elem ) {\n    var item = this.getItem( elem );\n    if ( item ) {\n      items.push( item );\n    }\n  }, this );\n\n  return items;\n};\n\n/**\n * remove element(s) from instance and DOM\n * @param {Array or NodeList or Element} elems\n */\nproto.remove = function( elems ) {\n  var removeItems = this.getItems( elems );\n\n  this._emitCompleteOnItems( 'remove', removeItems );\n\n  // bail if no items to remove\n  if ( !removeItems || !removeItems.length ) {\n    return;\n  }\n\n  removeItems.forEach( function( item ) {\n    item.remove();\n    // remove item from collection\n    utils.removeFrom( this.items, item );\n  }, this );\n};\n\n// ----- destroy ----- //\n\n// remove and disable Outlayer instance\nproto.destroy = function() {\n  // clean up dynamic styles\n  var style = this.element.style;\n  style.height = '';\n  style.position = '';\n  style.width = '';\n  // destroy items\n  this.items.forEach( function( item ) {\n    item.destroy();\n  });\n\n  this.unbindResize();\n\n  var id = this.element.outlayerGUID;\n  delete instances[ id ]; // remove reference to instance by id\n  delete this.element.outlayerGUID;\n  // remove data for jQuery\n  if ( jQuery ) {\n    jQuery.removeData( this.element, this.constructor.namespace );\n  }\n\n};\n\n// -------------------------- data -------------------------- //\n\n/**\n * get Outlayer instance from element\n * @param {Element} elem\n * @returns {Outlayer}\n */\nOutlayer.data = function( elem ) {\n  elem = utils.getQueryElement( elem );\n  var id = elem && elem.outlayerGUID;\n  return id && instances[ id ];\n};\n\n\n// -------------------------- create Outlayer class -------------------------- //\n\n/**\n * create a layout class\n * @param {String} namespace\n */\nOutlayer.create = function( namespace, options ) {\n  // sub-class Outlayer\n  var Layout = subclass( Outlayer );\n  // apply new options and compatOptions\n  Layout.defaults = utils.extend( {}, Outlayer.defaults );\n  utils.extend( Layout.defaults, options );\n  Layout.compatOptions = utils.extend( {}, Outlayer.compatOptions  );\n\n  Layout.namespace = namespace;\n\n  Layout.data = Outlayer.data;\n\n  // sub-class Item\n  Layout.Item = subclass( Item );\n\n  // -------------------------- declarative -------------------------- //\n\n  utils.htmlInit( Layout, namespace );\n\n  // -------------------------- jQuery bridge -------------------------- //\n\n  // make into jQuery plugin\n  if ( jQuery && jQuery.bridget ) {\n    jQuery.bridget( namespace, Layout );\n  }\n\n  return Layout;\n};\n\nfunction subclass( Parent ) {\n  function SubClass() {\n    Parent.apply( this, arguments );\n  }\n\n  SubClass.prototype = Object.create( Parent.prototype );\n  SubClass.prototype.constructor = SubClass;\n\n  return SubClass;\n}\n\n// ----- helpers ----- //\n\n// how many milliseconds are in each unit\nvar msUnits = {\n  ms: 1,\n  s: 1000\n};\n\n// munge time-like parameter into millisecond number\n// '0.4s' -> 40\nfunction getMilliseconds( time ) {\n  if ( typeof time == 'number' ) {\n    return time;\n  }\n  var matches = time.match( /(^\\d*\\.?\\d*)(\\w*)/ );\n  var num = matches && matches[1];\n  var unit = matches && matches[2];\n  if ( !num.length ) {\n    return 0;\n  }\n  num = parseFloat( num );\n  var mult = msUnits[ unit ] || 1;\n  return num * mult;\n}\n\n// ----- fin ----- //\n\n// back in global\nOutlayer.Item = Item;\n\nreturn Outlayer;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/outlayer/outlayer.js\n// module id = 33\n// module chunks = 0\n//# sourceURL=webpack:///./~/outlayer/outlayer.js?")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * EvEmitter v1.1.0\n * Lil' event emitter\n * MIT License\n */\n\n/* jshint unused: true, undef: true, strict: true */\n\n( function( global, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /* globals define, module, window */\n  if ( true ) {\n    // AMD - RequireJS\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS - Browserify, Webpack\n    module.exports = factory();\n  } else {\n    // Browser globals\n    global.EvEmitter = factory();\n  }\n\n}( typeof window != 'undefined' ? window : this, function() {\n\n\"use strict\";\n\nfunction EvEmitter() {}\n\nvar proto = EvEmitter.prototype;\n\nproto.on = function( eventName, listener ) {\n  if ( !eventName || !listener ) {\n    return;\n  }\n  // set events hash\n  var events = this._events = this._events || {};\n  // set listeners array\n  var listeners = events[ eventName ] = events[ eventName ] || [];\n  // only add once\n  if ( listeners.indexOf( listener ) == -1 ) {\n    listeners.push( listener );\n  }\n\n  return this;\n};\n\nproto.once = function( eventName, listener ) {\n  if ( !eventName || !listener ) {\n    return;\n  }\n  // add event\n  this.on( eventName, listener );\n  // set once flag\n  // set onceEvents hash\n  var onceEvents = this._onceEvents = this._onceEvents || {};\n  // set onceListeners object\n  var onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};\n  // set flag\n  onceListeners[ listener ] = true;\n\n  return this;\n};\n\nproto.off = function( eventName, listener ) {\n  var listeners = this._events && this._events[ eventName ];\n  if ( !listeners || !listeners.length ) {\n    return;\n  }\n  var index = listeners.indexOf( listener );\n  if ( index != -1 ) {\n    listeners.splice( index, 1 );\n  }\n\n  return this;\n};\n\nproto.emitEvent = function( eventName, args ) {\n  var listeners = this._events && this._events[ eventName ];\n  if ( !listeners || !listeners.length ) {\n    return;\n  }\n  // copy over to avoid interference if .off() in listener\n  listeners = listeners.slice(0);\n  args = args || [];\n  // once stuff\n  var onceListeners = this._onceEvents && this._onceEvents[ eventName ];\n\n  for ( var i=0; i < listeners.length; i++ ) {\n    var listener = listeners[i]\n    var isOnce = onceListeners && onceListeners[ listener ];\n    if ( isOnce ) {\n      // remove listener\n      // remove before trigger to prevent recursion\n      this.off( eventName, listener );\n      // unset once flag\n      delete onceListeners[ listener ];\n    }\n    // trigger listener\n    listener.apply( this, args );\n  }\n\n  return this;\n};\n\nproto.allOff = function() {\n  delete this._events;\n  delete this._onceEvents;\n};\n\nreturn EvEmitter;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ev-emitter/ev-emitter.js\n// module id = 34\n// module chunks = 0\n//# sourceURL=webpack:///./~/ev-emitter/ev-emitter.js?")},function(module,exports,__webpack_require__){
eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Outlayer Item\n */\n\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /* globals define, module, require */\n  if ( true ) {\n    // AMD - RequireJS\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(34),\n        __webpack_require__(30)\n      ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS - Browserify, Webpack\n    module.exports = factory(\n      require('ev-emitter'),\n      require('get-size')\n    );\n  } else {\n    // browser global\n    window.Outlayer = {};\n    window.Outlayer.Item = factory(\n      window.EvEmitter,\n      window.getSize\n    );\n  }\n\n}( window, function factory( EvEmitter, getSize ) {\n'use strict';\n\n// ----- helpers ----- //\n\nfunction isEmptyObj( obj ) {\n  for ( var prop in obj ) {\n    return false;\n  }\n  prop = null;\n  return true;\n}\n\n// -------------------------- CSS3 support -------------------------- //\n\n\nvar docElemStyle = document.documentElement.style;\n\nvar transitionProperty = typeof docElemStyle.transition == 'string' ?\n  'transition' : 'WebkitTransition';\nvar transformProperty = typeof docElemStyle.transform == 'string' ?\n  'transform' : 'WebkitTransform';\n\nvar transitionEndEvent = {\n  WebkitTransition: 'webkitTransitionEnd',\n  transition: 'transitionend'\n}[ transitionProperty ];\n\n// cache all vendor properties that could have vendor prefix\nvar vendorProperties = {\n  transform: transformProperty,\n  transition: transitionProperty,\n  transitionDuration: transitionProperty + 'Duration',\n  transitionProperty: transitionProperty + 'Property',\n  transitionDelay: transitionProperty + 'Delay'\n};\n\n// -------------------------- Item -------------------------- //\n\nfunction Item( element, layout ) {\n  if ( !element ) {\n    return;\n  }\n\n  this.element = element;\n  // parent layout class, i.e. Masonry, Isotope, or Packery\n  this.layout = layout;\n  this.position = {\n    x: 0,\n    y: 0\n  };\n\n  this._create();\n}\n\n// inherit EvEmitter\nvar proto = Item.prototype = Object.create( EvEmitter.prototype );\nproto.constructor = Item;\n\nproto._create = function() {\n  // transition objects\n  this._transn = {\n    ingProperties: {},\n    clean: {},\n    onEnd: {}\n  };\n\n  this.css({\n    position: 'absolute'\n  });\n};\n\n// trigger specified handler for event type\nproto.handleEvent = function( event ) {\n  var method = 'on' + event.type;\n  if ( this[ method ] ) {\n    this[ method ]( event );\n  }\n};\n\nproto.getSize = function() {\n  this.size = getSize( this.element );\n};\n\n/**\n * apply CSS styles to element\n * @param {Object} style\n */\nproto.css = function( style ) {\n  var elemStyle = this.element.style;\n\n  for ( var prop in style ) {\n    // use vendor property if available\n    var supportedProp = vendorProperties[ prop ] || prop;\n    elemStyle[ supportedProp ] = style[ prop ];\n  }\n};\n\n // measure position, and sets it\nproto.getPosition = function() {\n  var style = getComputedStyle( this.element );\n  var isOriginLeft = this.layout._getOption('originLeft');\n  var isOriginTop = this.layout._getOption('originTop');\n  var xValue = style[ isOriginLeft ? 'left' : 'right' ];\n  var yValue = style[ isOriginTop ? 'top' : 'bottom' ];\n  var x = parseFloat( xValue );\n  var y = parseFloat( yValue );\n  // convert percent to pixels\n  var layoutSize = this.layout.size;\n  if ( xValue.indexOf('%') != -1 ) {\n    x = ( x / 100 ) * layoutSize.width;\n  }\n  if ( yValue.indexOf('%') != -1 ) {\n    y = ( y / 100 ) * layoutSize.height;\n  }\n  // clean up 'auto' or other non-integer values\n  x = isNaN( x ) ? 0 : x;\n  y = isNaN( y ) ? 0 : y;\n  // remove padding from measurement\n  x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;\n  y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;\n\n  this.position.x = x;\n  this.position.y = y;\n};\n\n// set settled position, apply padding\nproto.layoutPosition = function() {\n  var layoutSize = this.layout.size;\n  var style = {};\n  var isOriginLeft = this.layout._getOption('originLeft');\n  var isOriginTop = this.layout._getOption('originTop');\n\n  // x\n  var xPadding = isOriginLeft ? 'paddingLeft' : 'paddingRight';\n  var xProperty = isOriginLeft ? 'left' : 'right';\n  var xResetProperty = isOriginLeft ? 'right' : 'left';\n\n  var x = this.position.x + layoutSize[ xPadding ];\n  // set in percentage or pixels\n  style[ xProperty ] = this.getXValue( x );\n  // reset other property\n  style[ xResetProperty ] = '';\n\n  // y\n  var yPadding = isOriginTop ? 'paddingTop' : 'paddingBottom';\n  var yProperty = isOriginTop ? 'top' : 'bottom';\n  var yResetProperty = isOriginTop ? 'bottom' : 'top';\n\n  var y = this.position.y + layoutSize[ yPadding ];\n  // set in percentage or pixels\n  style[ yProperty ] = this.getYValue( y );\n  // reset other property\n  style[ yResetProperty ] = '';\n\n  this.css( style );\n  this.emitEvent( 'layout', [ this ] );\n};\n\nproto.getXValue = function( x ) {\n  var isHorizontal = this.layout._getOption('horizontal');\n  return this.layout.options.percentPosition && !isHorizontal ?\n    ( ( x / this.layout.size.width ) * 100 ) + '%' : x + 'px';\n};\n\nproto.getYValue = function( y ) {\n  var isHorizontal = this.layout._getOption('horizontal');\n  return this.layout.options.percentPosition && isHorizontal ?\n    ( ( y / this.layout.size.height ) * 100 ) + '%' : y + 'px';\n};\n\nproto._transitionTo = function( x, y ) {\n  this.getPosition();\n  // get current x & y from top/left\n  var curX = this.position.x;\n  var curY = this.position.y;\n\n  var didNotMove = x == this.position.x && y == this.position.y;\n\n  // save end position\n  this.setPosition( x, y );\n\n  // if did not move and not transitioning, just go to layout\n  if ( didNotMove && !this.isTransitioning ) {\n    this.layoutPosition();\n    return;\n  }\n\n  var transX = x - curX;\n  var transY = y - curY;\n  var transitionStyle = {};\n  transitionStyle.transform = this.getTranslate( transX, transY );\n\n  this.transition({\n    to: transitionStyle,\n    onTransitionEnd: {\n      transform: this.layoutPosition\n    },\n    isCleaning: true\n  });\n};\n\nproto.getTranslate = function( x, y ) {\n  // flip cooridinates if origin on right or bottom\n  var isOriginLeft = this.layout._getOption('originLeft');\n  var isOriginTop = this.layout._getOption('originTop');\n  x = isOriginLeft ? x : -x;\n  y = isOriginTop ? y : -y;\n  return 'translate3d(' + x + 'px, ' + y + 'px, 0)';\n};\n\n// non transition + transform support\nproto.goTo = function( x, y ) {\n  this.setPosition( x, y );\n  this.layoutPosition();\n};\n\nproto.moveTo = proto._transitionTo;\n\nproto.setPosition = function( x, y ) {\n  this.position.x = parseFloat( x );\n  this.position.y = parseFloat( y );\n};\n\n// ----- transition ----- //\n\n/**\n * @param {Object} style - CSS\n * @param {Function} onTransitionEnd\n */\n\n// non transition, just trigger callback\nproto._nonTransition = function( args ) {\n  this.css( args.to );\n  if ( args.isCleaning ) {\n    this._removeStyles( args.to );\n  }\n  for ( var prop in args.onTransitionEnd ) {\n    args.onTransitionEnd[ prop ].call( this );\n  }\n};\n\n/**\n * proper transition\n * @param {Object} args - arguments\n *   @param {Object} to - style to transition to\n *   @param {Object} from - style to start transition from\n *   @param {Boolean} isCleaning - removes transition styles after transition\n *   @param {Function} onTransitionEnd - callback\n */\nproto.transition = function( args ) {\n  // redirect to nonTransition if no transition duration\n  if ( !parseFloat( this.layout.options.transitionDuration ) ) {\n    this._nonTransition( args );\n    return;\n  }\n\n  var _transition = this._transn;\n  // keep track of onTransitionEnd callback by css property\n  for ( var prop in args.onTransitionEnd ) {\n    _transition.onEnd[ prop ] = args.onTransitionEnd[ prop ];\n  }\n  // keep track of properties that are transitioning\n  for ( prop in args.to ) {\n    _transition.ingProperties[ prop ] = true;\n    // keep track of properties to clean up when transition is done\n    if ( args.isCleaning ) {\n      _transition.clean[ prop ] = true;\n    }\n  }\n\n  // set from styles\n  if ( args.from ) {\n    this.css( args.from );\n    // force redraw. http://blog.alexmaccaw.com/css-transitions\n    var h = this.element.offsetHeight;\n    // hack for JSHint to hush about unused var\n    h = null;\n  }\n  // enable transition\n  this.enableTransition( args.to );\n  // set styles that are transitioning\n  this.css( args.to );\n\n  this.isTransitioning = true;\n\n};\n\n// dash before all cap letters, including first for\n// WebkitTransform => -webkit-transform\nfunction toDashedAll( str ) {\n  return str.replace( /([A-Z])/g, function( $1 ) {\n    return '-' + $1.toLowerCase();\n  });\n}\n\nvar transitionProps = 'opacity,' + toDashedAll( transformProperty );\n\nproto.enableTransition = function(/* style */) {\n  // HACK changing transitionProperty during a transition\n  // will cause transition to jump\n  if ( this.isTransitioning ) {\n    return;\n  }\n\n  // make `transition: foo, bar, baz` from style object\n  // HACK un-comment this when enableTransition can work\n  // while a transition is happening\n  // var transitionValues = [];\n  // for ( var prop in style ) {\n  //   // dash-ify camelCased properties like WebkitTransition\n  //   prop = vendorProperties[ prop ] || prop;\n  //   transitionValues.push( toDashedAll( prop ) );\n  // }\n  // munge number to millisecond, to match stagger\n  var duration = this.layout.options.transitionDuration;\n  duration = typeof duration == 'number' ? duration + 'ms' : duration;\n  // enable transition styles\n  this.css({\n    transitionProperty: transitionProps,\n    transitionDuration: duration,\n    transitionDelay: this.staggerDelay || 0\n  });\n  // listen for transition end event\n  this.element.addEventListener( transitionEndEvent, this, false );\n};\n\n// ----- events ----- //\n\nproto.onwebkitTransitionEnd = function( event ) {\n  this.ontransitionend( event );\n};\n\nproto.onotransitionend = function( event ) {\n  this.ontransitionend( event );\n};\n\n// properties that I munge to make my life easier\nvar dashedVendorProperties = {\n  '-webkit-transform': 'transform'\n};\n\nproto.ontransitionend = function( event ) {\n  // disregard bubbled events from children\n  if ( event.target !== this.element ) {\n    return;\n  }\n  var _transition = this._transn;\n  // get property name of transitioned property, convert to prefix-free\n  var propertyName = dashedVendorProperties[ event.propertyName ] || event.propertyName;\n\n  // remove property that has completed transitioning\n  delete _transition.ingProperties[ propertyName ];\n  // check if any properties are still transitioning\n  if ( isEmptyObj( _transition.ingProperties ) ) {\n    // all properties have completed transitioning\n    this.disableTransition();\n  }\n  // clean style\n  if ( propertyName in _transition.clean ) {\n    // clean up style\n    this.element.style[ event.propertyName ] = '';\n    delete _transition.clean[ propertyName ];\n  }\n  // trigger onTransitionEnd callback\n  if ( propertyName in _transition.onEnd ) {\n    var onTransitionEnd = _transition.onEnd[ propertyName ];\n    onTransitionEnd.call( this );\n    delete _transition.onEnd[ propertyName ];\n  }\n\n  this.emitEvent( 'transitionEnd', [ this ] );\n};\n\nproto.disableTransition = function() {\n  this.removeTransitionStyles();\n  this.element.removeEventListener( transitionEndEvent, this, false );\n  this.isTransitioning = false;\n};\n\n/**\n * removes style property from element\n * @param {Object} style\n**/\nproto._removeStyles = function( style ) {\n  // clean up transition styles\n  var cleanStyle = {};\n  for ( var prop in style ) {\n    cleanStyle[ prop ] = '';\n  }\n  this.css( cleanStyle );\n};\n\nvar cleanTransitionStyle = {\n  transitionProperty: '',\n  transitionDuration: '',\n  transitionDelay: ''\n};\n\nproto.removeTransitionStyles = function() {\n  // remove transition\n  this.css( cleanTransitionStyle );\n};\n\n// ----- stagger ----- //\n\nproto.stagger = function( delay ) {\n  delay = isNaN( delay ) ? 0 : delay;\n  this.staggerDelay = delay + 'ms';\n};\n\n// ----- show/hide/remove ----- //\n\n// remove element from DOM\nproto.removeElem = function() {\n  this.element.parentNode.removeChild( this.element );\n  // remove display: none\n  this.css({ display: '' });\n  this.emitEvent( 'remove', [ this ] );\n};\n\nproto.remove = function() {\n  // just remove element if no transition support or no transition\n  if ( !transitionProperty || !parseFloat( this.layout.options.transitionDuration ) ) {\n    this.removeElem();\n    return;\n  }\n\n  // start transition\n  this.once( 'transitionEnd', function() {\n    this.removeElem();\n  });\n  this.hide();\n};\n\nproto.reveal = function() {\n  delete this.isHidden;\n  // remove display: none\n  this.css({ display: '' });\n\n  var options = this.layout.options;\n\n  var onTransitionEnd = {};\n  var transitionEndProperty = this.getHideRevealTransitionEndProperty('visibleStyle');\n  onTransitionEnd[ transitionEndProperty ] = this.onRevealTransitionEnd;\n\n  this.transition({\n    from: options.hiddenStyle,\n    to: options.visibleStyle,\n    isCleaning: true,\n    onTransitionEnd: onTransitionEnd\n  });\n};\n\nproto.onRevealTransitionEnd = function() {\n  // check if still visible\n  // during transition, item may have been hidden\n  if ( !this.isHidden ) {\n    this.emitEvent('reveal');\n  }\n};\n\n/**\n * get style property use for hide/reveal transition end\n * @param {String} styleProperty - hiddenStyle/visibleStyle\n * @returns {String}\n */\nproto.getHideRevealTransitionEndProperty = function( styleProperty ) {\n  var optionStyle = this.layout.options[ styleProperty ];\n  // use opacity\n  if ( optionStyle.opacity ) {\n    return 'opacity';\n  }\n  // get first property\n  for ( var prop in optionStyle ) {\n    return prop;\n  }\n};\n\nproto.hide = function() {\n  // set flag\n  this.isHidden = true;\n  // remove display: none\n  this.css({ display: '' });\n\n  var options = this.layout.options;\n\n  var onTransitionEnd = {};\n  var transitionEndProperty = this.getHideRevealTransitionEndProperty('hiddenStyle');\n  onTransitionEnd[ transitionEndProperty ] = this.onHideTransitionEnd;\n\n  this.transition({\n    from: options.visibleStyle,\n    to: options.hiddenStyle,\n    // keep hidden stuff hidden\n    isCleaning: true,\n    onTransitionEnd: onTransitionEnd\n  });\n};\n\nproto.onHideTransitionEnd = function() {\n  // check if still hidden\n  // during transition, item may have been un-hidden\n  if ( this.isHidden ) {\n    this.css({ display: 'none' });\n    this.emitEvent('hide');\n  }\n};\n\nproto.destroy = function() {\n  this.css({\n    position: '',\n    left: '',\n    right: '',\n    top: '',\n    bottom: '',\n    transition: '',\n    transform: ''\n  });\n};\n\nreturn Item;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/outlayer/item.js\n// module id = 35\n// module chunks = 0\n//# sourceURL=webpack:///./~/outlayer/item.js?")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Isotope LayoutMode\n */\n\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /*globals define, module, require */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(30),\n        __webpack_require__(33)\n      ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      require('get-size'),\n      require('outlayer')\n    );\n  } else {\n    // browser global\n    window.Isotope = window.Isotope || {};\n    window.Isotope.LayoutMode = factory(\n      window.getSize,\n      window.Outlayer\n    );\n  }\n\n}( window, function factory( getSize, Outlayer ) {\n  'use strict';\n\n  // layout mode class\n  function LayoutMode( isotope ) {\n    this.isotope = isotope;\n    // link properties\n    if ( isotope ) {\n      this.options = isotope.options[ this.namespace ];\n      this.element = isotope.element;\n      this.items = isotope.filteredItems;\n      this.size = isotope.size;\n    }\n  }\n\n  var proto = LayoutMode.prototype;\n\n  /**\n   * some methods should just defer to default Outlayer method\n   * and reference the Isotope instance as `this`\n  **/\n  var facadeMethods = [\n    '_resetLayout',\n    '_getItemLayoutPosition',\n    '_manageStamp',\n    '_getContainerSize',\n    '_getElementOffset',\n    'needsResizeLayout',\n    '_getOption'\n  ];\n\n  facadeMethods.forEach( function( methodName ) {\n    proto[ methodName ] = function() {\n      return Outlayer.prototype[ methodName ].apply( this.isotope, arguments );\n    };\n  });\n\n  // -----  ----- //\n\n  // for horizontal layout modes, check vertical size\n  proto.needsVerticalResizeLayout = function() {\n    // don't trigger if size did not change\n    var size = getSize( this.isotope.element );\n    // check that this.size and size are there\n    // IE8 triggers resize on body size change, so they might not be\n    var hasSizes = this.isotope.size && size;\n    return hasSizes && size.innerHeight != this.isotope.size.innerHeight;\n  };\n\n  // ----- measurements ----- //\n\n  proto._getMeasurement = function() {\n    this.isotope._getMeasurement.apply( this, arguments );\n  };\n\n  proto.getColumnWidth = function() {\n    this.getSegmentSize( 'column', 'Width' );\n  };\n\n  proto.getRowHeight = function() {\n    this.getSegmentSize( 'row', 'Height' );\n  };\n\n  /**\n   * get columnWidth or rowHeight\n   * segment: 'column' or 'row'\n   * size 'Width' or 'Height'\n  **/\n  proto.getSegmentSize = function( segment, size ) {\n    var segmentName = segment + size;\n    var outerSize = 'outer' + size;\n    // columnWidth / outerWidth // rowHeight / outerHeight\n    this._getMeasurement( segmentName, outerSize );\n    // got rowHeight or columnWidth, we can chill\n    if ( this[ segmentName ] ) {\n      return;\n    }\n    // fall back to item of first element\n    var firstItemSize = this.getFirstItemSize();\n    this[ segmentName ] = firstItemSize && firstItemSize[ outerSize ] ||\n      // or size of container\n      this.isotope.size[ 'inner' + size ];\n  };\n\n  proto.getFirstItemSize = function() {\n    var firstItem = this.isotope.filteredItems[0];\n    return firstItem && firstItem.element && getSize( firstItem.element );\n  };\n\n  // ----- methods that should reference isotope ----- //\n\n  proto.layout = function() {\n    this.isotope.layout.apply( this.isotope, arguments );\n  };\n\n  proto.getSize = function() {\n    this.isotope.getSize();\n    this.size = this.isotope.size;\n  };\n\n  // -------------------------- create -------------------------- //\n\n  LayoutMode.modes = {};\n\n  LayoutMode.create = function( namespace, options ) {\n\n    function Mode() {\n      LayoutMode.apply( this, arguments );\n    }\n\n    Mode.prototype = Object.create( proto );\n    Mode.prototype.constructor = Mode;\n\n    // default options\n    if ( options ) {\n      Mode.options = options;\n    }\n\n    Mode.prototype.namespace = namespace;\n    // register in Isotope\n    LayoutMode.modes[ namespace ] = Mode;\n\n    return Mode;\n  };\n\n  return LayoutMode;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isotope-layout/js/layout-mode.js\n// module id = 36\n// module chunks = 0\n//# sourceURL=webpack:///./~/isotope-layout/js/layout-mode.js?")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Masonry layout mode\n * sub-classes Masonry\n * http://masonry.desandro.com\n */\n\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /*globals define, module, require */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(36),\n        __webpack_require__(38)\n      ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      require('../layout-mode'),\n      require('masonry-layout')\n    );\n  } else {\n    // browser global\n    factory(\n      window.Isotope.LayoutMode,\n      window.Masonry\n    );\n  }\n\n}( window, function factory( LayoutMode, Masonry ) {\n'use strict';\n\n// -------------------------- masonryDefinition -------------------------- //\n\n  // create an Outlayer layout class\n  var MasonryMode = LayoutMode.create('masonry');\n\n  var proto = MasonryMode.prototype;\n\n  var keepModeMethods = {\n    _getElementOffset: true,\n    layout: true,\n    _getMeasurement: true\n  };\n\n  // inherit Masonry prototype\n  for ( var method in Masonry.prototype ) {\n    // do not inherit mode methods\n    if ( !keepModeMethods[ method ] ) {\n      proto[ method ] = Masonry.prototype[ method ];\n    }\n  }\n\n  var measureColumns = proto.measureColumns;\n  proto.measureColumns = function() {\n    // set items, used if measuring first item\n    this.items = this.isotope.filteredItems;\n    measureColumns.call( this );\n  };\n\n  // point to mode options for fitWidth\n  var _getOption = proto._getOption;\n  proto._getOption = function( option ) {\n    if ( option == 'fitWidth' ) {\n      return this.options.isFitWidth !== undefined ?\n        this.options.isFitWidth : this.options.fitWidth;\n    }\n    return _getOption.apply( this.isotope, arguments );\n  };\n\n  return MasonryMode;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isotope-layout/js/layout-modes/masonry.js\n// module id = 37\n// module chunks = 0\n//# sourceURL=webpack:///./~/isotope-layout/js/layout-modes/masonry.js?")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Masonry v4.2.0\n * Cascading grid layout library\n * http://masonry.desandro.com\n * MIT License\n * by David DeSandro\n */\n\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /*globals define, module, require */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(33),\n        __webpack_require__(30)\n      ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      require('outlayer'),\n      require('get-size')\n    );\n  } else {\n    // browser global\n    window.Masonry = factory(\n      window.Outlayer,\n      window.getSize\n    );\n  }\n\n}( window, function factory( Outlayer, getSize ) {\n\n'use strict';\n\n// -------------------------- masonryDefinition -------------------------- //\n\n  // create an Outlayer layout class\n  var Masonry = Outlayer.create('masonry');\n  // isFitWidth -> fitWidth\n  Masonry.compatOptions.fitWidth = 'isFitWidth';\n\n  var proto = Masonry.prototype;\n\n  proto._resetLayout = function() {\n    this.getSize();\n    this._getMeasurement( 'columnWidth', 'outerWidth' );\n    this._getMeasurement( 'gutter', 'outerWidth' );\n    this.measureColumns();\n\n    // reset column Y\n    this.colYs = [];\n    for ( var i=0; i < this.cols; i++ ) {\n      this.colYs.push( 0 );\n    }\n\n    this.maxY = 0;\n    this.horizontalColIndex = 0;\n  };\n\n  proto.measureColumns = function() {\n    this.getContainerWidth();\n    // if columnWidth is 0, default to outerWidth of first item\n    if ( !this.columnWidth ) {\n      var firstItem = this.items[0];\n      var firstItemElem = firstItem && firstItem.element;\n      // columnWidth fall back to item of first element\n      this.columnWidth = firstItemElem && getSize( firstItemElem ).outerWidth ||\n        // if first elem has no width, default to size of container\n        this.containerWidth;\n    }\n\n    var columnWidth = this.columnWidth += this.gutter;\n\n    // calculate columns\n    var containerWidth = this.containerWidth + this.gutter;\n    var cols = containerWidth / columnWidth;\n    // fix rounding errors, typically with gutters\n    var excess = columnWidth - containerWidth % columnWidth;\n    // if overshoot is less than a pixel, round up, otherwise floor it\n    var mathMethod = excess && excess < 1 ? 'round' : 'floor';\n    cols = Math[ mathMethod ]( cols );\n    this.cols = Math.max( cols, 1 );\n  };\n\n  proto.getContainerWidth = function() {\n    // container is parent if fit width\n    var isFitWidth = this._getOption('fitWidth');\n    var container = isFitWidth ? this.element.parentNode : this.element;\n    // check that this.size and size are there\n    // IE8 triggers resize on body size change, so they might not be\n    var size = getSize( container );\n    this.containerWidth = size && size.innerWidth;\n  };\n\n  proto._getItemLayoutPosition = function( item ) {\n    item.getSize();\n    // how many columns does this brick span\n    var remainder = item.size.outerWidth % this.columnWidth;\n    var mathMethod = remainder && remainder < 1 ? 'round' : 'ceil';\n    // round if off by 1 pixel, otherwise use ceil\n    var colSpan = Math[ mathMethod ]( item.size.outerWidth / this.columnWidth );\n    colSpan = Math.min( colSpan, this.cols );\n    // use horizontal or top column position\n    var colPosMethod = this.options.horizontalOrder ?\n      '_getHorizontalColPosition' : '_getTopColPosition';\n    var colPosition = this[ colPosMethod ]( colSpan, item );\n    // position the brick\n    var position = {\n      x: this.columnWidth * colPosition.col,\n      y: colPosition.y\n    };\n    // apply setHeight to necessary columns\n    var setHeight = colPosition.y + item.size.outerHeight;\n    var setMax = colSpan + colPosition.col;\n    for ( var i = colPosition.col; i < setMax; i++ ) {\n      this.colYs[i] = setHeight;\n    }\n\n    return position;\n  };\n\n  proto._getTopColPosition = function( colSpan ) {\n    var colGroup = this._getTopColGroup( colSpan );\n    // get the minimum Y value from the columns\n    var minimumY = Math.min.apply( Math, colGroup );\n\n    return {\n      col: colGroup.indexOf( minimumY ),\n      y: minimumY,\n    };\n  };\n\n  /**\n   * @param {Number} colSpan - number of columns the element spans\n   * @returns {Array} colGroup\n   */\n  proto._getTopColGroup = function( colSpan ) {\n    if ( colSpan < 2 ) {\n      // if brick spans only one column, use all the column Ys\n      return this.colYs;\n    }\n\n    var colGroup = [];\n    // how many different places could this brick fit horizontally\n    var groupCount = this.cols + 1 - colSpan;\n    // for each group potential horizontal position\n    for ( var i = 0; i < groupCount; i++ ) {\n      colGroup[i] = this._getColGroupY( i, colSpan );\n    }\n    return colGroup;\n  };\n\n  proto._getColGroupY = function( col, colSpan ) {\n    if ( colSpan < 2 ) {\n      return this.colYs[ col ];\n    }\n    // make an array of colY values for that one group\n    var groupColYs = this.colYs.slice( col, col + colSpan );\n    // and get the max value of the array\n    return Math.max.apply( Math, groupColYs );\n  };\n\n  // get column position based on horizontal index. #873\n  proto._getHorizontalColPosition = function( colSpan, item ) {\n    var col = this.horizontalColIndex % this.cols;\n    var isOver = colSpan > 1 && col + colSpan > this.cols;\n    // shift to next row if item can't fit on current row\n    col = isOver ? 0 : col;\n    // don't let zero-size items take up space\n    var hasSize = item.size.outerWidth && item.size.outerHeight;\n    this.horizontalColIndex = hasSize ? col + colSpan : this.horizontalColIndex;\n\n    return {\n      col: col,\n      y: this._getColGroupY( col, colSpan ),\n    };\n  };\n\n  proto._manageStamp = function( stamp ) {\n    var stampSize = getSize( stamp );\n    var offset = this._getElementOffset( stamp );\n    // get the columns that this stamp affects\n    var isOriginLeft = this._getOption('originLeft');\n    var firstX = isOriginLeft ? offset.left : offset.right;\n    var lastX = firstX + stampSize.outerWidth;\n    var firstCol = Math.floor( firstX / this.columnWidth );\n    firstCol = Math.max( 0, firstCol );\n    var lastCol = Math.floor( lastX / this.columnWidth );\n    // lastCol should not go over if multiple of columnWidth #425\n    lastCol -= lastX % this.columnWidth ? 0 : 1;\n    lastCol = Math.min( this.cols - 1, lastCol );\n    // set colYs to bottom of the stamp\n\n    var isOriginTop = this._getOption('originTop');\n    var stampMaxY = ( isOriginTop ? offset.top : offset.bottom ) +\n      stampSize.outerHeight;\n    for ( var i = firstCol; i <= lastCol; i++ ) {\n      this.colYs[i] = Math.max( stampMaxY, this.colYs[i] );\n    }\n  };\n\n  proto._getContainerSize = function() {\n    this.maxY = Math.max.apply( Math, this.colYs );\n    var size = {\n      height: this.maxY\n    };\n\n    if ( this._getOption('fitWidth') ) {\n      size.width = this._getContainerFitWidth();\n    }\n\n    return size;\n  };\n\n  proto._getContainerFitWidth = function() {\n    var unusedCols = 0;\n    // count unused columns\n    var i = this.cols;\n    while ( --i ) {\n      if ( this.colYs[i] !== 0 ) {\n        break;\n      }\n      unusedCols++;\n    }\n    // fit container to columns that have been used\n    return ( this.cols - unusedCols ) * this.columnWidth - this.gutter;\n  };\n\n  proto.needsResizeLayout = function() {\n    var previousWidth = this.containerWidth;\n    this.getContainerWidth();\n    return previousWidth != this.containerWidth;\n  };\n\n  return Masonry;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/masonry-layout/masonry.js\n// module id = 38\n// module chunks = 0\n//# sourceURL=webpack:///./~/masonry-layout/masonry.js?")},function(module,exports,__webpack_require__){
eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * fitRows layout mode\n */\n\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /*globals define, module, require */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(36)\n      ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if ( typeof exports == 'object' ) {\n    // CommonJS\n    module.exports = factory(\n      require('../layout-mode')\n    );\n  } else {\n    // browser global\n    factory(\n      window.Isotope.LayoutMode\n    );\n  }\n\n}( window, function factory( LayoutMode ) {\n'use strict';\n\nvar FitRows = LayoutMode.create('fitRows');\n\nvar proto = FitRows.prototype;\n\nproto._resetLayout = function() {\n  this.x = 0;\n  this.y = 0;\n  this.maxY = 0;\n  this._getMeasurement( 'gutter', 'outerWidth' );\n};\n\nproto._getItemLayoutPosition = function( item ) {\n  item.getSize();\n\n  var itemWidth = item.size.outerWidth + this.gutter;\n  // if this element cannot fit in the current row\n  var containerWidth = this.isotope.size.innerWidth + this.gutter;\n  if ( this.x !== 0 && itemWidth + this.x > containerWidth ) {\n    this.x = 0;\n    this.y = this.maxY;\n  }\n\n  var position = {\n    x: this.x,\n    y: this.y\n  };\n\n  this.maxY = Math.max( this.maxY, this.y + item.size.outerHeight );\n  this.x += itemWidth;\n\n  return position;\n};\n\nproto._getContainerSize = function() {\n  return { height: this.maxY };\n};\n\nreturn FitRows;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isotope-layout/js/layout-modes/fit-rows.js\n// module id = 39\n// module chunks = 0\n//# sourceURL=webpack:///./~/isotope-layout/js/layout-modes/fit-rows.js?")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * vertical layout mode\n */\n\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /*globals define, module, require */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(36)\n      ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      require('../layout-mode')\n    );\n  } else {\n    // browser global\n    factory(\n      window.Isotope.LayoutMode\n    );\n  }\n\n}( window, function factory( LayoutMode ) {\n'use strict';\n\nvar Vertical = LayoutMode.create( 'vertical', {\n  horizontalAlignment: 0\n});\n\nvar proto = Vertical.prototype;\n\nproto._resetLayout = function() {\n  this.y = 0;\n};\n\nproto._getItemLayoutPosition = function( item ) {\n  item.getSize();\n  var x = ( this.isotope.size.innerWidth - item.size.outerWidth ) *\n    this.options.horizontalAlignment;\n  var y = this.y;\n  this.y += item.size.outerHeight;\n  return { x: x, y: y };\n};\n\nproto._getContainerSize = function() {\n  return { height: this.y };\n};\n\nreturn Vertical;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isotope-layout/js/layout-modes/vertical.js\n// module id = 40\n// module chunks = 0\n//# sourceURL=webpack:///./~/isotope-layout/js/layout-modes/vertical.js?")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Isotope Item\n**/\n\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /*globals define, module, require */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(33)\n      ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      require('outlayer')\n    );\n  } else {\n    // browser global\n    window.Isotope = window.Isotope || {};\n    window.Isotope.Item = factory(\n      window.Outlayer\n    );\n  }\n\n}( window, function factory( Outlayer ) {\n'use strict';\n\n// -------------------------- Item -------------------------- //\n\n// sub-class Outlayer Item\nfunction Item() {\n  Outlayer.Item.apply( this, arguments );\n}\n\nvar proto = Item.prototype = Object.create( Outlayer.Item.prototype );\n\nvar _create = proto._create;\nproto._create = function() {\n  // assign id, used for original-order sorting\n  this.id = this.layout.itemGUID++;\n  _create.call( this );\n  this.sortData = {};\n};\n\nproto.updateSortData = function() {\n  if ( this.isIgnored ) {\n    return;\n  }\n  // default sorters\n  this.sortData.id = this.id;\n  // for backward compatibility\n  this.sortData['original-order'] = this.id;\n  this.sortData.random = Math.random();\n  // go thru getSortData obj and apply the sorters\n  var getSortData = this.layout.options.getSortData;\n  var sorters = this.layout._sorters;\n  for ( var key in getSortData ) {\n    var sorter = sorters[ key ];\n    this.sortData[ key ] = sorter( this.element, this );\n  }\n};\n\nvar _destroy = proto.destroy;\nproto.destroy = function() {\n  // call super\n  _destroy.apply( this, arguments );\n  // reset display, #741\n  this.css({\n    display: ''\n  });\n};\n\nreturn Item;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isotope-layout/js/item.js\n// module id = 41\n// module chunks = 0\n//# sourceURL=webpack:///./~/isotope-layout/js/item.js?")},function(module,exports,__webpack_require__){eval("var plyr = __webpack_require__(25);\n\nfunction VideoModal(node){\n    this.node = node;\n    this.init();\n}\n\nVideoModal.prototype.init = function(){\n    var cxt = this;\n    this.playBtn = this.node.querySelector('.video-prompt--btn');\n    this.heading = this.node.querySelector('.centered-heading');\n    this.videoPlayer = this.node.querySelector('[data-type]');\n    this.videoModalHook = document.getElementById('videoModalHook');\n    this.videoModalBg = document.getElementById('videoModalBgHook');\n    this.closeBtn = this.node.querySelector('.video-modal--close');\n\n    this.videoModalHook.addEventListener('click', this.triggerModal.bind(this));\n    this.closeBtn.addEventListener('click', this.closeModal.bind(this));\n\n    this.vidInstance = plyr.setup(this.videoPlayer,\n        {\n            clickToPlay : false\n        }\n    );\n\n    this.playBtn.addEventListener('click', function(e){\n        e.preventDefault();\n        cxt.vidInstance[0].play();\n        cxt.playBtn.classList.add('remove');\n    });\n\n    this.vidInstance[0].on('pause', function(event) {\n      cxt.playBtn.classList.remove('remove');\n    });\n\n    this.vidInstance[0].on('play', function(event) {\n      cxt.playBtn.classList.add('remove');\n    });\n\n    this.vidInstance[0].on('stop', function(event) {\n      cxt.playBtn.classList.remove('remove');\n    });\n}\n\nVideoModal.prototype.triggerModal = function(e){\n    e.preventDefault();\n    var cxt = this;\n\n    this.videoModalBg.style.display = 'block';\n    this.videoModalBg.style.zIndex = 8;\n    this.videoModalBg.classList.add('reveal');\n\n    this.node.style.zIndex = 9;\n    this.node.classList.add('reveal');\n\n    setTimeout(function(){\n        cxt.vidInstance[0].play();\n        cxt.playBtn.classList.add('remove');\n    }, 400);\n}\n\nVideoModal.prototype.closeModal = function(e){\n    var cxt = this;\n\n    this.videoModalBg.classList.remove('reveal');\n    setTimeout(function(){\n        cxt.videoModalBg.style.display = 'none';\n        cxt.videoModalBg.style.zIndex = -1;\n    }, 400);\n\n    this.node.classList.remove('reveal');\n    setTimeout(function(){\n        cxt.node.style.zIndex = -1;\n    }, 400);\n\n    this.vidInstance[0].pause();\n}\n\nmodule.exports = VideoModal;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./assets/scripts/widgets/video-modal.js\n// module id = 42\n// module chunks = 0\n//# sourceURL=webpack:///./assets/scripts/widgets/video-modal.js?")},function(module,exports,__webpack_require__){eval("var debounce = __webpack_require__(17);\n\nfunction EqualHeights(node){\n    this.node = node;\n    this.init();\n}\n\nEqualHeights.prototype.init = function(){\n    this.eq(false);\n    window.addEventListener('resize', debounce(this.eq.bind(this, true), 50));\n}\n\nEqualHeights.prototype.eq = function(resize){\n    var parent = this.node;\n    var elements = parent.getElementsByClassName(\"eq\"),\n        allHeights = [],\n        i = 0;\n    if(resize === true){\n      for(i = 0; i < elements.length; i++){\n        elements[i].style.height = 'auto';\n      }\n    }\n    for(i = 0; i < elements.length; i++){\n      var elementHeight = elements[i].clientHeight;\n      allHeights.push(elementHeight);\n    }\n    for(i = 0; i < elements.length; i++){\n      elements[i].style.height = Math.max.apply( Math, allHeights) + 'px';\n    }\n}\n\nmodule.exports = EqualHeights;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./assets/scripts/widgets/equal-heights.js\n// module id = 43\n// module chunks = 0\n//# sourceURL=webpack:///./assets/scripts/widgets/equal-heights.js?")},function(module,exports){eval("function Share(node){\n    this.node = node;\n    this.init();\n}\n\nShare.prototype.init = function(){\n\n    var href = window.location.href;\n    var social = this.node.getElementsByTagName('a');\n\n    Array.prototype.forEach.call(social, function(el, index, array){\n    \tel.setAttribute('href', el.getAttribute('href').replace(\"SHAREURL\", href));\n    });\n\n}\n\nmodule.exports = Share;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./assets/scripts/widgets/share.js\n// module id = 44\n// module chunks = 0\n//# sourceURL=webpack:///./assets/scripts/widgets/share.js?")},function(module,exports,__webpack_require__){eval("var plyr = __webpack_require__(25);\n\nfunction VideoDisplay(node){\n    this.node = node;\n    this.selectors();\n    this.init();\n}\n\nVideoDisplay.prototype.selectors = function(){\n    this.css = {\n        states : {\n            'init' : 'initialised'\n        },\n        selectors : {\n            'video' : '.video-display--player'\n        }\n    }\n}\n\nVideoDisplay.prototype.init = function(){\n    var cxt = this;\n    this.videoPlayer = this.node.querySelector('.video-display--player');\n    this.playBtn = this.node.querySelector('.video-prompt--btn');\n\n    this.vidInstance = plyr.setup(this.videoPlayer,\n        {\n            clickToPlay : true\n        }\n    );\n\n    this.playBtn.addEventListener('click', function(e){\n        e.preventDefault();\n        cxt.vidInstance[0].play();\n        cxt.playBtn.classList.add('remove');\n    });\n\n    this.vidInstance[0].on('pause', function(event) {\n      cxt.playBtn.classList.remove('remove');\n    });\n\n    this.vidInstance[0].on('play', function(event) {\n      cxt.playBtn.classList.add('remove');\n    });\n\n    this.vidInstance[0].on('stop', function(event) {\n      cxt.playBtn.classList.remove('remove');\n    });\n}\n\nmodule.exports = VideoDisplay;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./assets/scripts/widgets/video-display.js\n// module id = 45\n// module chunks = 0\n//# sourceURL=webpack:///./assets/scripts/widgets/video-display.js?")},function(module,exports,__webpack_require__){eval("var Swiper = __webpack_require__(21);\n\nfunction FaqCarousel(node){\n    this.node = node;\n    this.init();\n}\n\nFaqCarousel.prototype.init = function(){\n\n    var ww = window.innerWidth;\n    var slider = this.node;\n    var dot_count         = slider.querySelectorAll('.js_slide').length;\n    var dot_container     = slider.querySelector('.js_dots');\n    var dot_list_item     = document.createElement('li');\n\n    var swiper = new Swiper(slider, {\n      slidesPerView: 3,\n      spaceBetween: 30,\n      loop: false,\n      pagination: {\n         el: '.swiper-pagination',\n      },\n      navigation: {\n         nextEl: '.swiper-button-next',\n         prevEl: '.swiper-button-prev',\n      },\n      breakpoints: {\n        998: {\n          slidesPerView: 2,\n          spaceBetween: 20,\n        },\n        500: {\n          slidesPerView: 1,\n          spaceBetween: 10,\n        }\n      }\n    });\n\n}\n\nmodule.exports = FaqCarousel;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./assets/scripts/widgets/faq-carousel.js\n// module id = 46\n// module chunks = 0\n//# sourceURL=webpack:///./assets/scripts/widgets/faq-carousel.js?")},function(module,exports,__webpack_require__){eval("var Promise = __webpack_require__(7);\n\nfunction MoreInfo(node){\n    this.node = node;\n    this.init();\n}\n\nMoreInfo.prototype.init = function(){\n    var cxt = this;\n    this.targetAnchors = this.node.querySelectorAll('[data-target]');\n    this.overlay = document.getElementById('faq-overlay');\n    this.bg = document.getElementById('overlayBackgroundHook');\n    this.overlayTitle = this.overlay.querySelector('h4');\n    this.overlayDesc = this.overlay.querySelector('p');\n    this.qLists = this.node.querySelectorAll('.faqs__q-list');\n\n    [].forEach.call(this.targetAnchors, function(element, index, array){\n        element.addEventListener('click', cxt.getData.bind(cxt));\n    });\n\n    [].forEach.call(this.qLists, function(element, index, array){\n        cxt.loadMore(element);\n    });\n\n    this.getUrl();\n}\n\nMoreInfo.prototype.getData = function(e){\n    var cxt = this;\n    var target = e.currentTarget;\n    this.targetSlug = target.getAttribute('data-faq-slug');\n\n    this.checkJson(this.targetSlug);\n    cxt.setUrl(this.targetSlug);\n}\n\nMoreInfo.prototype.checkJson = function(slug){\n    var cxt = this;\n    this.get('json/faqs.json').then(function(faqs) {\n        for(var i = 0; i < faqs.length; i++) {\n            if(faqs[i].slug == slug) {\n                cxt.buildFaqItem(faqs[i].title, faqs[i].description);\n                cxt.showModal();\n            }\n        }\n    }, function(error) {\n      console.error(\"Failed!\", error);\n    });\n}\n\nMoreInfo.prototype.setUrl = function(slug){\n    if(history.pushState) {\n        history.pushState(null, null, '#' + slug);\n    } else {\n        location.hash = '#' + slug;\n    }\n}\n\nMoreInfo.prototype.getUrl = function(e){\n    var type = window.location.hash.substr(1);\n    this.checkJson(type);\n}\n\nMoreInfo.prototype.showModal = function(){\n    this.bg.classList.add('active');\n    this.bg.style.zIndex = 998;\n    this.overlay.classList.add('active');\n}\n\nMoreInfo.prototype.buildFaqItem = function(title, description){\n    this.overlayTitle.innerText = title;\n    this.overlayDesc.innerText = description;\n}\n\nMoreInfo.prototype.get = function(url) {\n\n  return new Promise(function(resolve, reject) {\n\n    var req = new XMLHttpRequest();\n    req.open('GET', url);\n\n    req.onload = function() {\n\n      if (req.status == 200) {\n        resolve(JSON.parse(req.response));\n      }\n      else {\n        reject(Error(req.statusText));\n      }\n    };\n\n    // Handle network errors\n    req.onerror = function() {\n      reject(Error(\"Network Error\"));\n    };\n\n    req.send();\n  });\n}\n\nMoreInfo.prototype.loadMore = function(element){\n    var cxt = this;\n    var items = element.querySelectorAll('.faqs__q-list--item');\n    var itemsUl = element.querySelector('.faqs__q-list--ul');\n    var loadMore = element.querySelector('.faqs__q-list--see-more');\n    var itemsLength = items.length;\n\n    cxt.get('json/faqs.json').then(function(faqs) {\n        loadMore.innerText = 'See ' + (faqs.length - itemsLength) + ' more';\n\n        loadMore.addEventListener('click', function(e){\n            e.preventDefault();\n            var faqsMax = faqs.length; //max number of locations\n\n            if(itemsLength < faqsMax) {\n                for (var i = itemsLength; i < faqsMax; i++) {\n                    var li = document.createElement(\"li\");\n                    var a = document.createElement(\"a\");\n                    li.appendChild(a);\n                    li.classList.add(\"faqs__q-list--item\");\n                    a.innerText = faqs[i].title;\n                    a.setAttribute('data-faq-slug', faqs[i].slug);\n                    a.setAttribute('href', '#' + faqs[i].slug);\n                    itemsUl.appendChild(li);\n                    a.addEventListener('click', cxt.getData.bind(cxt));\n                }\n\n                loadMore.classList.add('disabled');\n            }\n\n        });\n    }, function(error) {\n        console.error(\"Failed!\", error);\n    });\n\n}\n\nmodule.exports = MoreInfo;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./assets/scripts/widgets/faq-more-info.js\n// module id = 47\n// module chunks = 0\n//# sourceURL=webpack:///./assets/scripts/widgets/faq-more-info.js?")}]);